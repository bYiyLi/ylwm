package com.yi.ylwm.xcb;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import com.yi.ylwm.xcb.xcb_generic_error_t.ByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;


/**
 * java -jar ./jnaerator-0.12-shaded.jar  -runtime JNA  -mode Maven  -mavenGroupId net.gdface  -mavenArtifactId cassdk_jna  -o jna_code -package com.yi.ylwm.xcb -f  -library LibXcb  /usr/lib/libxcb.so /usr/include/xcb/xcb.h
 */

/**
 * JNA Wrapper for library <b>LibXcb</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface LibXcbLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "libxcb";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(LibXcbLibrary.JNA_LIBRARY_NAME);
	public static final LibXcbLibrary INSTANCE = (LibXcbLibrary) Native.load(LibXcbLibrary.JNA_LIBRARY_NAME, LibXcbLibrary.class);
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_visual_class_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:290</i> */
		public static final int XCB_VISUAL_CLASS_STATIC_GRAY = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:291</i> */
		public static final int XCB_VISUAL_CLASS_GRAY_SCALE = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:292</i> */
		public static final int XCB_VISUAL_CLASS_STATIC_COLOR = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:293</i> */
		public static final int XCB_VISUAL_CLASS_PSEUDO_COLOR = 3;
		/** <i>native declaration : /usr/include/xcb/xproto.h:294</i> */
		public static final int XCB_VISUAL_CLASS_TRUE_COLOR = 4;
		/** <i>native declaration : /usr/include/xcb/xproto.h:295</i> */
		public static final int XCB_VISUAL_CLASS_DIRECT_COLOR = 5;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_event_mask_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:341</i> */
		public static final int XCB_EVENT_MASK_NO_EVENT = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:342</i> */
		public static final int XCB_EVENT_MASK_KEY_PRESS = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:343</i> */
		public static final int XCB_EVENT_MASK_KEY_RELEASE = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:344</i> */
		public static final int XCB_EVENT_MASK_BUTTON_PRESS = 4;
		/** <i>native declaration : /usr/include/xcb/xproto.h:345</i> */
		public static final int XCB_EVENT_MASK_BUTTON_RELEASE = 8;
		/** <i>native declaration : /usr/include/xcb/xproto.h:346</i> */
		public static final int XCB_EVENT_MASK_ENTER_WINDOW = 16;
		/** <i>native declaration : /usr/include/xcb/xproto.h:347</i> */
		public static final int XCB_EVENT_MASK_LEAVE_WINDOW = 32;
		/** <i>native declaration : /usr/include/xcb/xproto.h:348</i> */
		public static final int XCB_EVENT_MASK_POINTER_MOTION = 64;
		/** <i>native declaration : /usr/include/xcb/xproto.h:349</i> */
		public static final int XCB_EVENT_MASK_POINTER_MOTION_HINT = 128;
		/** <i>native declaration : /usr/include/xcb/xproto.h:350</i> */
		public static final int XCB_EVENT_MASK_BUTTON_1_MOTION = 256;
		/** <i>native declaration : /usr/include/xcb/xproto.h:351</i> */
		public static final int XCB_EVENT_MASK_BUTTON_2_MOTION = 512;
		/** <i>native declaration : /usr/include/xcb/xproto.h:352</i> */
		public static final int XCB_EVENT_MASK_BUTTON_3_MOTION = 1024;
		/** <i>native declaration : /usr/include/xcb/xproto.h:353</i> */
		public static final int XCB_EVENT_MASK_BUTTON_4_MOTION = 2048;
		/** <i>native declaration : /usr/include/xcb/xproto.h:354</i> */
		public static final int XCB_EVENT_MASK_BUTTON_5_MOTION = 4096;
		/** <i>native declaration : /usr/include/xcb/xproto.h:355</i> */
		public static final int XCB_EVENT_MASK_BUTTON_MOTION = 8192;
		/** <i>native declaration : /usr/include/xcb/xproto.h:356</i> */
		public static final int XCB_EVENT_MASK_KEYMAP_STATE = 16384;
		/** <i>native declaration : /usr/include/xcb/xproto.h:357</i> */
		public static final int XCB_EVENT_MASK_EXPOSURE = 32768;
		/** <i>native declaration : /usr/include/xcb/xproto.h:358</i> */
		public static final int XCB_EVENT_MASK_VISIBILITY_CHANGE = 65536;
		/** <i>native declaration : /usr/include/xcb/xproto.h:359</i> */
		public static final int XCB_EVENT_MASK_STRUCTURE_NOTIFY = 131072;
		/** <i>native declaration : /usr/include/xcb/xproto.h:360</i> */
		public static final int XCB_EVENT_MASK_RESIZE_REDIRECT = 262144;
		/** <i>native declaration : /usr/include/xcb/xproto.h:361</i> */
		public static final int XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY = 524288;
		/** <i>native declaration : /usr/include/xcb/xproto.h:362</i> */
		public static final int XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT = 1048576;
		/** <i>native declaration : /usr/include/xcb/xproto.h:363</i> */
		public static final int XCB_EVENT_MASK_FOCUS_CHANGE = 2097152;
		/** <i>native declaration : /usr/include/xcb/xproto.h:364</i> */
		public static final int XCB_EVENT_MASK_PROPERTY_CHANGE = 4194304;
		/** <i>native declaration : /usr/include/xcb/xproto.h:365</i> */
		public static final int XCB_EVENT_MASK_COLOR_MAP_CHANGE = 8388608;
		/** <i>native declaration : /usr/include/xcb/xproto.h:366</i> */
		public static final int XCB_EVENT_MASK_OWNER_GRAB_BUTTON = 16777216;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_backing_store_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:370</i> */
		public static final int XCB_BACKING_STORE_NOT_USEFUL = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:371</i> */
		public static final int XCB_BACKING_STORE_WHEN_MAPPED = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:372</i> */
		public static final int XCB_BACKING_STORE_ALWAYS = 2;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_image_order_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:467</i> */
		public static final int XCB_IMAGE_ORDER_LSB_FIRST = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:468</i> */
		public static final int XCB_IMAGE_ORDER_MSB_FIRST = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_mod_mask_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:507</i> */
		public static final int XCB_MOD_MASK_SHIFT = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:508</i> */
		public static final int XCB_MOD_MASK_LOCK = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:509</i> */
		public static final int XCB_MOD_MASK_CONTROL = 4;
		/** <i>native declaration : /usr/include/xcb/xproto.h:510</i> */
		public static final int XCB_MOD_MASK_1 = 8;
		/** <i>native declaration : /usr/include/xcb/xproto.h:511</i> */
		public static final int XCB_MOD_MASK_2 = 16;
		/** <i>native declaration : /usr/include/xcb/xproto.h:512</i> */
		public static final int XCB_MOD_MASK_3 = 32;
		/** <i>native declaration : /usr/include/xcb/xproto.h:513</i> */
		public static final int XCB_MOD_MASK_4 = 64;
		/** <i>native declaration : /usr/include/xcb/xproto.h:514</i> */
		public static final int XCB_MOD_MASK_5 = 128;
		/** <i>native declaration : /usr/include/xcb/xproto.h:515</i> */
		public static final int XCB_MOD_MASK_ANY = 32768;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_key_but_mask_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:519</i> */
		public static final int XCB_KEY_BUT_MASK_SHIFT = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:520</i> */
		public static final int XCB_KEY_BUT_MASK_LOCK = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:521</i> */
		public static final int XCB_KEY_BUT_MASK_CONTROL = 4;
		/** <i>native declaration : /usr/include/xcb/xproto.h:522</i> */
		public static final int XCB_KEY_BUT_MASK_MOD_1 = 8;
		/** <i>native declaration : /usr/include/xcb/xproto.h:523</i> */
		public static final int XCB_KEY_BUT_MASK_MOD_2 = 16;
		/** <i>native declaration : /usr/include/xcb/xproto.h:524</i> */
		public static final int XCB_KEY_BUT_MASK_MOD_3 = 32;
		/** <i>native declaration : /usr/include/xcb/xproto.h:525</i> */
		public static final int XCB_KEY_BUT_MASK_MOD_4 = 64;
		/** <i>native declaration : /usr/include/xcb/xproto.h:526</i> */
		public static final int XCB_KEY_BUT_MASK_MOD_5 = 128;
		/** <i>native declaration : /usr/include/xcb/xproto.h:527</i> */
		public static final int XCB_KEY_BUT_MASK_BUTTON_1 = 256;
		/** <i>native declaration : /usr/include/xcb/xproto.h:528</i> */
		public static final int XCB_KEY_BUT_MASK_BUTTON_2 = 512;
		/** <i>native declaration : /usr/include/xcb/xproto.h:529</i> */
		public static final int XCB_KEY_BUT_MASK_BUTTON_3 = 1024;
		/** <i>native declaration : /usr/include/xcb/xproto.h:530</i> */
		public static final int XCB_KEY_BUT_MASK_BUTTON_4 = 2048;
		/** <i>native declaration : /usr/include/xcb/xproto.h:531</i> */
		public static final int XCB_KEY_BUT_MASK_BUTTON_5 = 4096;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_window_enum_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:535</i> */
		public static final int XCB_WINDOW_NONE = 0;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_button_mask_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:567</i> */
		public static final int XCB_BUTTON_MASK_1 = 256;
		/** <i>native declaration : /usr/include/xcb/xproto.h:568</i> */
		public static final int XCB_BUTTON_MASK_2 = 512;
		/** <i>native declaration : /usr/include/xcb/xproto.h:569</i> */
		public static final int XCB_BUTTON_MASK_3 = 1024;
		/** <i>native declaration : /usr/include/xcb/xproto.h:570</i> */
		public static final int XCB_BUTTON_MASK_4 = 2048;
		/** <i>native declaration : /usr/include/xcb/xproto.h:571</i> */
		public static final int XCB_BUTTON_MASK_5 = 4096;
		/** <i>native declaration : /usr/include/xcb/xproto.h:572</i> */
		public static final int XCB_BUTTON_MASK_ANY = 32768;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_motion_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:604</i> */
		public static final int XCB_MOTION_NORMAL = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:605</i> */
		public static final int XCB_MOTION_HINT = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_notify_detail_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:632</i> */
		public static final int XCB_NOTIFY_DETAIL_ANCESTOR = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:633</i> */
		public static final int XCB_NOTIFY_DETAIL_VIRTUAL = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:634</i> */
		public static final int XCB_NOTIFY_DETAIL_INFERIOR = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:635</i> */
		public static final int XCB_NOTIFY_DETAIL_NONLINEAR = 3;
		/** <i>native declaration : /usr/include/xcb/xproto.h:636</i> */
		public static final int XCB_NOTIFY_DETAIL_NONLINEAR_VIRTUAL = 4;
		/** <i>native declaration : /usr/include/xcb/xproto.h:637</i> */
		public static final int XCB_NOTIFY_DETAIL_POINTER = 5;
		/** <i>native declaration : /usr/include/xcb/xproto.h:638</i> */
		public static final int XCB_NOTIFY_DETAIL_POINTER_ROOT = 6;
		/** <i>native declaration : /usr/include/xcb/xproto.h:639</i> */
		public static final int XCB_NOTIFY_DETAIL_NONE = 7;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_notify_mode_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:643</i> */
		public static final int XCB_NOTIFY_MODE_NORMAL = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:644</i> */
		public static final int XCB_NOTIFY_MODE_GRAB = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:645</i> */
		public static final int XCB_NOTIFY_MODE_UNGRAB = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:646</i> */
		public static final int XCB_NOTIFY_MODE_WHILE_GRABBED = 3;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_visibility_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:765</i> */
		public static final int XCB_VISIBILITY_UNOBSCURED = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:766</i> */
		public static final int XCB_VISIBILITY_PARTIALLY_OBSCURED = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:767</i> */
		public static final int XCB_VISIBILITY_FULLY_OBSCURED = 2;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_place_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:960</i> */
		public static final int XCB_PLACE_ON_TOP = 0;
		/**
		 * < The window is now on top of all siblings.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:963</i>
		 */
		public static final int XCB_PLACE_ON_BOTTOM = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_property_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:991</i> */
		public static final int XCB_PROPERTY_NEW_VALUE = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:992</i> */
		public static final int XCB_PROPERTY_DELETE = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_time_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:1028</i> */
		public static final int XCB_TIME_CURRENT_TIME = 0;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_atom_enum_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:1032</i> */
		public static final int XCB_ATOM_NONE = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1033</i> */
		public static final int XCB_ATOM_ANY = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1034</i> */
		public static final int XCB_ATOM_PRIMARY = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1035</i> */
		public static final int XCB_ATOM_SECONDARY = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1036</i> */
		public static final int XCB_ATOM_ARC = 3;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1037</i> */
		public static final int XCB_ATOM_ATOM = 4;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1038</i> */
		public static final int XCB_ATOM_BITMAP = 5;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1039</i> */
		public static final int XCB_ATOM_CARDINAL = 6;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1040</i> */
		public static final int XCB_ATOM_COLORMAP = 7;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1041</i> */
		public static final int XCB_ATOM_CURSOR = 8;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1042</i> */
		public static final int XCB_ATOM_CUT_BUFFER0 = 9;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1043</i> */
		public static final int XCB_ATOM_CUT_BUFFER1 = 10;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1044</i> */
		public static final int XCB_ATOM_CUT_BUFFER2 = 11;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1045</i> */
		public static final int XCB_ATOM_CUT_BUFFER3 = 12;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1046</i> */
		public static final int XCB_ATOM_CUT_BUFFER4 = 13;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1047</i> */
		public static final int XCB_ATOM_CUT_BUFFER5 = 14;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1048</i> */
		public static final int XCB_ATOM_CUT_BUFFER6 = 15;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1049</i> */
		public static final int XCB_ATOM_CUT_BUFFER7 = 16;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1050</i> */
		public static final int XCB_ATOM_DRAWABLE = 17;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1051</i> */
		public static final int XCB_ATOM_FONT = 18;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1052</i> */
		public static final int XCB_ATOM_INTEGER = 19;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1053</i> */
		public static final int XCB_ATOM_PIXMAP = 20;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1054</i> */
		public static final int XCB_ATOM_POINT = 21;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1055</i> */
		public static final int XCB_ATOM_RECTANGLE = 22;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1056</i> */
		public static final int XCB_ATOM_RESOURCE_MANAGER = 23;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1057</i> */
		public static final int XCB_ATOM_RGB_COLOR_MAP = 24;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1058</i> */
		public static final int XCB_ATOM_RGB_BEST_MAP = 25;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1059</i> */
		public static final int XCB_ATOM_RGB_BLUE_MAP = 26;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1060</i> */
		public static final int XCB_ATOM_RGB_DEFAULT_MAP = 27;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1061</i> */
		public static final int XCB_ATOM_RGB_GRAY_MAP = 28;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1062</i> */
		public static final int XCB_ATOM_RGB_GREEN_MAP = 29;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1063</i> */
		public static final int XCB_ATOM_RGB_RED_MAP = 30;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1064</i> */
		public static final int XCB_ATOM_STRING = 31;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1065</i> */
		public static final int XCB_ATOM_VISUALID = 32;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1066</i> */
		public static final int XCB_ATOM_WINDOW = 33;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1067</i> */
		public static final int XCB_ATOM_WM_COMMAND = 34;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1068</i> */
		public static final int XCB_ATOM_WM_HINTS = 35;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1069</i> */
		public static final int XCB_ATOM_WM_CLIENT_MACHINE = 36;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1070</i> */
		public static final int XCB_ATOM_WM_ICON_NAME = 37;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1071</i> */
		public static final int XCB_ATOM_WM_ICON_SIZE = 38;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1072</i> */
		public static final int XCB_ATOM_WM_NAME = 39;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1073</i> */
		public static final int XCB_ATOM_WM_NORMAL_HINTS = 40;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1074</i> */
		public static final int XCB_ATOM_WM_SIZE_HINTS = 41;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1075</i> */
		public static final int XCB_ATOM_WM_ZOOM_HINTS = 42;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1076</i> */
		public static final int XCB_ATOM_MIN_SPACE = 43;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1077</i> */
		public static final int XCB_ATOM_NORM_SPACE = 44;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1078</i> */
		public static final int XCB_ATOM_MAX_SPACE = 45;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1079</i> */
		public static final int XCB_ATOM_END_SPACE = 46;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1080</i> */
		public static final int XCB_ATOM_SUPERSCRIPT_X = 47;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1081</i> */
		public static final int XCB_ATOM_SUPERSCRIPT_Y = 48;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1082</i> */
		public static final int XCB_ATOM_SUBSCRIPT_X = 49;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1083</i> */
		public static final int XCB_ATOM_SUBSCRIPT_Y = 50;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1084</i> */
		public static final int XCB_ATOM_UNDERLINE_POSITION = 51;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1085</i> */
		public static final int XCB_ATOM_UNDERLINE_THICKNESS = 52;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1086</i> */
		public static final int XCB_ATOM_STRIKEOUT_ASCENT = 53;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1087</i> */
		public static final int XCB_ATOM_STRIKEOUT_DESCENT = 54;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1088</i> */
		public static final int XCB_ATOM_ITALIC_ANGLE = 55;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1089</i> */
		public static final int XCB_ATOM_X_HEIGHT = 56;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1090</i> */
		public static final int XCB_ATOM_QUAD_WIDTH = 57;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1091</i> */
		public static final int XCB_ATOM_WEIGHT = 58;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1092</i> */
		public static final int XCB_ATOM_POINT_SIZE = 59;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1093</i> */
		public static final int XCB_ATOM_RESOLUTION = 60;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1094</i> */
		public static final int XCB_ATOM_COPYRIGHT = 61;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1095</i> */
		public static final int XCB_ATOM_NOTICE = 62;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1096</i> */
		public static final int XCB_ATOM_FONT_NAME = 63;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1097</i> */
		public static final int XCB_ATOM_FAMILY_NAME = 64;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1098</i> */
		public static final int XCB_ATOM_FULL_NAME = 65;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1099</i> */
		public static final int XCB_ATOM_CAP_HEIGHT = 66;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1100</i> */
		public static final int XCB_ATOM_WM_CLASS = 67;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1101</i> */
		public static final int XCB_ATOM_WM_TRANSIENT_FOR = 68;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_colormap_state_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:1140</i> */
		public static final int XCB_COLORMAP_STATE_UNINSTALLED = 0;
		/**
		 * < The colormap was uninstalled.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1143</i>
		 */
		public static final int XCB_COLORMAP_STATE_INSTALLED = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_colormap_enum_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:1149</i> */
		public static final int XCB_COLORMAP_NONE = 0;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_mapping_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:1203</i> */
		public static final int XCB_MAPPING_MODIFIER = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1204</i> */
		public static final int XCB_MAPPING_KEYBOARD = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1205</i> */
		public static final int XCB_MAPPING_POINTER = 2;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_window_class_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:1348</i> */
		public static final int XCB_WINDOW_CLASS_COPY_FROM_PARENT = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1349</i> */
		public static final int XCB_WINDOW_CLASS_INPUT_OUTPUT = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1350</i> */
		public static final int XCB_WINDOW_CLASS_INPUT_ONLY = 2;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_cw_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:1354</i> */
		public static final int XCB_CW_BACK_PIXMAP = 1;
		/**
		 * < Overrides the default background-pixmap. The background pixmap and window must<br>
		 * have the same root and same depth. Any size pixmap can be used, although some<br>
		 * sizes may be faster than others.<br>
		 * If `XCB_BACK_PIXMAP_NONE` is specified, the window has no defined background.<br>
		 * The server may fill the contents with the previous screen contents or with<br>
		 * contents of its own choosing.<br>
		 * If `XCB_BACK_PIXMAP_PARENT_RELATIVE` is specified, the parent's background is<br>
		 * used, but the window must have the same depth as the parent (or a Match error<br>
		 * results).   The parent's background is tracked, and the current version is<br>
		 * used each time the window background is required.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1368</i>
		 */
		public static final int XCB_CW_BACK_PIXEL = 2;
		/**
		 * < Overrides `BackPixmap`. A pixmap of undefined size filled with the specified<br>
		 * background pixel is used for the background. Range-checking is not performed,<br>
		 * the background pixel is truncated to the appropriate number of bits.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1373</i>
		 */
		public static final int XCB_CW_BORDER_PIXMAP = 4;
		/**
		 * < Overrides the default border-pixmap. The border pixmap and window must have the<br>
		 * same root and the same depth. Any size pixmap can be used, although some sizes<br>
		 * may be faster than others.<br>
		 * The special value `XCB_COPY_FROM_PARENT` means the parent's border pixmap is<br>
		 * copied (subsequent changes to the parent's border attribute do not affect the<br>
		 * child), but the window must have the same depth as the parent.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1382</i>
		 */
		public static final int XCB_CW_BORDER_PIXEL = 8;
		/**
		 * < Overrides `BorderPixmap`. A pixmap of undefined size filled with the specified<br>
		 * border pixel is used for the border. Range checking is not performed on the<br>
		 * border-pixel value, it is truncated to the appropriate number of bits.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1387</i>
		 */
		public static final int XCB_CW_BIT_GRAVITY = 16;
		/**
		 * < Defines which region of the window should be retained if the window is resized.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1390</i>
		 */
		public static final int XCB_CW_WIN_GRAVITY = 32;
		/**
		 * < Defines how the window should be repositioned if the parent is resized (see<br>
		 * `ConfigureWindow`).<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1394</i>
		 */
		public static final int XCB_CW_BACKING_STORE = 64;
		/**
		 * < A backing-store of `WhenMapped` advises the server that maintaining contents of<br>
		 * obscured regions when the window is mapped would be beneficial. A backing-store<br>
		 * of `Always` advises the server that maintaining contents even when the window<br>
		 * is unmapped would be beneficial. In this case, the server may generate an<br>
		 * exposure event when the window is created. A value of `NotUseful` advises the<br>
		 * server that maintaining contents is unnecessary, although a server may still<br>
		 * choose to maintain contents while the window is mapped. Note that if the server<br>
		 * maintains contents, then the server should maintain complete contents not just<br>
		 * the region within the parent boundaries, even if the window is larger than its<br>
		 * parent. While the server maintains contents, exposure events will not normally<br>
		 * be generated, but the server may stop maintaining contents at any time.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1407</i>
		 */
		public static final int XCB_CW_BACKING_PLANES = 128;
		/**
		 * < The backing-planes indicates (with bits set to 1) which bit planes of the<br>
		 * window hold dynamic data that must be preserved in backing-stores and during<br>
		 * save-unders.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1412</i>
		 */
		public static final int XCB_CW_BACKING_PIXEL = 256;
		/**
		 * < The backing-pixel specifies what value to use in planes not covered by<br>
		 * backing-planes. The server is free to save only the specified bit planes in the<br>
		 * backing-store or save-under and regenerate the remaining planes with the<br>
		 * specified pixel value. Any bits beyond the specified depth of the window in<br>
		 * these values are simply ignored.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1419</i>
		 */
		public static final int XCB_CW_OVERRIDE_REDIRECT = 512;
		/**
		 * < The override-redirect specifies whether map and configure requests on this<br>
		 * window should override a SubstructureRedirect on the parent, typically to<br>
		 * inform a window manager not to tamper with the window.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1424</i>
		 */
		public static final int XCB_CW_SAVE_UNDER = 1024;
		/**
		 * < If 1, the server is advised that when this window is mapped, saving the<br>
		 * contents of windows it obscures would be beneficial.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1428</i>
		 */
		public static final int XCB_CW_EVENT_MASK = 2048;
		/**
		 * < The event-mask defines which events the client is interested in for this window<br>
		 * (or for some event types, inferiors of the window).<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1432</i>
		 */
		public static final int XCB_CW_DONT_PROPAGATE = 4096;
		/**
		 * < The do-not-propagate-mask defines which events should not be propagated to<br>
		 * ancestor windows when no client has the event type selected in this window.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1436</i>
		 */
		public static final int XCB_CW_COLORMAP = 8192;
		/**
		 * < The colormap specifies the colormap that best reflects the true colors of the window. Servers<br>
		 * capable of supporting multiple hardware colormaps may use this information, and window man-<br>
		 * agers may use it for InstallColormap requests. The colormap must have the same visual type<br>
		 * and root as the window (or a Match error results). If CopyFromParent is specified, the parent's<br>
		 * colormap is copied (subsequent changes to the parent's colormap attribute do not affect the child).<br>
		 * However, the window must have the same visual type as the parent (or a Match error results),<br>
		 * and the parent must not have a colormap of None (or a Match error results). For an explanation<br>
		 * of None, see FreeColormap request. The colormap is copied by sharing the colormap object<br>
		 * between the child and the parent, not by making a complete copy of the colormap contents.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1447</i>
		 */
		public static final int XCB_CW_CURSOR = 16384;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_back_pixmap_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:1455</i> */
		public static final int XCB_BACK_PIXMAP_NONE = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1456</i> */
		public static final int XCB_BACK_PIXMAP_PARENT_RELATIVE = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_gravity_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:1460</i> */
		public static final int XCB_GRAVITY_BIT_FORGET = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1461</i> */
		public static final int XCB_GRAVITY_WIN_UNMAP = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1462</i> */
		public static final int XCB_GRAVITY_NORTH_WEST = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1463</i> */
		public static final int XCB_GRAVITY_NORTH = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1464</i> */
		public static final int XCB_GRAVITY_NORTH_EAST = 3;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1465</i> */
		public static final int XCB_GRAVITY_WEST = 4;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1466</i> */
		public static final int XCB_GRAVITY_CENTER = 5;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1467</i> */
		public static final int XCB_GRAVITY_EAST = 6;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1468</i> */
		public static final int XCB_GRAVITY_SOUTH_WEST = 7;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1469</i> */
		public static final int XCB_GRAVITY_SOUTH = 8;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1470</i> */
		public static final int XCB_GRAVITY_SOUTH_EAST = 9;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1471</i> */
		public static final int XCB_GRAVITY_STATIC = 10;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_map_state_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:1553</i> */
		public static final int XCB_MAP_STATE_UNMAPPED = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1554</i> */
		public static final int XCB_MAP_STATE_UNVIEWABLE = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1555</i> */
		public static final int XCB_MAP_STATE_VIEWABLE = 2;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_set_mode_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:1630</i> */
		public static final int XCB_SET_MODE_INSERT = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1631</i> */
		public static final int XCB_SET_MODE_DELETE = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_config_window_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:1716</i> */
		public static final int XCB_CONFIG_WINDOW_X = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1717</i> */
		public static final int XCB_CONFIG_WINDOW_Y = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1718</i> */
		public static final int XCB_CONFIG_WINDOW_WIDTH = 4;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1719</i> */
		public static final int XCB_CONFIG_WINDOW_HEIGHT = 8;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1720</i> */
		public static final int XCB_CONFIG_WINDOW_BORDER_WIDTH = 16;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1721</i> */
		public static final int XCB_CONFIG_WINDOW_SIBLING = 32;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1722</i> */
		public static final int XCB_CONFIG_WINDOW_STACK_MODE = 64;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_stack_mode_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:1726</i> */
		public static final int XCB_STACK_MODE_ABOVE = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1727</i> */
		public static final int XCB_STACK_MODE_BELOW = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1728</i> */
		public static final int XCB_STACK_MODE_TOP_IF = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1729</i> */
		public static final int XCB_STACK_MODE_BOTTOM_IF = 3;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1730</i> */
		public static final int XCB_STACK_MODE_OPPOSITE = 4;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_circulate_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:1762</i> */
		public static final int XCB_CIRCULATE_RAISE_LOWEST = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:1763</i> */
		public static final int XCB_CIRCULATE_LOWER_HIGHEST = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_prop_mode_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:1915</i> */
		public static final int XCB_PROP_MODE_REPLACE = 0;
		/**
		 * < Discard the previous property value and store the new data.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1918</i>
		 */
		public static final int XCB_PROP_MODE_PREPEND = 1;
		/**
		 * < Insert the new data before the beginning of existing data. The `format` must<br>
		 * match existing property value. If the property is undefined, it is treated as<br>
		 * defined with the correct type and format with zero-length data.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:1923</i>
		 */
		public static final int XCB_PROP_MODE_APPEND = 2;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_get_property_type_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:1963</i> */
		public static final int XCB_GET_PROPERTY_TYPE_ANY = 0;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_send_event_dest_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:2100</i> */
		public static final int XCB_SEND_EVENT_DEST_POINTER_WINDOW = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:2101</i> */
		public static final int XCB_SEND_EVENT_DEST_ITEM_FOCUS = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_grab_mode_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:2120</i> */
		public static final int XCB_GRAB_MODE_SYNC = 0;
		/**
		 * < The state of the keyboard appears to freeze: No further keyboard events are<br>
		 * generated by the server until the grabbing client issues a releasing<br>
		 * `AllowEvents` request or until the keyboard grab is released.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:2125</i>
		 */
		public static final int XCB_GRAB_MODE_ASYNC = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_grab_status_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:2131</i> */
		public static final int XCB_GRAB_STATUS_SUCCESS = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:2132</i> */
		public static final int XCB_GRAB_STATUS_ALREADY_GRABBED = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:2133</i> */
		public static final int XCB_GRAB_STATUS_INVALID_TIME = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:2134</i> */
		public static final int XCB_GRAB_STATUS_NOT_VIEWABLE = 3;
		/** <i>native declaration : /usr/include/xcb/xproto.h:2135</i> */
		public static final int XCB_GRAB_STATUS_FROZEN = 4;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_cursor_enum_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:2139</i> */
		public static final int XCB_CURSOR_NONE = 0;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_button_index_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:2192</i> */
		public static final int XCB_BUTTON_INDEX_ANY = 0;
		/**
		 * < Any of the following (or none):<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:2195</i>
		 */
		public static final int XCB_BUTTON_INDEX_1 = 1;
		/**
		 * < The left mouse button.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:2198</i>
		 */
		public static final int XCB_BUTTON_INDEX_2 = 2;
		/**
		 * < The right mouse button.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:2201</i>
		 */
		public static final int XCB_BUTTON_INDEX_3 = 3;
		/**
		 * < The middle mouse button.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:2204</i>
		 */
		public static final int XCB_BUTTON_INDEX_4 = 4;
		/**
		 * < Scroll wheel. TODO: direction?<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:2207</i>
		 */
		public static final int XCB_BUTTON_INDEX_5 = 5;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_grab_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:2312</i> */
		public static final int XCB_GRAB_ANY = 0;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_allow_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:2349</i> */
		public static final int XCB_ALLOW_ASYNC_POINTER = 0;
		/**
		 * < For AsyncPointer, if the pointer is frozen by the client, pointer event<br>
		 * processing continues normally. If the pointer is frozen twice by the client on<br>
		 * behalf of two separate grabs, AsyncPointer thaws for both. AsyncPointer has no<br>
		 * effect if the pointer is not frozen by the client, but the pointer need not be<br>
		 * grabbed by the client.<br>
		 * TODO: rewrite this in more understandable terms.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:2358</i>
		 */
		public static final int XCB_ALLOW_SYNC_POINTER = 1;
		/**
		 * < For SyncPointer, if the pointer is frozen and actively grabbed by the client,<br>
		 * pointer event processing continues normally until the next ButtonPress or<br>
		 * ButtonRelease event is reported to the client, at which time the pointer again<br>
		 * appears to freeze. However, if the reported event causes the pointer grab to be<br>
		 * released, then the pointer does not freeze. SyncPointer has no effect if the<br>
		 * pointer is not frozen by the client or if the pointer is not grabbed by the<br>
		 * client.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:2367</i>
		 */
		public static final int XCB_ALLOW_REPLAY_POINTER = 2;
		/**
		 * < For ReplayPointer, if the pointer is actively grabbed by the client and is<br>
		 * frozen as the result of an event having been sent to the client (either from<br>
		 * the activation of a GrabButton or from a previous AllowEvents with mode<br>
		 * SyncPointer but not from a GrabPointer), then the pointer grab is released and<br>
		 * that event is completely reprocessed, this time ignoring any passive grabs at<br>
		 * or above (towards the root) the grab-window of the grab just released. The<br>
		 * request has no effect if the pointer is not grabbed by the client or if the<br>
		 * pointer is not frozen as the result of an event.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:2377</i>
		 */
		public static final int XCB_ALLOW_ASYNC_KEYBOARD = 3;
		/**
		 * < For AsyncKeyboard, if the keyboard is frozen by the client, keyboard event<br>
		 * processing continues normally. If the keyboard is frozen twice by the client on<br>
		 * behalf of two separate grabs, AsyncKeyboard thaws for both. AsyncKeyboard has<br>
		 * no effect if the keyboard is not frozen by the client, but the keyboard need<br>
		 * not be grabbed by the client.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:2384</i>
		 */
		public static final int XCB_ALLOW_SYNC_KEYBOARD = 4;
		/**
		 * < For SyncKeyboard, if the keyboard is frozen and actively grabbed by the client,<br>
		 * keyboard event processing continues normally until the next KeyPress or<br>
		 * KeyRelease event is reported to the client, at which time the keyboard again<br>
		 * appears to freeze. However, if the reported event causes the keyboard grab to<br>
		 * be released, then the keyboard does not freeze. SyncKeyboard has no effect if<br>
		 * the keyboard is not frozen by the client or if the keyboard is not grabbed by<br>
		 * the client.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:2393</i>
		 */
		public static final int XCB_ALLOW_REPLAY_KEYBOARD = 5;
		/**
		 * < For ReplayKeyboard, if the keyboard is actively grabbed by the client and is<br>
		 * frozen as the result of an event having been sent to the client (either from<br>
		 * the activation of a GrabKey or from a previous AllowEvents with mode<br>
		 * SyncKeyboard but not from a GrabKeyboard), then the keyboard grab is released<br>
		 * and that event is completely reprocessed, this time ignoring any passive grabs<br>
		 * at or above (towards the root) the grab-window of the grab just released. The<br>
		 * request has no effect if the keyboard is not grabbed by the client or if the<br>
		 * keyboard is not frozen as the result of an event.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:2403</i>
		 */
		public static final int XCB_ALLOW_ASYNC_BOTH = 6;
		/**
		 * < For AsyncBoth, if the pointer and the keyboard are frozen by the client, event<br>
		 * processing for both devices continues normally. If a device is frozen twice by<br>
		 * the client on behalf of two separate grabs, AsyncBoth thaws for both. AsyncBoth<br>
		 * has no effect unless both pointer and keyboard are frozen by the client.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:2409</i>
		 */
		public static final int XCB_ALLOW_SYNC_BOTH = 7;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_input_focus_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:2608</i> */
		public static final int XCB_INPUT_FOCUS_NONE = 0;
		/**
		 * < The focus reverts to `XCB_NONE`, so no window will have the input focus.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:2611</i>
		 */
		public static final int XCB_INPUT_FOCUS_POINTER_ROOT = 1;
		/**
		 * < The focus reverts to `XCB_POINTER_ROOT` respectively. When the focus reverts,<br>
		 * FocusIn and FocusOut events are generated, but the last-focus-change time is<br>
		 * not changed.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:2616</i>
		 */
		public static final int XCB_INPUT_FOCUS_PARENT = 2;
		/**
		 * < The focus reverts to the parent (or closest viewable ancestor) and the new<br>
		 * revert_to value is `XCB_INPUT_FOCUS_NONE`.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:2620</i>
		 */
		public static final int XCB_INPUT_FOCUS_FOLLOW_KEYBOARD = 3;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_font_draw_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:2728</i> */
		public static final int XCB_FONT_DRAW_LEFT_TO_RIGHT = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:2729</i> */
		public static final int XCB_FONT_DRAW_RIGHT_TO_LEFT = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_gc_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:3022</i> */
		public static final int XCB_GC_FUNCTION = 1;
		/**
		 * < TODO: Refer to GX<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3025</i>
		 */
		public static final int XCB_GC_PLANE_MASK = 2;
		/**
		 * < In graphics operations, given a source and destination pixel, the result is<br>
		 * computed bitwise on corresponding bits of the pixels; that is, a Boolean<br>
		 * operation is performed in each bit plane. The plane-mask restricts the<br>
		 * operation to a subset of planes, so the result is:<br>
		 * ((src FUNC dst) AND plane-mask) OR (dst AND (NOT plane-mask))<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3033</i>
		 */
		public static final int XCB_GC_FOREGROUND = 4;
		/**
		 * < Foreground colorpixel.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3036</i>
		 */
		public static final int XCB_GC_BACKGROUND = 8;
		/**
		 * < Background colorpixel.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3039</i>
		 */
		public static final int XCB_GC_LINE_WIDTH = 16;
		/**
		 * < The line-width is measured in pixels and can be greater than or equal to one, a wide line, or the<br>
		 * special value zero, a thin line.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3043</i>
		 */
		public static final int XCB_GC_LINE_STYLE = 32;
		/**
		 * < The line-style defines which sections of a line are drawn:<br>
		 * Solid                The full path of the line is drawn.<br>
		 * DoubleDash           The full path of the line is drawn, but the even dashes are filled differently<br>
		 * than the odd dashes (see fill-style), with Butt cap-style used where even and<br>
		 * odd dashes meet.<br>
		 * OnOffDash            Only the even dashes are drawn, and cap-style applies to all internal ends of<br>
		 * the individual dashes (except NotLast is treated as Butt).<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3052</i>
		 */
		public static final int XCB_GC_CAP_STYLE = 64;
		/**
		 * < The cap-style defines how the endpoints of a path are drawn:<br>
		 * NotLast    The result is equivalent to Butt, except that for a line-width of zero the final<br>
		 * endpoint is not drawn.<br>
		 * Butt       The result is square at the endpoint (perpendicular to the slope of the line)<br>
		 * with no projection beyond.<br>
		 * Round      The result is a circular arc with its diameter equal to the line-width, centered<br>
		 * on the endpoint; it is equivalent to Butt for line-width zero.<br>
		 * Projecting The result is square at the end, but the path continues beyond the endpoint for<br>
		 * a distance equal to half the line-width; it is equivalent to Butt for line-width<br>
		 * zero.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3064</i>
		 */
		public static final int XCB_GC_JOIN_STYLE = 128;
		/**
		 * < The join-style defines how corners are drawn for wide lines:<br>
		 * Miter               The outer edges of the two lines extend to meet at an angle. However, if the<br>
		 * angle is less than 11 degrees, a Bevel join-style is used instead.<br>
		 * Round               The result is a circular arc with a diameter equal to the line-width, centered<br>
		 * on the joinpoint.<br>
		 * Bevel               The result is Butt endpoint styles, and then the triangular notch is filled.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3072</i>
		 */
		public static final int XCB_GC_FILL_STYLE = 256;
		/**
		 * < The fill-style defines the contents of the source for line, text, and fill requests. For all text and fill<br>
		 * requests (for example, PolyText8, PolyText16, PolyFillRectangle, FillPoly, and PolyFillArc)<br>
		 * as well as for line requests with line-style Solid, (for example, PolyLine, PolySegment,<br>
		 * PolyRectangle, PolyArc) and for the even dashes for line requests with line-style OnOffDash<br>
		 * or DoubleDash:<br>
		 * Solid                     Foreground<br>
		 * Tiled                     Tile<br>
		 * OpaqueStippled            A tile with the same width and height as stipple but with background<br>
		 * everywhere stipple has a zero and with foreground everywhere stipple<br>
		 * has a one<br>
		 * Stippled                  Foreground masked by stipple<br>
		 * For the odd dashes for line requests with line-style DoubleDash:<br>
		 * Solid                     Background<br>
		 * Tiled                     Same as for even dashes<br>
		 * OpaqueStippled            Same as for even dashes<br>
		 * Stippled                  Background masked by stipple<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3090</i>
		 */
		public static final int XCB_GC_FILL_RULE = 512;
		/**
		 * <<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3093</i>
		 */
		public static final int XCB_GC_TILE = 1024;
		/**
		 * < The tile/stipple represents an infinite two-dimensional plane with the tile/stipple replicated in all<br>
		 * dimensions. When that plane is superimposed on the drawable for use in a graphics operation,<br>
		 * the upper-left corner of some instance of the tile/stipple is at the coordinates within the drawable<br>
		 * specified by the tile/stipple origin. The tile/stipple and clip origins are interpreted relative to the<br>
		 * origin of whatever destination drawable is specified in a graphics request.<br>
		 * The tile pixmap must have the same root and depth as the gcontext (or a Match error results).<br>
		 * The stipple pixmap must have depth one and must have the same root as the gcontext (or a<br>
		 * Match error results). For fill-style Stippled (but not fill-style<br>
		 * OpaqueStippled), the stipple pattern is tiled in a single plane and acts as an<br>
		 * additional clip mask to be ANDed with the clip-mask.<br>
		 * Any size pixmap can be used for tiling or stippling, although some sizes may be faster to use than<br>
		 * others.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3107</i>
		 */
		public static final int XCB_GC_STIPPLE = 2048;
		/**
		 * < The tile/stipple represents an infinite two-dimensional plane with the tile/stipple replicated in all<br>
		 * dimensions. When that plane is superimposed on the drawable for use in a graphics operation,<br>
		 * the upper-left corner of some instance of the tile/stipple is at the coordinates within the drawable<br>
		 * specified by the tile/stipple origin. The tile/stipple and clip origins are interpreted relative to the<br>
		 * origin of whatever destination drawable is specified in a graphics request.<br>
		 * The tile pixmap must have the same root and depth as the gcontext (or a Match error results).<br>
		 * The stipple pixmap must have depth one and must have the same root as the gcontext (or a<br>
		 * Match error results). For fill-style Stippled (but not fill-style<br>
		 * OpaqueStippled), the stipple pattern is tiled in a single plane and acts as an<br>
		 * additional clip mask to be ANDed with the clip-mask.<br>
		 * Any size pixmap can be used for tiling or stippling, although some sizes may be faster to use than<br>
		 * others.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3121</i>
		 */
		public static final int XCB_GC_TILE_STIPPLE_ORIGIN_X = 4096;
		/**
		 * < TODO<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3124</i>
		 */
		public static final int XCB_GC_TILE_STIPPLE_ORIGIN_Y = 8192;
		/**
		 * < TODO<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3127</i>
		 */
		public static final int XCB_GC_FONT = 16384;
		/**
		 * < Which font to use for the `ImageText8` and `ImageText16` requests.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3130</i>
		 */
		public static final int XCB_GC_SUBWINDOW_MODE = 32768;
		/**
		 * < For ClipByChildren, both source and destination windows are additionally<br>
		 * clipped by all viewable InputOutput children. For IncludeInferiors, neither<br>
		 * source nor destination window is<br>
		 * clipped by inferiors. This will result in including subwindow contents in the source and drawing<br>
		 * through subwindow boundaries of the destination. The use of IncludeInferiors with a source or<br>
		 * destination window of one depth with mapped inferiors of differing depth is not illegal, but the<br>
		 * semantics is undefined by the core protocol.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3139</i>
		 */
		public static final int XCB_GC_GRAPHICS_EXPOSURES = 65536;
		/**
		 * < Whether ExposureEvents should be generated (1) or not (0).<br>
		 * The default is 1.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3144</i>
		 */
		public static final int XCB_GC_CLIP_ORIGIN_X = 131072;
		/**
		 * < TODO<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3147</i>
		 */
		public static final int XCB_GC_CLIP_ORIGIN_Y = 262144;
		/**
		 * < TODO<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3150</i>
		 */
		public static final int XCB_GC_CLIP_MASK = 524288;
		/**
		 * < The clip-mask restricts writes to the destination drawable. Only pixels where the clip-mask has<br>
		 * bits set to 1 are drawn. Pixels are not drawn outside the area covered by the clip-mask or where<br>
		 * the clip-mask has bits set to 0. The clip-mask affects all graphics requests, but it does not clip<br>
		 * sources. The clip-mask origin is interpreted relative to the origin of whatever destination drawable is specified in a graphics request. If a pixmap is specified as the clip-mask, it must have<br>
		 * depth 1 and have the same root as the gcontext (or a Match error results). If clip-mask is None,<br>
		 * then pixels are always drawn, regardless of the clip origin. The clip-mask can also be set with the<br>
		 * SetClipRectangles request.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3159</i>
		 */
		public static final int XCB_GC_DASH_OFFSET = 1048576;
		/**
		 * < TODO<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3162</i>
		 */
		public static final int XCB_GC_DASH_LIST = 2097152;
		/**
		 * < TODO<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3165</i>
		 */
		public static final int XCB_GC_ARC_MODE = 4194304;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_gx_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:3171</i> */
		public static final int XCB_GX_CLEAR = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3172</i> */
		public static final int XCB_GX_AND = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3173</i> */
		public static final int XCB_GX_AND_REVERSE = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3174</i> */
		public static final int XCB_GX_COPY = 3;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3175</i> */
		public static final int XCB_GX_AND_INVERTED = 4;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3176</i> */
		public static final int XCB_GX_NOOP = 5;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3177</i> */
		public static final int XCB_GX_XOR = 6;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3178</i> */
		public static final int XCB_GX_OR = 7;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3179</i> */
		public static final int XCB_GX_NOR = 8;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3180</i> */
		public static final int XCB_GX_EQUIV = 9;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3181</i> */
		public static final int XCB_GX_INVERT = 10;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3182</i> */
		public static final int XCB_GX_OR_REVERSE = 11;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3183</i> */
		public static final int XCB_GX_COPY_INVERTED = 12;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3184</i> */
		public static final int XCB_GX_OR_INVERTED = 13;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3185</i> */
		public static final int XCB_GX_NAND = 14;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3186</i> */
		public static final int XCB_GX_SET = 15;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_line_style_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:3190</i> */
		public static final int XCB_LINE_STYLE_SOLID = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3191</i> */
		public static final int XCB_LINE_STYLE_ON_OFF_DASH = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3192</i> */
		public static final int XCB_LINE_STYLE_DOUBLE_DASH = 2;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_cap_style_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:3196</i> */
		public static final int XCB_CAP_STYLE_NOT_LAST = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3197</i> */
		public static final int XCB_CAP_STYLE_BUTT = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3198</i> */
		public static final int XCB_CAP_STYLE_ROUND = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3199</i> */
		public static final int XCB_CAP_STYLE_PROJECTING = 3;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_join_style_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:3203</i> */
		public static final int XCB_JOIN_STYLE_MITER = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3204</i> */
		public static final int XCB_JOIN_STYLE_ROUND = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3205</i> */
		public static final int XCB_JOIN_STYLE_BEVEL = 2;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_fill_style_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:3209</i> */
		public static final int XCB_FILL_STYLE_SOLID = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3210</i> */
		public static final int XCB_FILL_STYLE_TILED = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3211</i> */
		public static final int XCB_FILL_STYLE_STIPPLED = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3212</i> */
		public static final int XCB_FILL_STYLE_OPAQUE_STIPPLED = 3;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_fill_rule_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:3216</i> */
		public static final int XCB_FILL_RULE_EVEN_ODD = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3217</i> */
		public static final int XCB_FILL_RULE_WINDING = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_subwindow_mode_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:3221</i> */
		public static final int XCB_SUBWINDOW_MODE_CLIP_BY_CHILDREN = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3222</i> */
		public static final int XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_arc_mode_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:3226</i> */
		public static final int XCB_ARC_MODE_CHORD = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3227</i> */
		public static final int XCB_ARC_MODE_PIE_SLICE = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_clip_ordering_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:3348</i> */
		public static final int XCB_CLIP_ORDERING_UNSORTED = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3349</i> */
		public static final int XCB_CLIP_ORDERING_Y_SORTED = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3350</i> */
		public static final int XCB_CLIP_ORDERING_YX_SORTED = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3351</i> */
		public static final int XCB_CLIP_ORDERING_YX_BANDED = 3;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_coord_mode_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:3443</i> */
		public static final int XCB_COORD_MODE_ORIGIN = 0;
		/**
		 * < Treats all coordinates as relative to the origin.<br>
		 * <i>native declaration : /usr/include/xcb/xproto.h:3446</i>
		 */
		public static final int XCB_COORD_MODE_PREVIOUS = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_poly_shape_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:3541</i> */
		public static final int XCB_POLY_SHAPE_COMPLEX = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3542</i> */
		public static final int XCB_POLY_SHAPE_NONCONVEX = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3543</i> */
		public static final int XCB_POLY_SHAPE_CONVEX = 2;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_image_format_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:3592</i> */
		public static final int XCB_IMAGE_FORMAT_XY_BITMAP = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3593</i> */
		public static final int XCB_IMAGE_FORMAT_XY_PIXMAP = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3594</i> */
		public static final int XCB_IMAGE_FORMAT_Z_PIXMAP = 2;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_colormap_alloc_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:3720</i> */
		public static final int XCB_COLORMAP_ALLOC_NONE = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3721</i> */
		public static final int XCB_COLORMAP_ALLOC_ALL = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_color_flag_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:3992</i> */
		public static final int XCB_COLOR_FLAG_RED = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3993</i> */
		public static final int XCB_COLOR_FLAG_GREEN = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:3994</i> */
		public static final int XCB_COLOR_FLAG_BLUE = 4;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_pixmap_enum_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:4137</i> */
		public static final int XCB_PIXMAP_NONE = 0;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_font_enum_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:4164</i> */
		public static final int XCB_FONT_NONE = 0;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_query_shape_of_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:4223</i> */
		public static final int XCB_QUERY_SHAPE_OF_LARGEST_CURSOR = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4224</i> */
		public static final int XCB_QUERY_SHAPE_OF_FASTEST_TILE = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4225</i> */
		public static final int XCB_QUERY_SHAPE_OF_FASTEST_STIPPLE = 2;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_kb_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:4375</i> */
		public static final int XCB_KB_KEY_CLICK_PERCENT = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4376</i> */
		public static final int XCB_KB_BELL_PERCENT = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4377</i> */
		public static final int XCB_KB_BELL_PITCH = 4;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4378</i> */
		public static final int XCB_KB_BELL_DURATION = 8;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4379</i> */
		public static final int XCB_KB_LED = 16;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4380</i> */
		public static final int XCB_KB_LED_MODE = 32;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4381</i> */
		public static final int XCB_KB_KEY = 64;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4382</i> */
		public static final int XCB_KB_AUTO_REPEAT_MODE = 128;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_led_mode_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:4386</i> */
		public static final int XCB_LED_MODE_OFF = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4387</i> */
		public static final int XCB_LED_MODE_ON = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_auto_repeat_mode_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:4391</i> */
		public static final int XCB_AUTO_REPEAT_MODE_OFF = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4392</i> */
		public static final int XCB_AUTO_REPEAT_MODE_ON = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4393</i> */
		public static final int XCB_AUTO_REPEAT_MODE_DEFAULT = 2;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_blanking_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:4522</i> */
		public static final int XCB_BLANKING_NOT_PREFERRED = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4523</i> */
		public static final int XCB_BLANKING_PREFERRED = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4524</i> */
		public static final int XCB_BLANKING_DEFAULT = 2;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_exposures_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:4528</i> */
		public static final int XCB_EXPOSURES_NOT_ALLOWED = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4529</i> */
		public static final int XCB_EXPOSURES_ALLOWED = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4530</i> */
		public static final int XCB_EXPOSURES_DEFAULT = 2;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_host_mode_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:4584</i> */
		public static final int XCB_HOST_MODE_INSERT = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4585</i> */
		public static final int XCB_HOST_MODE_DELETE = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_family_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:4589</i> */
		public static final int XCB_FAMILY_INTERNET = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4590</i> */
		public static final int XCB_FAMILY_DECNET = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4591</i> */
		public static final int XCB_FAMILY_CHAOS = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4592</i> */
		public static final int XCB_FAMILY_SERVER_INTERPRETED = 5;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4593</i> */
		public static final int XCB_FAMILY_INTERNET_6 = 6;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_access_control_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:4661</i> */
		public static final int XCB_ACCESS_CONTROL_DISABLE = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4662</i> */
		public static final int XCB_ACCESS_CONTROL_ENABLE = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_close_down_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:4678</i> */
		public static final int XCB_CLOSE_DOWN_DESTROY_ALL = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4679</i> */
		public static final int XCB_CLOSE_DOWN_RETAIN_PERMANENT = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4680</i> */
		public static final int XCB_CLOSE_DOWN_RETAIN_TEMPORARY = 2;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_kill_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:4696</i> */
		public static final int XCB_KILL_ALL_TEMPORARY = 0;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_screen_saver_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:4728</i> */
		public static final int XCB_SCREEN_SAVER_RESET = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4729</i> */
		public static final int XCB_SCREEN_SAVER_ACTIVE = 1;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_mapping_status_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:4745</i> */
		public static final int XCB_MAPPING_STATUS_SUCCESS = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4746</i> */
		public static final int XCB_MAPPING_STATUS_BUSY = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4747</i> */
		public static final int XCB_MAPPING_STATUS_FAILURE = 2;
	};
	/**
	 * <i>native declaration : /usr/include/xcb/xproto.h</i><br>
	 * enum values
	 */
	public static interface xcb_map_index_t {
		/** <i>native declaration : /usr/include/xcb/xproto.h:4810</i> */
		public static final int XCB_MAP_INDEX_SHIFT = 0;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4811</i> */
		public static final int XCB_MAP_INDEX_LOCK = 1;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4812</i> */
		public static final int XCB_MAP_INDEX_CONTROL = 2;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4813</i> */
		public static final int XCB_MAP_INDEX_1 = 3;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4814</i> */
		public static final int XCB_MAP_INDEX_2 = 4;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4815</i> */
		public static final int XCB_MAP_INDEX_3 = 5;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4816</i> */
		public static final int XCB_MAP_INDEX_4 = 6;
		/** <i>native declaration : /usr/include/xcb/xproto.h:4817</i> */
		public static final int XCB_MAP_INDEX_5 = 7;
	};
	/** <i>native declaration : /usr/include/xcb/xcb.h</i> */
	public static final int X_PROTOCOL = (int)11;
	/** <i>native declaration : /usr/include/xcb/xcb.h</i> */
	public static final int X_PROTOCOL_REVISION = (int)0;
	/** <i>native declaration : /usr/include/xcb/xcb.h</i> */
	public static final int X_TCP_PORT = (int)6000;
	/** <i>native declaration : /usr/include/xcb/xcb.h</i> */
	public static final int XCB_CONN_ERROR = (int)1;
	/** <i>native declaration : /usr/include/xcb/xcb.h</i> */
	public static final int XCB_CONN_CLOSED_EXT_NOTSUPPORTED = (int)2;
	/** <i>native declaration : /usr/include/xcb/xcb.h</i> */
	public static final int XCB_CONN_CLOSED_MEM_INSUFFICIENT = (int)3;
	/** <i>native declaration : /usr/include/xcb/xcb.h</i> */
	public static final int XCB_CONN_CLOSED_REQ_LEN_EXCEED = (int)4;
	/** <i>native declaration : /usr/include/xcb/xcb.h</i> */
	public static final int XCB_CONN_CLOSED_PARSE_ERR = (int)5;
	/** <i>native declaration : /usr/include/xcb/xcb.h</i> */
	public static final int XCB_CONN_CLOSED_INVALID_SCREEN = (int)6;
	/** <i>native declaration : /usr/include/xcb/xcb.h</i> */
	public static final int XCB_CONN_CLOSED_FDPASSING_FAILED = (int)7;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_KEY_PRESS = (int)2;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_KEY_RELEASE = (int)3;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_BUTTON_PRESS = (int)4;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_BUTTON_RELEASE = (int)5;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_MOTION_NOTIFY = (int)6;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_ENTER_NOTIFY = (int)7;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_LEAVE_NOTIFY = (int)8;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_FOCUS_IN = (int)9;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_FOCUS_OUT = (int)10;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_KEYMAP_NOTIFY = (int)11;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_EXPOSE = (int)12;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GRAPHICS_EXPOSURE = (int)13;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_NO_EXPOSURE = (int)14;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_VISIBILITY_NOTIFY = (int)15;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CREATE_NOTIFY = (int)16;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_DESTROY_NOTIFY = (int)17;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_UNMAP_NOTIFY = (int)18;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_MAP_NOTIFY = (int)19;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_MAP_REQUEST = (int)20;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_REPARENT_NOTIFY = (int)21;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CONFIGURE_NOTIFY = (int)22;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CONFIGURE_REQUEST = (int)23;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GRAVITY_NOTIFY = (int)24;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_RESIZE_REQUEST = (int)25;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CIRCULATE_NOTIFY = (int)26;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CIRCULATE_REQUEST = (int)27;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_PROPERTY_NOTIFY = (int)28;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_SELECTION_CLEAR = (int)29;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_SELECTION_REQUEST = (int)30;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_SELECTION_NOTIFY = (int)31;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_COLORMAP_NOTIFY = (int)32;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CLIENT_MESSAGE = (int)33;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_MAPPING_NOTIFY = (int)34;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GE_GENERIC = (int)35;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_REQUEST = (int)1;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_VALUE = (int)2;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_WINDOW = (int)3;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_PIXMAP = (int)4;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_ATOM = (int)5;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CURSOR = (int)6;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_FONT = (int)7;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_MATCH = (int)8;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_DRAWABLE = (int)9;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_ACCESS = (int)10;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_ALLOC = (int)11;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_COLORMAP = (int)12;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_G_CONTEXT = (int)13;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_ID_CHOICE = (int)14;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_NAME = (int)15;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_LENGTH = (int)16;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_IMPLEMENTATION = (int)17;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CREATE_WINDOW = (int)1;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CHANGE_WINDOW_ATTRIBUTES = (int)2;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GET_WINDOW_ATTRIBUTES = (int)3;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_DESTROY_WINDOW = (int)4;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_DESTROY_SUBWINDOWS = (int)5;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CHANGE_SAVE_SET = (int)6;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_REPARENT_WINDOW = (int)7;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_MAP_WINDOW = (int)8;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_MAP_SUBWINDOWS = (int)9;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_UNMAP_WINDOW = (int)10;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_UNMAP_SUBWINDOWS = (int)11;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CONFIGURE_WINDOW = (int)12;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CIRCULATE_WINDOW = (int)13;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GET_GEOMETRY = (int)14;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_QUERY_TREE = (int)15;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_INTERN_ATOM = (int)16;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GET_ATOM_NAME = (int)17;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CHANGE_PROPERTY = (int)18;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_DELETE_PROPERTY = (int)19;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GET_PROPERTY = (int)20;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_LIST_PROPERTIES = (int)21;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_SET_SELECTION_OWNER = (int)22;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GET_SELECTION_OWNER = (int)23;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CONVERT_SELECTION = (int)24;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_SEND_EVENT = (int)25;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GRAB_POINTER = (int)26;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_UNGRAB_POINTER = (int)27;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GRAB_BUTTON = (int)28;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_UNGRAB_BUTTON = (int)29;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CHANGE_ACTIVE_POINTER_GRAB = (int)30;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GRAB_KEYBOARD = (int)31;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_UNGRAB_KEYBOARD = (int)32;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GRAB_KEY = (int)33;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_UNGRAB_KEY = (int)34;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_ALLOW_EVENTS = (int)35;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GRAB_SERVER = (int)36;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_UNGRAB_SERVER = (int)37;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_QUERY_POINTER = (int)38;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GET_MOTION_EVENTS = (int)39;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_TRANSLATE_COORDINATES = (int)40;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_WARP_POINTER = (int)41;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_SET_INPUT_FOCUS = (int)42;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GET_INPUT_FOCUS = (int)43;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_QUERY_KEYMAP = (int)44;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_OPEN_FONT = (int)45;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CLOSE_FONT = (int)46;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_QUERY_FONT = (int)47;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_QUERY_TEXT_EXTENTS = (int)48;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_LIST_FONTS = (int)49;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_LIST_FONTS_WITH_INFO = (int)50;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_SET_FONT_PATH = (int)51;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GET_FONT_PATH = (int)52;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CREATE_PIXMAP = (int)53;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_FREE_PIXMAP = (int)54;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CREATE_GC = (int)55;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CHANGE_GC = (int)56;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_COPY_GC = (int)57;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_SET_DASHES = (int)58;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_SET_CLIP_RECTANGLES = (int)59;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_FREE_GC = (int)60;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CLEAR_AREA = (int)61;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_COPY_AREA = (int)62;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_COPY_PLANE = (int)63;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_POLY_POINT = (int)64;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_POLY_LINE = (int)65;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_POLY_SEGMENT = (int)66;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_POLY_RECTANGLE = (int)67;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_POLY_ARC = (int)68;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_FILL_POLY = (int)69;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_POLY_FILL_RECTANGLE = (int)70;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_POLY_FILL_ARC = (int)71;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_PUT_IMAGE = (int)72;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GET_IMAGE = (int)73;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_POLY_TEXT_8 = (int)74;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_POLY_TEXT_16 = (int)75;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_IMAGE_TEXT_8 = (int)76;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_IMAGE_TEXT_16 = (int)77;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CREATE_COLORMAP = (int)78;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_FREE_COLORMAP = (int)79;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_COPY_COLORMAP_AND_FREE = (int)80;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_INSTALL_COLORMAP = (int)81;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_UNINSTALL_COLORMAP = (int)82;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_LIST_INSTALLED_COLORMAPS = (int)83;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_ALLOC_COLOR = (int)84;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_ALLOC_NAMED_COLOR = (int)85;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_ALLOC_COLOR_CELLS = (int)86;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_ALLOC_COLOR_PLANES = (int)87;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_FREE_COLORS = (int)88;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_STORE_COLORS = (int)89;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_STORE_NAMED_COLOR = (int)90;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_QUERY_COLORS = (int)91;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_LOOKUP_COLOR = (int)92;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CREATE_CURSOR = (int)93;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CREATE_GLYPH_CURSOR = (int)94;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_FREE_CURSOR = (int)95;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_RECOLOR_CURSOR = (int)96;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_QUERY_BEST_SIZE = (int)97;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_QUERY_EXTENSION = (int)98;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_LIST_EXTENSIONS = (int)99;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CHANGE_KEYBOARD_MAPPING = (int)100;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GET_KEYBOARD_MAPPING = (int)101;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CHANGE_KEYBOARD_CONTROL = (int)102;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GET_KEYBOARD_CONTROL = (int)103;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_BELL = (int)104;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CHANGE_POINTER_CONTROL = (int)105;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GET_POINTER_CONTROL = (int)106;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_SET_SCREEN_SAVER = (int)107;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GET_SCREEN_SAVER = (int)108;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_CHANGE_HOSTS = (int)109;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_LIST_HOSTS = (int)110;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_SET_ACCESS_CONTROL = (int)111;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_SET_CLOSE_DOWN_MODE = (int)112;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_KILL_CLIENT = (int)113;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_ROTATE_PROPERTIES = (int)114;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_FORCE_SCREEN_SAVER = (int)115;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_SET_POINTER_MAPPING = (int)116;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GET_POINTER_MAPPING = (int)117;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_SET_MODIFIER_MAPPING = (int)118;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_GET_MODIFIER_MAPPING = (int)119;
	/** <i>native declaration : /usr/include/xcb/xproto.h</i> */
	public static final int XCB_NO_OPERATION = (int)127;
	/** <i>native declaration : /usr/include/xcb/xcb.h</i> */
	public static final int XCB_NONE = (int)0;
	/** <i>native declaration : /usr/include/xcb/xcb.h</i> */
	public static final int XCB_COPY_FROM_PARENT = (int)0;
	/** <i>native declaration : /usr/include/xcb/xcb.h</i> */
	public static final int XCB_CURRENT_TIME = (int)0;
	/** <i>native declaration : /usr/include/xcb/xcb.h</i> */
	public static final int XCB_NO_SYMBOL = (int)0;
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_char2b_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_char2b_t)<br>
	 * Original signature : <code>void xcb_char2b_next(xcb_char2b_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:4899</i>
	 */
	void xcb_char2b_next(xcb_char2b_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_char2b_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_char2b_end(xcb_char2b_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:4911</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_char2b_end(xcb_char2b_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_window_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_window_t)<br>
	 * Original signature : <code>void xcb_window_next(xcb_window_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:4922</i>
	 */
	void xcb_window_next(xcb_window_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_window_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_window_end(xcb_window_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:4934</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_window_end(xcb_window_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_pixmap_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_pixmap_t)<br>
	 * Original signature : <code>void xcb_pixmap_next(xcb_pixmap_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:4945</i>
	 */
	void xcb_pixmap_next(xcb_pixmap_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_pixmap_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_pixmap_end(xcb_pixmap_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:4957</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_pixmap_end(xcb_pixmap_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_cursor_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_cursor_t)<br>
	 * Original signature : <code>void xcb_cursor_next(xcb_cursor_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:4968</i>
	 */
	void xcb_cursor_next(xcb_cursor_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_cursor_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_cursor_end(xcb_cursor_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:4980</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_cursor_end(xcb_cursor_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_font_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_font_t)<br>
	 * Original signature : <code>void xcb_font_next(xcb_font_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:4991</i>
	 */
	void xcb_font_next(xcb_font_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_font_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_font_end(xcb_font_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5003</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_font_end(xcb_font_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_gcontext_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_gcontext_t)<br>
	 * Original signature : <code>void xcb_gcontext_next(xcb_gcontext_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5014</i>
	 */
	void xcb_gcontext_next(xcb_gcontext_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_gcontext_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_gcontext_end(xcb_gcontext_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5026</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_gcontext_end(xcb_gcontext_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_colormap_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_colormap_t)<br>
	 * Original signature : <code>void xcb_colormap_next(xcb_colormap_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5037</i>
	 */
	void xcb_colormap_next(xcb_colormap_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_colormap_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_colormap_end(xcb_colormap_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5049</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_colormap_end(xcb_colormap_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_atom_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_atom_t)<br>
	 * Original signature : <code>void xcb_atom_next(xcb_atom_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5060</i>
	 */
	void xcb_atom_next(xcb_atom_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_atom_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_atom_end(xcb_atom_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5072</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_atom_end(xcb_atom_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_drawable_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_drawable_t)<br>
	 * Original signature : <code>void xcb_drawable_next(xcb_drawable_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5083</i>
	 */
	void xcb_drawable_next(xcb_drawable_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_drawable_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_drawable_end(xcb_drawable_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5095</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_drawable_end(xcb_drawable_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_fontable_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_fontable_t)<br>
	 * Original signature : <code>void xcb_fontable_next(xcb_fontable_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5106</i>
	 */
	void xcb_fontable_next(xcb_fontable_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_fontable_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_fontable_end(xcb_fontable_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5118</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_fontable_end(xcb_fontable_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_bool32_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_bool32_t)<br>
	 * Original signature : <code>void xcb_bool32_next(xcb_bool32_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5129</i>
	 */
	void xcb_bool32_next(xcb_bool32_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_bool32_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_bool32_end(xcb_bool32_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5141</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_bool32_end(xcb_bool32_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_visualid_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_visualid_t)<br>
	 * Original signature : <code>void xcb_visualid_next(xcb_visualid_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5152</i>
	 */
	void xcb_visualid_next(xcb_visualid_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_visualid_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_visualid_end(xcb_visualid_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5164</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_visualid_end(xcb_visualid_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_timestamp_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_timestamp_t)<br>
	 * Original signature : <code>void xcb_timestamp_next(xcb_timestamp_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5175</i>
	 */
	void xcb_timestamp_next(xcb_timestamp_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_timestamp_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_timestamp_end(xcb_timestamp_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5187</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_timestamp_end(xcb_timestamp_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_keysym_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_keysym_t)<br>
	 * Original signature : <code>void xcb_keysym_next(xcb_keysym_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5198</i>
	 */
	void xcb_keysym_next(xcb_keysym_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_keysym_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_keysym_end(xcb_keysym_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5210</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_keysym_end(xcb_keysym_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_keycode_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_keycode_t)<br>
	 * Original signature : <code>void xcb_keycode_next(xcb_keycode_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5221</i>
	 */
	void xcb_keycode_next(xcb_keycode_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_keycode_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_keycode_end(xcb_keycode_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5233</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_keycode_end(xcb_keycode_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_keycode32_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_keycode32_t)<br>
	 * Original signature : <code>void xcb_keycode32_next(xcb_keycode32_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5244</i>
	 */
	void xcb_keycode32_next(xcb_keycode32_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_keycode32_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_keycode32_end(xcb_keycode32_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5256</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_keycode32_end(xcb_keycode32_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_button_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_button_t)<br>
	 * Original signature : <code>void xcb_button_next(xcb_button_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5267</i>
	 */
	void xcb_button_next(xcb_button_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_button_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_button_end(xcb_button_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5279</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_button_end(xcb_button_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_point_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_point_t)<br>
	 * Original signature : <code>void xcb_point_next(xcb_point_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5290</i>
	 */
	void xcb_point_next(xcb_point_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_point_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_point_end(xcb_point_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5302</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_point_end(xcb_point_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_rectangle_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_rectangle_t)<br>
	 * Original signature : <code>void xcb_rectangle_next(xcb_rectangle_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5313</i>
	 */
	void xcb_rectangle_next(xcb_rectangle_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_rectangle_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_rectangle_end(xcb_rectangle_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5325</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_rectangle_end(xcb_rectangle_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_arc_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_arc_t)<br>
	 * Original signature : <code>void xcb_arc_next(xcb_arc_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5336</i>
	 */
	void xcb_arc_next(xcb_arc_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_arc_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_arc_end(xcb_arc_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5348</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_arc_end(xcb_arc_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_format_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_format_t)<br>
	 * Original signature : <code>void xcb_format_next(xcb_format_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5359</i>
	 */
	void xcb_format_next(xcb_format_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_format_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_format_end(xcb_format_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5371</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_format_end(xcb_format_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_visualtype_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_visualtype_t)<br>
	 * Original signature : <code>void xcb_visualtype_next(xcb_visualtype_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5382</i>
	 */
	void xcb_visualtype_next(xcb_visualtype_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_visualtype_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_visualtype_end(xcb_visualtype_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5394</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_visualtype_end(xcb_visualtype_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_depth_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5397</i>
	 */
	int xcb_depth_sizeof(Pointer _buffer);
	/**
	 * Original signature : <code>xcb_visualtype_t* xcb_depth_visuals(const xcb_depth_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5400</i>
	 */
	xcb_visualtype_t xcb_depth_visuals(xcb_depth_t R);
	/**
	 * Original signature : <code>int xcb_depth_visuals_length(const xcb_depth_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5403</i>
	 */
	int xcb_depth_visuals_length(xcb_depth_t R);
	/**
	 * Original signature : <code>xcb_visualtype_iterator_t xcb_depth_visuals_iterator(const xcb_depth_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5406</i>
	 */
	xcb_visualtype_iterator_t.ByValue xcb_depth_visuals_iterator(xcb_depth_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_depth_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_depth_t)<br>
	 * Original signature : <code>void xcb_depth_next(xcb_depth_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5417</i>
	 */
	void xcb_depth_next(xcb_depth_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_depth_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_depth_end(xcb_depth_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5429</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_depth_end(xcb_depth_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_screen_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5432</i>
	 */
	int xcb_screen_sizeof(Pointer _buffer);
	/**
	 * Original signature : <code>int xcb_screen_allowed_depths_length(const xcb_screen_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5435</i>
	 */
	int xcb_screen_allowed_depths_length(xcb_screen_t R);
	/**
	 * Original signature : <code>xcb_depth_iterator_t xcb_screen_allowed_depths_iterator(const xcb_screen_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5438</i>
	 */
	xcb_depth_iterator_t.ByValue xcb_screen_allowed_depths_iterator(xcb_screen_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_screen_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_screen_t)<br>
	 * Original signature : <code>void xcb_screen_next(xcb_screen_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5449</i>
	 */
	void xcb_screen_next(xcb_screen_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_screen_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_screen_end(xcb_screen_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5461</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_screen_end(xcb_screen_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_setup_request_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5464</i>
	 */
	int xcb_setup_request_sizeof(Pointer _buffer);
	/**
	 * Original signature : <code>char* xcb_setup_request_authorization_protocol_name(const xcb_setup_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5467</i>
	 */
	Pointer xcb_setup_request_authorization_protocol_name(xcb_setup_request_t R);
	/**
	 * Original signature : <code>int xcb_setup_request_authorization_protocol_name_length(const xcb_setup_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5470</i>
	 */
	int xcb_setup_request_authorization_protocol_name_length(xcb_setup_request_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_request_authorization_protocol_name_end(const xcb_setup_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5473</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_setup_request_authorization_protocol_name_end(xcb_setup_request_t R);
	/**
	 * Original signature : <code>char* xcb_setup_request_authorization_protocol_data(const xcb_setup_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5476</i>
	 */
	Pointer xcb_setup_request_authorization_protocol_data(xcb_setup_request_t R);
	/**
	 * Original signature : <code>int xcb_setup_request_authorization_protocol_data_length(const xcb_setup_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5479</i>
	 */
	int xcb_setup_request_authorization_protocol_data_length(xcb_setup_request_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_request_authorization_protocol_data_end(const xcb_setup_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5482</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_setup_request_authorization_protocol_data_end(xcb_setup_request_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_setup_request_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_setup_request_t)<br>
	 * Original signature : <code>void xcb_setup_request_next(xcb_setup_request_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5493</i>
	 */
	void xcb_setup_request_next(xcb_setup_request_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_setup_request_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_request_end(xcb_setup_request_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5505</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_setup_request_end(xcb_setup_request_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_setup_failed_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5508</i>
	 */
	int xcb_setup_failed_sizeof(Pointer _buffer);
	/**
	 * Original signature : <code>char* xcb_setup_failed_reason(const xcb_setup_failed_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5511</i>
	 */
	Pointer xcb_setup_failed_reason(xcb_setup_failed_t R);
	/**
	 * Original signature : <code>int xcb_setup_failed_reason_length(const xcb_setup_failed_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5514</i>
	 */
	int xcb_setup_failed_reason_length(xcb_setup_failed_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_failed_reason_end(const xcb_setup_failed_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5517</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_setup_failed_reason_end(xcb_setup_failed_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_setup_failed_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_setup_failed_t)<br>
	 * Original signature : <code>void xcb_setup_failed_next(xcb_setup_failed_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5528</i>
	 */
	void xcb_setup_failed_next(xcb_setup_failed_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_setup_failed_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_failed_end(xcb_setup_failed_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5540</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_setup_failed_end(xcb_setup_failed_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_setup_authenticate_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5543</i>
	 */
	int xcb_setup_authenticate_sizeof(Pointer _buffer);
	/**
	 * Original signature : <code>char* xcb_setup_authenticate_reason(const xcb_setup_authenticate_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5546</i>
	 */
	Pointer xcb_setup_authenticate_reason(xcb_setup_authenticate_t R);
	/**
	 * Original signature : <code>int xcb_setup_authenticate_reason_length(const xcb_setup_authenticate_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5549</i>
	 */
	int xcb_setup_authenticate_reason_length(xcb_setup_authenticate_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_authenticate_reason_end(const xcb_setup_authenticate_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5552</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_setup_authenticate_reason_end(xcb_setup_authenticate_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_setup_authenticate_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_setup_authenticate_t)<br>
	 * Original signature : <code>void xcb_setup_authenticate_next(xcb_setup_authenticate_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5563</i>
	 */
	void xcb_setup_authenticate_next(xcb_setup_authenticate_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_setup_authenticate_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_authenticate_end(xcb_setup_authenticate_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5575</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_setup_authenticate_end(xcb_setup_authenticate_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_setup_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5578</i>
	 */
	int xcb_setup_sizeof(Pointer _buffer);
	/**
	 * Original signature : <code>char* xcb_setup_vendor(const xcb_setup_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5581</i>
	 */
	Pointer xcb_setup_vendor(xcb_setup_t R);
	/**
	 * Original signature : <code>int xcb_setup_vendor_length(const xcb_setup_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5584</i>
	 */
	int xcb_setup_vendor_length(xcb_setup_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_vendor_end(const xcb_setup_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5587</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_setup_vendor_end(xcb_setup_t R);
	/**
	 * Original signature : <code>xcb_format_t* xcb_setup_pixmap_formats(const xcb_setup_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5590</i>
	 */
	xcb_format_t xcb_setup_pixmap_formats(xcb_setup_t R);
	/**
	 * Original signature : <code>int xcb_setup_pixmap_formats_length(const xcb_setup_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5593</i>
	 */
	int xcb_setup_pixmap_formats_length(xcb_setup_t R);
	/**
	 * Original signature : <code>xcb_format_iterator_t xcb_setup_pixmap_formats_iterator(const xcb_setup_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5596</i>
	 */
	xcb_format_iterator_t.ByValue xcb_setup_pixmap_formats_iterator(xcb_setup_t R);
	/**
	 * Original signature : <code>int xcb_setup_roots_length(const xcb_setup_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5599</i>
	 */
	int xcb_setup_roots_length(xcb_setup_t R);
	/**
	 * Original signature : <code>xcb_screen_iterator_t xcb_setup_roots_iterator(const xcb_setup_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5602</i>
	 */
	xcb_screen_iterator_t.ByValue xcb_setup_roots_iterator(xcb_setup_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_setup_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_setup_t)<br>
	 * Original signature : <code>void xcb_setup_next(xcb_setup_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5613</i>
	 */
	void xcb_setup_next(xcb_setup_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_setup_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_setup_end(xcb_setup_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5625</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_setup_end(xcb_setup_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_client_message_data_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_client_message_data_t)<br>
	 * Original signature : <code>void xcb_client_message_data_next(xcb_client_message_data_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5636</i>
	 */
	void xcb_client_message_data_next(xcb_client_message_data_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_client_message_data_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_client_message_data_end(xcb_client_message_data_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5648</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_client_message_data_end(xcb_client_message_data_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_create_window_value_list_serialize(void**, uint32_t, const xcb_create_window_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5651</i>
	 */
	int xcb_create_window_value_list_serialize(PointerByReference _buffer, int value_mask, xcb_create_window_value_list_t _aux);
	/**
	 * Original signature : <code>int xcb_create_window_value_list_unpack(const void*, uint32_t, xcb_create_window_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5656</i>
	 */
	int xcb_create_window_value_list_unpack(Pointer _buffer, int value_mask, xcb_create_window_value_list_t _aux);
	/**
	 * Original signature : <code>int xcb_create_window_value_list_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5661</i>
	 */
	int xcb_create_window_value_list_sizeof(Pointer _buffer, int value_mask);
	/**
	 * Original signature : <code>int xcb_create_window_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5665</i>
	 */
	int xcb_create_window_sizeof(Pointer _buffer);
	/**
	 * @brief Creates a window<br>
	 * @param c The connection<br>
	 * @param depth Specifies the new window's depth (TODO: what unit?).<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the<br>
	 * \a parent window.<br>
	 * @param wid The ID with which you will refer to the new window, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param parent The parent window of the new window.<br>
	 * @param x The X coordinate of the new window.<br>
	 * @param y The Y coordinate of the new window.<br>
	 * @param width The width of the new window.<br>
	 * @param height The height of the new window.<br>
	 * @param border_width TODO:<br>
	 * \n<br>
	 * Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.<br>
	 * @param _class A bitmask of #xcb_window_class_t values.<br>
	 * @param _class \n<br>
	 * @param visual Specifies the id for the new window's visual.<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the<br>
	 * \a parent window.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @return A cookie<br>
	 * Creates an unmapped window as child of the specified \a parent window. A<br>
	 * CreateNotify event will be generated. The new window is placed on top in the<br>
	 * stacking order with respect to siblings.<br>
	 * <br>
	 * The coordinate system has the X axis horizontal and the Y axis vertical with<br>
	 * the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms<br>
	 * of pixels, and coincide with pixel centers. Each window and pixmap has its own<br>
	 * coordinate system. For a window, the origin is inside the border at the inside,<br>
	 * upper-left corner.<br>
	 * <br>
	 * The created window is not yet displayed (mapped), call `xcb_map_window` to<br>
	 * display it.<br>
	 * <br>
	 * The created window will initially use the same cursor as its parent.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_window_checked(xcb_connection_t*, uint8_t, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, uint16_t, uint16_t, xcb_visualid_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5714</i><br>
	 * @deprecated use the safer method {@link #xcb_create_window_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, short, short, short, short, int, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_window_checked(Pointer c, byte depth, int wid, int parent, short x, short y, short width, short height, short border_width, short _class, int visual, int value_mask, Pointer value_list);
	/**
	 * @brief Creates a window<br>
	 * @param c The connection<br>
	 * @param depth Specifies the new window's depth (TODO: what unit?).<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the<br>
	 * \a parent window.<br>
	 * @param wid The ID with which you will refer to the new window, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param parent The parent window of the new window.<br>
	 * @param x The X coordinate of the new window.<br>
	 * @param y The Y coordinate of the new window.<br>
	 * @param width The width of the new window.<br>
	 * @param height The height of the new window.<br>
	 * @param border_width TODO:<br>
	 * \n<br>
	 * Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.<br>
	 * @param _class A bitmask of #xcb_window_class_t values.<br>
	 * @param _class \n<br>
	 * @param visual Specifies the id for the new window's visual.<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the<br>
	 * \a parent window.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @return A cookie<br>
	 * Creates an unmapped window as child of the specified \a parent window. A<br>
	 * CreateNotify event will be generated. The new window is placed on top in the<br>
	 * stacking order with respect to siblings.<br>
	 * <br>
	 * The coordinate system has the X axis horizontal and the Y axis vertical with<br>
	 * the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms<br>
	 * of pixels, and coincide with pixel centers. Each window and pixmap has its own<br>
	 * coordinate system. For a window, the origin is inside the border at the inside,<br>
	 * upper-left corner.<br>
	 * <br>
	 * The created window is not yet displayed (mapped), call `xcb_map_window` to<br>
	 * display it.<br>
	 * <br>
	 * The created window will initially use the same cursor as its parent.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_window_checked(xcb_connection_t*, uint8_t, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, uint16_t, uint16_t, xcb_visualid_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5714</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_window_checked(PointerByReference c, byte depth, int wid, int parent, short x, short y, short width, short height, short border_width, short _class, int visual, int value_mask, Pointer value_list);
	/**
	 * @brief Creates a window<br>
	 * @param c The connection<br>
	 * @param depth Specifies the new window's depth (TODO: what unit?).<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the<br>
	 * \a parent window.<br>
	 * @param wid The ID with which you will refer to the new window, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param parent The parent window of the new window.<br>
	 * @param x The X coordinate of the new window.<br>
	 * @param y The Y coordinate of the new window.<br>
	 * @param width The width of the new window.<br>
	 * @param height The height of the new window.<br>
	 * @param border_width TODO:<br>
	 * \n<br>
	 * Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.<br>
	 * @param _class A bitmask of #xcb_window_class_t values.<br>
	 * @param _class \n<br>
	 * @param visual Specifies the id for the new window's visual.<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the<br>
	 * \a parent window.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @return A cookie<br>
	 * Creates an unmapped window as child of the specified \a parent window. A<br>
	 * CreateNotify event will be generated. The new window is placed on top in the<br>
	 * stacking order with respect to siblings.<br>
	 * <br>
	 * The coordinate system has the X axis horizontal and the Y axis vertical with<br>
	 * the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms<br>
	 * of pixels, and coincide with pixel centers. Each window and pixmap has its own<br>
	 * coordinate system. For a window, the origin is inside the border at the inside,<br>
	 * upper-left corner.<br>
	 * <br>
	 * The created window is not yet displayed (mapped), call `xcb_map_window` to<br>
	 * display it.<br>
	 * <br>
	 * The created window will initially use the same cursor as its parent.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_window(xcb_connection_t*, uint8_t, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, uint16_t, uint16_t, xcb_visualid_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5772</i><br>
	 * @deprecated use the safer method {@link #xcb_create_window(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, short, short, short, short, int, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_window(Pointer c, byte depth, int wid, int parent, short x, short y, short width, short height, short border_width, short _class, int visual, int value_mask, Pointer value_list);
	/**
	 * @brief Creates a window<br>
	 * @param c The connection<br>
	 * @param depth Specifies the new window's depth (TODO: what unit?).<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the<br>
	 * \a parent window.<br>
	 * @param wid The ID with which you will refer to the new window, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param parent The parent window of the new window.<br>
	 * @param x The X coordinate of the new window.<br>
	 * @param y The Y coordinate of the new window.<br>
	 * @param width The width of the new window.<br>
	 * @param height The height of the new window.<br>
	 * @param border_width TODO:<br>
	 * \n<br>
	 * Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.<br>
	 * @param _class A bitmask of #xcb_window_class_t values.<br>
	 * @param _class \n<br>
	 * @param visual Specifies the id for the new window's visual.<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the<br>
	 * \a parent window.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @return A cookie<br>
	 * Creates an unmapped window as child of the specified \a parent window. A<br>
	 * CreateNotify event will be generated. The new window is placed on top in the<br>
	 * stacking order with respect to siblings.<br>
	 * <br>
	 * The coordinate system has the X axis horizontal and the Y axis vertical with<br>
	 * the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms<br>
	 * of pixels, and coincide with pixel centers. Each window and pixmap has its own<br>
	 * coordinate system. For a window, the origin is inside the border at the inside,<br>
	 * upper-left corner.<br>
	 * <br>
	 * The created window is not yet displayed (mapped), call `xcb_map_window` to<br>
	 * display it.<br>
	 * <br>
	 * The created window will initially use the same cursor as its parent.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_window(xcb_connection_t*, uint8_t, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, uint16_t, uint16_t, xcb_visualid_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5772</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_window(PointerByReference c, byte depth, int wid, int parent, short x, short y, short width, short height, short border_width, short _class, int visual, int value_mask, Pointer value_list);
	/**
	 * @brief Creates a window<br>
	 * @param c The connection<br>
	 * @param depth Specifies the new window's depth (TODO: what unit?).<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the<br>
	 * \a parent window.<br>
	 * @param wid The ID with which you will refer to the new window, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param parent The parent window of the new window.<br>
	 * @param x The X coordinate of the new window.<br>
	 * @param y The Y coordinate of the new window.<br>
	 * @param width The width of the new window.<br>
	 * @param height The height of the new window.<br>
	 * @param border_width TODO:<br>
	 * \n<br>
	 * Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.<br>
	 * @param _class A bitmask of #xcb_window_class_t values.<br>
	 * @param _class \n<br>
	 * @param visual Specifies the id for the new window's visual.<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the<br>
	 * \a parent window.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @return A cookie<br>
	 * Creates an unmapped window as child of the specified \a parent window. A<br>
	 * CreateNotify event will be generated. The new window is placed on top in the<br>
	 * stacking order with respect to siblings.<br>
	 * <br>
	 * The coordinate system has the X axis horizontal and the Y axis vertical with<br>
	 * the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms<br>
	 * of pixels, and coincide with pixel centers. Each window and pixmap has its own<br>
	 * coordinate system. For a window, the origin is inside the border at the inside,<br>
	 * upper-left corner.<br>
	 * <br>
	 * The created window is not yet displayed (mapped), call `xcb_map_window` to<br>
	 * display it.<br>
	 * <br>
	 * The created window will initially use the same cursor as its parent.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_window_aux_checked(xcb_connection_t*, uint8_t, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, uint16_t, uint16_t, xcb_visualid_t, uint32_t, const xcb_create_window_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5833</i><br>
	 * @deprecated use the safer method {@link #xcb_create_window_aux_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, short, short, short, short, int, int, com.yi.ylwm.xcb.xcb_create_window_value_list_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_window_aux_checked(Pointer c, byte depth, int wid, int parent, short x, short y, short width, short height, short border_width, short _class, int visual, int value_mask, xcb_create_window_value_list_t value_list);
	/**
	 * @brief Creates a window<br>
	 * @param c The connection<br>
	 * @param depth Specifies the new window's depth (TODO: what unit?).<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the<br>
	 * \a parent window.<br>
	 * @param wid The ID with which you will refer to the new window, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param parent The parent window of the new window.<br>
	 * @param x The X coordinate of the new window.<br>
	 * @param y The Y coordinate of the new window.<br>
	 * @param width The width of the new window.<br>
	 * @param height The height of the new window.<br>
	 * @param border_width TODO:<br>
	 * \n<br>
	 * Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.<br>
	 * @param _class A bitmask of #xcb_window_class_t values.<br>
	 * @param _class \n<br>
	 * @param visual Specifies the id for the new window's visual.<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the<br>
	 * \a parent window.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @return A cookie<br>
	 * Creates an unmapped window as child of the specified \a parent window. A<br>
	 * CreateNotify event will be generated. The new window is placed on top in the<br>
	 * stacking order with respect to siblings.<br>
	 * <br>
	 * The coordinate system has the X axis horizontal and the Y axis vertical with<br>
	 * the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms<br>
	 * of pixels, and coincide with pixel centers. Each window and pixmap has its own<br>
	 * coordinate system. For a window, the origin is inside the border at the inside,<br>
	 * upper-left corner.<br>
	 * <br>
	 * The created window is not yet displayed (mapped), call `xcb_map_window` to<br>
	 * display it.<br>
	 * <br>
	 * The created window will initially use the same cursor as its parent.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_window_aux_checked(xcb_connection_t*, uint8_t, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, uint16_t, uint16_t, xcb_visualid_t, uint32_t, const xcb_create_window_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5833</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_window_aux_checked(PointerByReference c, byte depth, int wid, int parent, short x, short y, short width, short height, short border_width, short _class, int visual, int value_mask, xcb_create_window_value_list_t value_list);
	/**
	 * @brief Creates a window<br>
	 * @param c The connection<br>
	 * @param depth Specifies the new window's depth (TODO: what unit?).<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the<br>
	 * \a parent window.<br>
	 * @param wid The ID with which you will refer to the new window, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param parent The parent window of the new window.<br>
	 * @param x The X coordinate of the new window.<br>
	 * @param y The Y coordinate of the new window.<br>
	 * @param width The width of the new window.<br>
	 * @param height The height of the new window.<br>
	 * @param border_width TODO:<br>
	 * \n<br>
	 * Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.<br>
	 * @param _class A bitmask of #xcb_window_class_t values.<br>
	 * @param _class \n<br>
	 * @param visual Specifies the id for the new window's visual.<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the<br>
	 * \a parent window.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @return A cookie<br>
	 * Creates an unmapped window as child of the specified \a parent window. A<br>
	 * CreateNotify event will be generated. The new window is placed on top in the<br>
	 * stacking order with respect to siblings.<br>
	 * <br>
	 * The coordinate system has the X axis horizontal and the Y axis vertical with<br>
	 * the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms<br>
	 * of pixels, and coincide with pixel centers. Each window and pixmap has its own<br>
	 * coordinate system. For a window, the origin is inside the border at the inside,<br>
	 * upper-left corner.<br>
	 * <br>
	 * The created window is not yet displayed (mapped), call `xcb_map_window` to<br>
	 * display it.<br>
	 * <br>
	 * The created window will initially use the same cursor as its parent.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_window_aux(xcb_connection_t*, uint8_t, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, uint16_t, uint16_t, xcb_visualid_t, uint32_t, const xcb_create_window_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5891</i><br>
	 * @deprecated use the safer method {@link #xcb_create_window_aux(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, short, short, short, short, int, int, com.yi.ylwm.xcb.xcb_create_window_value_list_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_window_aux(Pointer c, byte depth, int wid, int parent, short x, short y, short width, short height, short border_width, short _class, int visual, int value_mask, xcb_create_window_value_list_t value_list);
	/**
	 * @brief Creates a window<br>
	 * @param c The connection<br>
	 * @param depth Specifies the new window's depth (TODO: what unit?).<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the<br>
	 * \a parent window.<br>
	 * @param wid The ID with which you will refer to the new window, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param parent The parent window of the new window.<br>
	 * @param x The X coordinate of the new window.<br>
	 * @param y The Y coordinate of the new window.<br>
	 * @param width The width of the new window.<br>
	 * @param height The height of the new window.<br>
	 * @param border_width TODO:<br>
	 * \n<br>
	 * Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.<br>
	 * @param _class A bitmask of #xcb_window_class_t values.<br>
	 * @param _class \n<br>
	 * @param visual Specifies the id for the new window's visual.<br>
	 * \n<br>
	 * The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the<br>
	 * \a parent window.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @return A cookie<br>
	 * Creates an unmapped window as child of the specified \a parent window. A<br>
	 * CreateNotify event will be generated. The new window is placed on top in the<br>
	 * stacking order with respect to siblings.<br>
	 * <br>
	 * The coordinate system has the X axis horizontal and the Y axis vertical with<br>
	 * the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms<br>
	 * of pixels, and coincide with pixel centers. Each window and pixmap has its own<br>
	 * coordinate system. For a window, the origin is inside the border at the inside,<br>
	 * upper-left corner.<br>
	 * <br>
	 * The created window is not yet displayed (mapped), call `xcb_map_window` to<br>
	 * display it.<br>
	 * <br>
	 * The created window will initially use the same cursor as its parent.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_window_aux(xcb_connection_t*, uint8_t, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, uint16_t, uint16_t, xcb_visualid_t, uint32_t, const xcb_create_window_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5891</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_window_aux(PointerByReference c, byte depth, int wid, int parent, short x, short y, short width, short height, short border_width, short _class, int visual, int value_mask, xcb_create_window_value_list_t value_list);
	/**
	 * Original signature : <code>void* xcb_create_window_value_list(const xcb_create_window_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5906</i>
	 */
	Pointer xcb_create_window_value_list(xcb_create_window_request_t R);
	/**
	 * Original signature : <code>int xcb_change_window_attributes_value_list_serialize(void**, uint32_t, const xcb_change_window_attributes_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5909</i>
	 */
	int xcb_change_window_attributes_value_list_serialize(PointerByReference _buffer, int value_mask, xcb_change_window_attributes_value_list_t _aux);
	/**
	 * Original signature : <code>int xcb_change_window_attributes_value_list_unpack(const void*, uint32_t, xcb_change_window_attributes_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5914</i>
	 */
	int xcb_change_window_attributes_value_list_unpack(Pointer _buffer, int value_mask, xcb_change_window_attributes_value_list_t _aux);
	/**
	 * Original signature : <code>int xcb_change_window_attributes_value_list_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5919</i>
	 */
	int xcb_change_window_attributes_value_list_sizeof(Pointer _buffer, int value_mask);
	/**
	 * Original signature : <code>int xcb_change_window_attributes_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5923</i>
	 */
	int xcb_change_window_attributes_sizeof(Pointer _buffer);
	/**
	 * @brief change window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to change.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the attributes specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the attributes specified by \a value_mask for the specified \a window.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_window_attributes_checked(xcb_connection_t*, xcb_window_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5944</i><br>
	 * @deprecated use the safer method {@link #xcb_change_window_attributes_checked(com.sun.jna.ptr.PointerByReference, int, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_window_attributes_checked(Pointer c, int window, int value_mask, Pointer value_list);
	/**
	 * @brief change window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to change.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the attributes specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the attributes specified by \a value_mask for the specified \a window.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_window_attributes_checked(xcb_connection_t*, xcb_window_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5944</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_window_attributes_checked(PointerByReference c, int window, int value_mask, Pointer value_list);
	/**
	 * @brief change window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to change.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the attributes specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the attributes specified by \a value_mask for the specified \a window.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_window_attributes(xcb_connection_t*, xcb_window_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5965</i><br>
	 * @deprecated use the safer method {@link #xcb_change_window_attributes(com.sun.jna.ptr.PointerByReference, int, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_window_attributes(Pointer c, int window, int value_mask, Pointer value_list);
	/**
	 * @brief change window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to change.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the attributes specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the attributes specified by \a value_mask for the specified \a window.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_window_attributes(xcb_connection_t*, xcb_window_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5965</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_window_attributes(PointerByReference c, int window, int value_mask, Pointer value_list);
	/**
	 * @brief change window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to change.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the attributes specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the attributes specified by \a value_mask for the specified \a window.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_window_attributes_aux_checked(xcb_connection_t*, xcb_window_t, uint32_t, const xcb_change_window_attributes_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5989</i><br>
	 * @deprecated use the safer method {@link #xcb_change_window_attributes_aux_checked(com.sun.jna.ptr.PointerByReference, int, int, com.yi.ylwm.xcb.xcb_change_window_attributes_value_list_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_window_attributes_aux_checked(Pointer c, int window, int value_mask, xcb_change_window_attributes_value_list_t value_list);
	/**
	 * @brief change window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to change.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the attributes specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the attributes specified by \a value_mask for the specified \a window.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_window_attributes_aux_checked(xcb_connection_t*, xcb_window_t, uint32_t, const xcb_change_window_attributes_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:5989</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_window_attributes_aux_checked(PointerByReference c, int window, int value_mask, xcb_change_window_attributes_value_list_t value_list);
	/**
	 * @brief change window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to change.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the attributes specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the attributes specified by \a value_mask for the specified \a window.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_window_attributes_aux(xcb_connection_t*, xcb_window_t, uint32_t, const xcb_change_window_attributes_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6010</i><br>
	 * @deprecated use the safer method {@link #xcb_change_window_attributes_aux(com.sun.jna.ptr.PointerByReference, int, int, com.yi.ylwm.xcb.xcb_change_window_attributes_value_list_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_window_attributes_aux(Pointer c, int window, int value_mask, xcb_change_window_attributes_value_list_t value_list);
	/**
	 * @brief change window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to change.<br>
	 * @param value_mask A bitmask of #xcb_cw_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the attributes specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the attributes specified by \a value_mask for the specified \a window.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_window_attributes_aux(xcb_connection_t*, xcb_window_t, uint32_t, const xcb_change_window_attributes_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6010</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_window_attributes_aux(PointerByReference c, int window, int value_mask, xcb_change_window_attributes_value_list_t value_list);
	/**
	 * Original signature : <code>void* xcb_change_window_attributes_value_list(const xcb_change_window_attributes_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6016</i>
	 */
	Pointer xcb_change_window_attributes_value_list(xcb_change_window_attributes_request_t R);
	/**
	 * @brief Gets window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to get the attributes from.<br>
	 * @return A cookie<br>
	 * Gets the current attributes for the specified \a window.<br>
	 * Original signature : <code>xcb_get_window_attributes_cookie_t xcb_get_window_attributes(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6029</i><br>
	 * @deprecated use the safer method {@link #xcb_get_window_attributes(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_window_attributes_cookie_t.ByValue xcb_get_window_attributes(Pointer c, int window);
	/**
	 * @brief Gets window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to get the attributes from.<br>
	 * @return A cookie<br>
	 * Gets the current attributes for the specified \a window.<br>
	 * Original signature : <code>xcb_get_window_attributes_cookie_t xcb_get_window_attributes(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6029</i>
	 */
	com.yi.ylwm.xcb.xcb_get_window_attributes_cookie_t.ByValue xcb_get_window_attributes(PointerByReference c, int window);
	/**
	 * @brief Gets window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to get the attributes from.<br>
	 * @return A cookie<br>
	 * Gets the current attributes for the specified \a window.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_window_attributes_cookie_t xcb_get_window_attributes_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6046</i><br>
	 * @deprecated use the safer method {@link #xcb_get_window_attributes_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_window_attributes_cookie_t.ByValue xcb_get_window_attributes_unchecked(Pointer c, int window);
	/**
	 * @brief Gets window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to get the attributes from.<br>
	 * @return A cookie<br>
	 * Gets the current attributes for the specified \a window.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_window_attributes_cookie_t xcb_get_window_attributes_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6046</i>
	 */
	com.yi.ylwm.xcb.xcb_get_window_attributes_cookie_t.ByValue xcb_get_window_attributes_unchecked(PointerByReference c, int window);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_window_attributes_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_window_attributes_reply_t* xcb_get_window_attributes_reply(xcb_connection_t*, xcb_get_window_attributes_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6064</i><br>
	 * @deprecated use the safer method {@link #xcb_get_window_attributes_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_get_window_attributes_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_window_attributes_reply_t xcb_get_window_attributes_reply(Pointer c, com.yi.ylwm.xcb.xcb_get_window_attributes_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_window_attributes_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_window_attributes_reply_t* xcb_get_window_attributes_reply(xcb_connection_t*, xcb_get_window_attributes_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6064</i>
	 */
	xcb_get_window_attributes_reply_t xcb_get_window_attributes_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_get_window_attributes_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * @brief Destroys a window<br>
	 * @param c The connection<br>
	 * @param window The window to destroy.<br>
	 * @return A cookie<br>
	 * Destroys the specified window and all of its subwindows. A DestroyNotify event<br>
	 * is generated for each destroyed window (a DestroyNotify event is first generated<br>
	 * for any given window's inferiors). If the window was mapped, it will be<br>
	 * automatically unmapped before destroying.<br>
	 * <br>
	 * Calling DestroyWindow on the root window will do nothing.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_destroy_window_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6087</i><br>
	 * @deprecated use the safer method {@link #xcb_destroy_window_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_destroy_window_checked(Pointer c, int window);
	/**
	 * @brief Destroys a window<br>
	 * @param c The connection<br>
	 * @param window The window to destroy.<br>
	 * @return A cookie<br>
	 * Destroys the specified window and all of its subwindows. A DestroyNotify event<br>
	 * is generated for each destroyed window (a DestroyNotify event is first generated<br>
	 * for any given window's inferiors). If the window was mapped, it will be<br>
	 * automatically unmapped before destroying.<br>
	 * <br>
	 * Calling DestroyWindow on the root window will do nothing.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_destroy_window_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6087</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_destroy_window_checked(PointerByReference c, int window);
	/**
	 * @brief Destroys a window<br>
	 * @param c The connection<br>
	 * @param window The window to destroy.<br>
	 * @return A cookie<br>
	 * Destroys the specified window and all of its subwindows. A DestroyNotify event<br>
	 * is generated for each destroyed window (a DestroyNotify event is first generated<br>
	 * for any given window's inferiors). If the window was mapped, it will be<br>
	 * automatically unmapped before destroying.<br>
	 * <br>
	 * Calling DestroyWindow on the root window will do nothing.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_destroy_window(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6106</i><br>
	 * @deprecated use the safer method {@link #xcb_destroy_window(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_destroy_window(Pointer c, int window);
	/**
	 * @brief Destroys a window<br>
	 * @param c The connection<br>
	 * @param window The window to destroy.<br>
	 * @return A cookie<br>
	 * Destroys the specified window and all of its subwindows. A DestroyNotify event<br>
	 * is generated for each destroyed window (a DestroyNotify event is first generated<br>
	 * for any given window's inferiors). If the window was mapped, it will be<br>
	 * automatically unmapped before destroying.<br>
	 * <br>
	 * Calling DestroyWindow on the root window will do nothing.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_destroy_window(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6106</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_destroy_window(PointerByReference c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_destroy_subwindows_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6121</i><br>
	 * @deprecated use the safer method {@link #xcb_destroy_subwindows_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_destroy_subwindows_checked(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_destroy_subwindows_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6121</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_destroy_subwindows_checked(PointerByReference c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_destroy_subwindows(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6133</i><br>
	 * @deprecated use the safer method {@link #xcb_destroy_subwindows(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_destroy_subwindows(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_destroy_subwindows(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6133</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_destroy_subwindows(PointerByReference c, int window);
	/**
	 * @brief Changes a client's save set<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_set_mode_t values.<br>
	 * @param mode Insert to add the specified window to the save set or Delete to delete it from the save set.<br>
	 * @param window The window to add or delete to/from your save set.<br>
	 * @return A cookie<br>
	 * TODO: explain what the save set is for.<br>
	 * <br>
	 * This function either adds or removes the specified window to the client's (your<br>
	 * application's) save set.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_save_set_checked(xcb_connection_t*, uint8_t, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6155</i><br>
	 * @deprecated use the safer method {@link #xcb_change_save_set_checked(com.sun.jna.ptr.PointerByReference, byte, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_save_set_checked(Pointer c, byte mode, int window);
	/**
	 * @brief Changes a client's save set<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_set_mode_t values.<br>
	 * @param mode Insert to add the specified window to the save set or Delete to delete it from the save set.<br>
	 * @param window The window to add or delete to/from your save set.<br>
	 * @return A cookie<br>
	 * TODO: explain what the save set is for.<br>
	 * <br>
	 * This function either adds or removes the specified window to the client's (your<br>
	 * application's) save set.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_save_set_checked(xcb_connection_t*, uint8_t, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6155</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_save_set_checked(PointerByReference c, byte mode, int window);
	/**
	 * @brief Changes a client's save set<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_set_mode_t values.<br>
	 * @param mode Insert to add the specified window to the save set or Delete to delete it from the save set.<br>
	 * @param window The window to add or delete to/from your save set.<br>
	 * @return A cookie<br>
	 * TODO: explain what the save set is for.<br>
	 * <br>
	 * This function either adds or removes the specified window to the client's (your<br>
	 * application's) save set.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_save_set(xcb_connection_t*, uint8_t, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6175</i><br>
	 * @deprecated use the safer method {@link #xcb_change_save_set(com.sun.jna.ptr.PointerByReference, byte, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_save_set(Pointer c, byte mode, int window);
	/**
	 * @brief Changes a client's save set<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_set_mode_t values.<br>
	 * @param mode Insert to add the specified window to the save set or Delete to delete it from the save set.<br>
	 * @param window The window to add or delete to/from your save set.<br>
	 * @return A cookie<br>
	 * TODO: explain what the save set is for.<br>
	 * <br>
	 * This function either adds or removes the specified window to the client's (your<br>
	 * application's) save set.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_save_set(xcb_connection_t*, uint8_t, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6175</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_save_set(PointerByReference c, byte mode, int window);
	/**
	 * @brief Reparents a window<br>
	 * @param c The connection<br>
	 * @param window The window to reparent.<br>
	 * @param parent The new parent of the window.<br>
	 * @param x The X position of the window within its new parent.<br>
	 * @param y The Y position of the window within its new parent.<br>
	 * @return A cookie<br>
	 * Makes the specified window a child of the specified parent window. If the<br>
	 * window is mapped, it will automatically be unmapped before reparenting and<br>
	 * re-mapped after reparenting. The window is placed in the stacking order on top<br>
	 * with respect to sibling windows.<br>
	 * <br>
	 * After reparenting, a ReparentNotify event is generated.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_reparent_window_checked(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6201</i><br>
	 * @deprecated use the safer method {@link #xcb_reparent_window_checked(com.sun.jna.ptr.PointerByReference, int, int, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_reparent_window_checked(Pointer c, int window, int parent, short x, short y);
	/**
	 * @brief Reparents a window<br>
	 * @param c The connection<br>
	 * @param window The window to reparent.<br>
	 * @param parent The new parent of the window.<br>
	 * @param x The X position of the window within its new parent.<br>
	 * @param y The Y position of the window within its new parent.<br>
	 * @return A cookie<br>
	 * Makes the specified window a child of the specified parent window. If the<br>
	 * window is mapped, it will automatically be unmapped before reparenting and<br>
	 * re-mapped after reparenting. The window is placed in the stacking order on top<br>
	 * with respect to sibling windows.<br>
	 * <br>
	 * After reparenting, a ReparentNotify event is generated.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_reparent_window_checked(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6201</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_reparent_window_checked(PointerByReference c, int window, int parent, short x, short y);
	/**
	 * @brief Reparents a window<br>
	 * @param c The connection<br>
	 * @param window The window to reparent.<br>
	 * @param parent The new parent of the window.<br>
	 * @param x The X position of the window within its new parent.<br>
	 * @param y The Y position of the window within its new parent.<br>
	 * @return A cookie<br>
	 * Makes the specified window a child of the specified parent window. If the<br>
	 * window is mapped, it will automatically be unmapped before reparenting and<br>
	 * re-mapped after reparenting. The window is placed in the stacking order on top<br>
	 * with respect to sibling windows.<br>
	 * <br>
	 * After reparenting, a ReparentNotify event is generated.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_reparent_window(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6226</i><br>
	 * @deprecated use the safer method {@link #xcb_reparent_window(com.sun.jna.ptr.PointerByReference, int, int, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_reparent_window(Pointer c, int window, int parent, short x, short y);
	/**
	 * @brief Reparents a window<br>
	 * @param c The connection<br>
	 * @param window The window to reparent.<br>
	 * @param parent The new parent of the window.<br>
	 * @param x The X position of the window within its new parent.<br>
	 * @param y The Y position of the window within its new parent.<br>
	 * @return A cookie<br>
	 * Makes the specified window a child of the specified parent window. If the<br>
	 * window is mapped, it will automatically be unmapped before reparenting and<br>
	 * re-mapped after reparenting. The window is placed in the stacking order on top<br>
	 * with respect to sibling windows.<br>
	 * <br>
	 * After reparenting, a ReparentNotify event is generated.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_reparent_window(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6226</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_reparent_window(PointerByReference c, int window, int parent, short x, short y);
	/**
	 * @brief Makes a window visible<br>
	 * @param c The connection<br>
	 * @param window The window to make visible.<br>
	 * @return A cookie<br>
	 * Maps the specified window. This means making the window visible (as long as its<br>
	 * parent is visible).<br>
	 * <br>
	 * This MapWindow request will be translated to a MapRequest request if a window<br>
	 * manager is running. The window manager then decides to either map the window or<br>
	 * not. Set the override-redirect window attribute to true if you want to bypass<br>
	 * this mechanism.<br>
	 * <br>
	 * If the window manager decides to map the window (or if no window manager is<br>
	 * running), a MapNotify event is generated.<br>
	 * <br>
	 * If the window becomes viewable and no earlier contents for it are remembered,<br>
	 * the X server tiles the window with its background. If the window's background<br>
	 * is undefined, the existing screen contents are not altered, and the X server<br>
	 * generates zero or more Expose events.<br>
	 * <br>
	 * If the window type is InputOutput, an Expose event will be generated when the<br>
	 * window becomes visible. The normal response to an Expose event should be to<br>
	 * repaint the window.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_map_window_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6264</i><br>
	 * @deprecated use the safer method {@link #xcb_map_window_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_map_window_checked(Pointer c, int window);
	/**
	 * @brief Makes a window visible<br>
	 * @param c The connection<br>
	 * @param window The window to make visible.<br>
	 * @return A cookie<br>
	 * Maps the specified window. This means making the window visible (as long as its<br>
	 * parent is visible).<br>
	 * <br>
	 * This MapWindow request will be translated to a MapRequest request if a window<br>
	 * manager is running. The window manager then decides to either map the window or<br>
	 * not. Set the override-redirect window attribute to true if you want to bypass<br>
	 * this mechanism.<br>
	 * <br>
	 * If the window manager decides to map the window (or if no window manager is<br>
	 * running), a MapNotify event is generated.<br>
	 * <br>
	 * If the window becomes viewable and no earlier contents for it are remembered,<br>
	 * the X server tiles the window with its background. If the window's background<br>
	 * is undefined, the existing screen contents are not altered, and the X server<br>
	 * generates zero or more Expose events.<br>
	 * <br>
	 * If the window type is InputOutput, an Expose event will be generated when the<br>
	 * window becomes visible. The normal response to an Expose event should be to<br>
	 * repaint the window.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_map_window_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6264</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_map_window_checked(PointerByReference c, int window);
	/**
	 * @brief Makes a window visible<br>
	 * @param c The connection<br>
	 * @param window The window to make visible.<br>
	 * @return A cookie<br>
	 * Maps the specified window. This means making the window visible (as long as its<br>
	 * parent is visible).<br>
	 * <br>
	 * This MapWindow request will be translated to a MapRequest request if a window<br>
	 * manager is running. The window manager then decides to either map the window or<br>
	 * not. Set the override-redirect window attribute to true if you want to bypass<br>
	 * this mechanism.<br>
	 * <br>
	 * If the window manager decides to map the window (or if no window manager is<br>
	 * running), a MapNotify event is generated.<br>
	 * <br>
	 * If the window becomes viewable and no earlier contents for it are remembered,<br>
	 * the X server tiles the window with its background. If the window's background<br>
	 * is undefined, the existing screen contents are not altered, and the X server<br>
	 * generates zero or more Expose events.<br>
	 * <br>
	 * If the window type is InputOutput, an Expose event will be generated when the<br>
	 * window becomes visible. The normal response to an Expose event should be to<br>
	 * repaint the window.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_map_window(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6296</i><br>
	 * @deprecated use the safer method {@link #xcb_map_window(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_map_window(Pointer c, int window);
	/**
	 * @brief Makes a window visible<br>
	 * @param c The connection<br>
	 * @param window The window to make visible.<br>
	 * @return A cookie<br>
	 * Maps the specified window. This means making the window visible (as long as its<br>
	 * parent is visible).<br>
	 * <br>
	 * This MapWindow request will be translated to a MapRequest request if a window<br>
	 * manager is running. The window manager then decides to either map the window or<br>
	 * not. Set the override-redirect window attribute to true if you want to bypass<br>
	 * this mechanism.<br>
	 * <br>
	 * If the window manager decides to map the window (or if no window manager is<br>
	 * running), a MapNotify event is generated.<br>
	 * <br>
	 * If the window becomes viewable and no earlier contents for it are remembered,<br>
	 * the X server tiles the window with its background. If the window's background<br>
	 * is undefined, the existing screen contents are not altered, and the X server<br>
	 * generates zero or more Expose events.<br>
	 * <br>
	 * If the window type is InputOutput, an Expose event will be generated when the<br>
	 * window becomes visible. The normal response to an Expose event should be to<br>
	 * repaint the window.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_map_window(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6296</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_map_window(PointerByReference c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_map_subwindows_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6311</i><br>
	 * @deprecated use the safer method {@link #xcb_map_subwindows_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_map_subwindows_checked(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_map_subwindows_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6311</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_map_subwindows_checked(PointerByReference c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_map_subwindows(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6323</i><br>
	 * @deprecated use the safer method {@link #xcb_map_subwindows(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_map_subwindows(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_map_subwindows(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6323</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_map_subwindows(PointerByReference c, int window);
	/**
	 * @brief Makes a window invisible<br>
	 * @param c The connection<br>
	 * @param window The window to make invisible.<br>
	 * @return A cookie<br>
	 * Unmaps the specified window. This means making the window invisible (and all<br>
	 * its child windows).<br>
	 * <br>
	 * Unmapping a window leads to the `UnmapNotify` event being generated. Also,<br>
	 * `Expose` events are generated for formerly obscured windows.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_unmap_window_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6344</i><br>
	 * @deprecated use the safer method {@link #xcb_unmap_window_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_unmap_window_checked(Pointer c, int window);
	/**
	 * @brief Makes a window invisible<br>
	 * @param c The connection<br>
	 * @param window The window to make invisible.<br>
	 * @return A cookie<br>
	 * Unmaps the specified window. This means making the window invisible (and all<br>
	 * its child windows).<br>
	 * <br>
	 * Unmapping a window leads to the `UnmapNotify` event being generated. Also,<br>
	 * `Expose` events are generated for formerly obscured windows.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_unmap_window_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6344</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_unmap_window_checked(PointerByReference c, int window);
	/**
	 * @brief Makes a window invisible<br>
	 * @param c The connection<br>
	 * @param window The window to make invisible.<br>
	 * @return A cookie<br>
	 * Unmaps the specified window. This means making the window invisible (and all<br>
	 * its child windows).<br>
	 * <br>
	 * Unmapping a window leads to the `UnmapNotify` event being generated. Also,<br>
	 * `Expose` events are generated for formerly obscured windows.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_unmap_window(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6362</i><br>
	 * @deprecated use the safer method {@link #xcb_unmap_window(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_unmap_window(Pointer c, int window);
	/**
	 * @brief Makes a window invisible<br>
	 * @param c The connection<br>
	 * @param window The window to make invisible.<br>
	 * @return A cookie<br>
	 * Unmaps the specified window. This means making the window invisible (and all<br>
	 * its child windows).<br>
	 * <br>
	 * Unmapping a window leads to the `UnmapNotify` event being generated. Also,<br>
	 * `Expose` events are generated for formerly obscured windows.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_unmap_window(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6362</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_unmap_window(PointerByReference c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_unmap_subwindows_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6377</i><br>
	 * @deprecated use the safer method {@link #xcb_unmap_subwindows_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_unmap_subwindows_checked(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_unmap_subwindows_checked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6377</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_unmap_subwindows_checked(PointerByReference c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_unmap_subwindows(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6389</i><br>
	 * @deprecated use the safer method {@link #xcb_unmap_subwindows(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_unmap_subwindows(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_unmap_subwindows(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6389</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_unmap_subwindows(PointerByReference c, int window);
	/**
	 * Original signature : <code>int xcb_configure_window_value_list_serialize(void**, uint16_t, const xcb_configure_window_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6393</i>
	 */
	int xcb_configure_window_value_list_serialize(PointerByReference _buffer, short value_mask, xcb_configure_window_value_list_t _aux);
	/**
	 * Original signature : <code>int xcb_configure_window_value_list_unpack(const void*, uint16_t, xcb_configure_window_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6398</i>
	 */
	int xcb_configure_window_value_list_unpack(Pointer _buffer, short value_mask, xcb_configure_window_value_list_t _aux);
	/**
	 * Original signature : <code>int xcb_configure_window_value_list_sizeof(const void*, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6403</i>
	 */
	int xcb_configure_window_value_list_sizeof(Pointer _buffer, short value_mask);
	/**
	 * Original signature : <code>int xcb_configure_window_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6407</i>
	 */
	int xcb_configure_window_sizeof(Pointer _buffer);
	/**
	 * @brief Configures window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to configure.<br>
	 * @param value_mask Bitmask of attributes to change.<br>
	 * @param value_list New values, corresponding to the attributes in value_mask. The order has to<br>
	 * correspond to the order of possible \a value_mask bits. See the example.<br>
	 * @return A cookie<br>
	 * Configures a window's size, position, border width and stacking order.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_configure_window_checked(xcb_connection_t*, xcb_window_t, uint16_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6426</i><br>
	 * @deprecated use the safer method {@link #xcb_configure_window_checked(com.sun.jna.ptr.PointerByReference, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_configure_window_checked(Pointer c, int window, short value_mask, Pointer value_list);
	/**
	 * @brief Configures window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to configure.<br>
	 * @param value_mask Bitmask of attributes to change.<br>
	 * @param value_list New values, corresponding to the attributes in value_mask. The order has to<br>
	 * correspond to the order of possible \a value_mask bits. See the example.<br>
	 * @return A cookie<br>
	 * Configures a window's size, position, border width and stacking order.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_configure_window_checked(xcb_connection_t*, xcb_window_t, uint16_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6426</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_configure_window_checked(PointerByReference c, int window, short value_mask, Pointer value_list);
	/**
	 * @brief Configures window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to configure.<br>
	 * @param value_mask Bitmask of attributes to change.<br>
	 * @param value_list New values, corresponding to the attributes in value_mask. The order has to<br>
	 * correspond to the order of possible \a value_mask bits. See the example.<br>
	 * @return A cookie<br>
	 * Configures a window's size, position, border width and stacking order.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_configure_window(xcb_connection_t*, xcb_window_t, uint16_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6445</i><br>
	 * @deprecated use the safer method {@link #xcb_configure_window(com.sun.jna.ptr.PointerByReference, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_configure_window(Pointer c, int window, short value_mask, Pointer value_list);
	/**
	 * @brief Configures window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to configure.<br>
	 * @param value_mask Bitmask of attributes to change.<br>
	 * @param value_list New values, corresponding to the attributes in value_mask. The order has to<br>
	 * correspond to the order of possible \a value_mask bits. See the example.<br>
	 * @return A cookie<br>
	 * Configures a window's size, position, border width and stacking order.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_configure_window(xcb_connection_t*, xcb_window_t, uint16_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6445</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_configure_window(PointerByReference c, int window, short value_mask, Pointer value_list);
	/**
	 * @brief Configures window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to configure.<br>
	 * @param value_mask Bitmask of attributes to change.<br>
	 * @param value_list New values, corresponding to the attributes in value_mask. The order has to<br>
	 * correspond to the order of possible \a value_mask bits. See the example.<br>
	 * @return A cookie<br>
	 * Configures a window's size, position, border width and stacking order.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_configure_window_aux_checked(xcb_connection_t*, xcb_window_t, uint16_t, const xcb_configure_window_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6467</i><br>
	 * @deprecated use the safer method {@link #xcb_configure_window_aux_checked(com.sun.jna.ptr.PointerByReference, int, short, com.yi.ylwm.xcb.xcb_configure_window_value_list_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_configure_window_aux_checked(Pointer c, int window, short value_mask, xcb_configure_window_value_list_t value_list);
	/**
	 * @brief Configures window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to configure.<br>
	 * @param value_mask Bitmask of attributes to change.<br>
	 * @param value_list New values, corresponding to the attributes in value_mask. The order has to<br>
	 * correspond to the order of possible \a value_mask bits. See the example.<br>
	 * @return A cookie<br>
	 * Configures a window's size, position, border width and stacking order.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_configure_window_aux_checked(xcb_connection_t*, xcb_window_t, uint16_t, const xcb_configure_window_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6467</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_configure_window_aux_checked(PointerByReference c, int window, short value_mask, xcb_configure_window_value_list_t value_list);
	/**
	 * @brief Configures window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to configure.<br>
	 * @param value_mask Bitmask of attributes to change.<br>
	 * @param value_list New values, corresponding to the attributes in value_mask. The order has to<br>
	 * correspond to the order of possible \a value_mask bits. See the example.<br>
	 * @return A cookie<br>
	 * Configures a window's size, position, border width and stacking order.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_configure_window_aux(xcb_connection_t*, xcb_window_t, uint16_t, const xcb_configure_window_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6486</i><br>
	 * @deprecated use the safer method {@link #xcb_configure_window_aux(com.sun.jna.ptr.PointerByReference, int, short, com.yi.ylwm.xcb.xcb_configure_window_value_list_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_configure_window_aux(Pointer c, int window, short value_mask, xcb_configure_window_value_list_t value_list);
	/**
	 * @brief Configures window attributes<br>
	 * @param c The connection<br>
	 * @param window The window to configure.<br>
	 * @param value_mask Bitmask of attributes to change.<br>
	 * @param value_list New values, corresponding to the attributes in value_mask. The order has to<br>
	 * correspond to the order of possible \a value_mask bits. See the example.<br>
	 * @return A cookie<br>
	 * Configures a window's size, position, border width and stacking order.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_configure_window_aux(xcb_connection_t*, xcb_window_t, uint16_t, const xcb_configure_window_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6486</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_configure_window_aux(PointerByReference c, int window, short value_mask, xcb_configure_window_value_list_t value_list);
	/**
	 * Original signature : <code>void* xcb_configure_window_value_list(const xcb_configure_window_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6492</i>
	 */
	Pointer xcb_configure_window_value_list(xcb_configure_window_request_t R);
	/**
	 * @brief Change window stacking order<br>
	 * @param c The connection<br>
	 * @param direction A bitmask of #xcb_circulate_t values.<br>
	 * @param direction \n<br>
	 * @param window The window to raise/lower (depending on \a direction).<br>
	 * @return A cookie<br>
	 * If \a direction is `XCB_CIRCULATE_RAISE_LOWEST`, the lowest mapped child (if<br>
	 * any) will be raised to the top of the stack.<br>
	 * <br>
	 * If \a direction is `XCB_CIRCULATE_LOWER_HIGHEST`, the highest mapped child will<br>
	 * be lowered to the bottom of the stack.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_circulate_window_checked(xcb_connection_t*, uint8_t, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6514</i><br>
	 * @deprecated use the safer method {@link #xcb_circulate_window_checked(com.sun.jna.ptr.PointerByReference, byte, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_circulate_window_checked(Pointer c, byte direction, int window);
	/**
	 * @brief Change window stacking order<br>
	 * @param c The connection<br>
	 * @param direction A bitmask of #xcb_circulate_t values.<br>
	 * @param direction \n<br>
	 * @param window The window to raise/lower (depending on \a direction).<br>
	 * @return A cookie<br>
	 * If \a direction is `XCB_CIRCULATE_RAISE_LOWEST`, the lowest mapped child (if<br>
	 * any) will be raised to the top of the stack.<br>
	 * <br>
	 * If \a direction is `XCB_CIRCULATE_LOWER_HIGHEST`, the highest mapped child will<br>
	 * be lowered to the bottom of the stack.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_circulate_window_checked(xcb_connection_t*, uint8_t, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6514</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_circulate_window_checked(PointerByReference c, byte direction, int window);
	/**
	 * @brief Change window stacking order<br>
	 * @param c The connection<br>
	 * @param direction A bitmask of #xcb_circulate_t values.<br>
	 * @param direction \n<br>
	 * @param window The window to raise/lower (depending on \a direction).<br>
	 * @return A cookie<br>
	 * If \a direction is `XCB_CIRCULATE_RAISE_LOWEST`, the lowest mapped child (if<br>
	 * any) will be raised to the top of the stack.<br>
	 * <br>
	 * If \a direction is `XCB_CIRCULATE_LOWER_HIGHEST`, the highest mapped child will<br>
	 * be lowered to the bottom of the stack.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_circulate_window(xcb_connection_t*, uint8_t, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6535</i><br>
	 * @deprecated use the safer method {@link #xcb_circulate_window(com.sun.jna.ptr.PointerByReference, byte, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_circulate_window(Pointer c, byte direction, int window);
	/**
	 * @brief Change window stacking order<br>
	 * @param c The connection<br>
	 * @param direction A bitmask of #xcb_circulate_t values.<br>
	 * @param direction \n<br>
	 * @param window The window to raise/lower (depending on \a direction).<br>
	 * @return A cookie<br>
	 * If \a direction is `XCB_CIRCULATE_RAISE_LOWEST`, the lowest mapped child (if<br>
	 * any) will be raised to the top of the stack.<br>
	 * <br>
	 * If \a direction is `XCB_CIRCULATE_LOWER_HIGHEST`, the highest mapped child will<br>
	 * be lowered to the bottom of the stack.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_circulate_window(xcb_connection_t*, uint8_t, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6535</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_circulate_window(PointerByReference c, byte direction, int window);
	/**
	 * @brief Get current window geometry<br>
	 * @param c The connection<br>
	 * @param drawable The drawable (`Window` or `Pixmap`) of which the geometry will be received.<br>
	 * @return A cookie<br>
	 * Gets the current geometry of the specified drawable (either `Window` or `Pixmap`).<br>
	 * Original signature : <code>xcb_get_geometry_cookie_t xcb_get_geometry(xcb_connection_t*, xcb_drawable_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6550</i><br>
	 * @deprecated use the safer method {@link #xcb_get_geometry(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_geometry_cookie_t.ByValue xcb_get_geometry(Pointer c, int drawable);
	/**
	 * @brief Get current window geometry<br>
	 * @param c The connection<br>
	 * @param drawable The drawable (`Window` or `Pixmap`) of which the geometry will be received.<br>
	 * @return A cookie<br>
	 * Gets the current geometry of the specified drawable (either `Window` or `Pixmap`).<br>
	 * Original signature : <code>xcb_get_geometry_cookie_t xcb_get_geometry(xcb_connection_t*, xcb_drawable_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6550</i>
	 */
	com.yi.ylwm.xcb.xcb_get_geometry_cookie_t.ByValue xcb_get_geometry(PointerByReference c, int drawable);
	/**
	 * @brief Get current window geometry<br>
	 * @param c The connection<br>
	 * @param drawable The drawable (`Window` or `Pixmap`) of which the geometry will be received.<br>
	 * @return A cookie<br>
	 * Gets the current geometry of the specified drawable (either `Window` or `Pixmap`).<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_geometry_cookie_t xcb_get_geometry_unchecked(xcb_connection_t*, xcb_drawable_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6567</i><br>
	 * @deprecated use the safer method {@link #xcb_get_geometry_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_geometry_cookie_t.ByValue xcb_get_geometry_unchecked(Pointer c, int drawable);
	/**
	 * @brief Get current window geometry<br>
	 * @param c The connection<br>
	 * @param drawable The drawable (`Window` or `Pixmap`) of which the geometry will be received.<br>
	 * @return A cookie<br>
	 * Gets the current geometry of the specified drawable (either `Window` or `Pixmap`).<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_geometry_cookie_t xcb_get_geometry_unchecked(xcb_connection_t*, xcb_drawable_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6567</i>
	 */
	com.yi.ylwm.xcb.xcb_get_geometry_cookie_t.ByValue xcb_get_geometry_unchecked(PointerByReference c, int drawable);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_geometry_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_geometry_reply_t* xcb_get_geometry_reply(xcb_connection_t*, xcb_get_geometry_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6585</i><br>
	 * @deprecated use the safer method {@link #xcb_get_geometry_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_get_geometry_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_geometry_reply_t xcb_get_geometry_reply(Pointer c, com.yi.ylwm.xcb.xcb_get_geometry_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_geometry_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_geometry_reply_t* xcb_get_geometry_reply(xcb_connection_t*, xcb_get_geometry_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6585</i>
	 */
	xcb_get_geometry_reply_t xcb_get_geometry_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_get_geometry_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_query_tree_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6590</i>
	 */
	int xcb_query_tree_sizeof(Pointer _buffer);
	/**
	 * @brief query the window tree<br>
	 * @param c The connection<br>
	 * @param window The \a window to query.<br>
	 * @return A cookie<br>
	 * Gets the root window ID, parent window ID and list of children windows for the<br>
	 * specified \a window. The children are listed in bottom-to-top stacking order.<br>
	 * Original signature : <code>xcb_query_tree_cookie_t xcb_query_tree(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6604</i><br>
	 * @deprecated use the safer method {@link #xcb_query_tree(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_query_tree_cookie_t.ByValue xcb_query_tree(Pointer c, int window);
	/**
	 * @brief query the window tree<br>
	 * @param c The connection<br>
	 * @param window The \a window to query.<br>
	 * @return A cookie<br>
	 * Gets the root window ID, parent window ID and list of children windows for the<br>
	 * specified \a window. The children are listed in bottom-to-top stacking order.<br>
	 * Original signature : <code>xcb_query_tree_cookie_t xcb_query_tree(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6604</i>
	 */
	com.yi.ylwm.xcb.xcb_query_tree_cookie_t.ByValue xcb_query_tree(PointerByReference c, int window);
	/**
	 * @brief query the window tree<br>
	 * @param c The connection<br>
	 * @param window The \a window to query.<br>
	 * @return A cookie<br>
	 * Gets the root window ID, parent window ID and list of children windows for the<br>
	 * specified \a window. The children are listed in bottom-to-top stacking order.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_tree_cookie_t xcb_query_tree_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6622</i><br>
	 * @deprecated use the safer method {@link #xcb_query_tree_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_query_tree_cookie_t.ByValue xcb_query_tree_unchecked(Pointer c, int window);
	/**
	 * @brief query the window tree<br>
	 * @param c The connection<br>
	 * @param window The \a window to query.<br>
	 * @return A cookie<br>
	 * Gets the root window ID, parent window ID and list of children windows for the<br>
	 * specified \a window. The children are listed in bottom-to-top stacking order.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_tree_cookie_t xcb_query_tree_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6622</i>
	 */
	com.yi.ylwm.xcb.xcb_query_tree_cookie_t.ByValue xcb_query_tree_unchecked(PointerByReference c, int window);
	/**
	 * Original signature : <code>xcb_window_t* xcb_query_tree_children(const xcb_query_tree_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6626</i>
	 */
	IntByReference xcb_query_tree_children(xcb_query_tree_reply_t R);
	/**
	 * Original signature : <code>int xcb_query_tree_children_length(const xcb_query_tree_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6629</i>
	 */
	int xcb_query_tree_children_length(xcb_query_tree_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_query_tree_children_end(const xcb_query_tree_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6632</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_query_tree_children_end(xcb_query_tree_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_tree_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_tree_reply_t* xcb_query_tree_reply(xcb_connection_t*, xcb_query_tree_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6649</i><br>
	 * @deprecated use the safer method {@link #xcb_query_tree_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_query_tree_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_query_tree_reply_t xcb_query_tree_reply(Pointer c, com.yi.ylwm.xcb.xcb_query_tree_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_tree_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_tree_reply_t* xcb_query_tree_reply(xcb_connection_t*, xcb_query_tree_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6649</i>
	 */
	xcb_query_tree_reply_t xcb_query_tree_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_query_tree_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_intern_atom_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6654</i>
	 */
	int xcb_intern_atom_sizeof(Pointer _buffer);
	/**
	 * @brief Get atom identifier by name<br>
	 * @param c The connection<br>
	 * @param only_if_exists Return a valid atom id only if the atom already exists.<br>
	 * @param name_len The length of the following \a name.<br>
	 * @param name The name of the atom.<br>
	 * @return A cookie<br>
	 * Retrieves the identifier (xcb_atom_t TODO) for the atom with the specified<br>
	 * name. Atoms are used in protocols like EWMH, for example to store window titles<br>
	 * (`_NET_WM_NAME` atom) as property of a window.<br>
	 * <br>
	 * If \a only_if_exists is 0, the atom will be created if it does not already exist.<br>
	 * If \a only_if_exists is 1, `XCB_ATOM_NONE` will be returned if the atom does<br>
	 * not yet exist.<br>
	 * Original signature : <code>xcb_intern_atom_cookie_t xcb_intern_atom(xcb_connection_t*, uint8_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6675</i><br>
	 * @deprecated use the safer methods {@link #xcb_intern_atom(com.sun.jna.ptr.PointerByReference, byte, short, java.lang.String)} and {@link #xcb_intern_atom(com.sun.jna.ptr.PointerByReference, byte, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_intern_atom_cookie_t.ByValue xcb_intern_atom(Pointer c, byte only_if_exists, short name_len, Pointer name);
	/**
	 * @brief Get atom identifier by name<br>
	 * @param c The connection<br>
	 * @param only_if_exists Return a valid atom id only if the atom already exists.<br>
	 * @param name_len The length of the following \a name.<br>
	 * @param name The name of the atom.<br>
	 * @return A cookie<br>
	 * Retrieves the identifier (xcb_atom_t TODO) for the atom with the specified<br>
	 * name. Atoms are used in protocols like EWMH, for example to store window titles<br>
	 * (`_NET_WM_NAME` atom) as property of a window.<br>
	 * <br>
	 * If \a only_if_exists is 0, the atom will be created if it does not already exist.<br>
	 * If \a only_if_exists is 1, `XCB_ATOM_NONE` will be returned if the atom does<br>
	 * not yet exist.<br>
	 * Original signature : <code>xcb_intern_atom_cookie_t xcb_intern_atom(xcb_connection_t*, uint8_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6675</i>
	 */
	com.yi.ylwm.xcb.xcb_intern_atom_cookie_t.ByValue xcb_intern_atom(PointerByReference c, byte only_if_exists, short name_len, String name);
	/**
	 * @brief Get atom identifier by name<br>
	 * @param c The connection<br>
	 * @param only_if_exists Return a valid atom id only if the atom already exists.<br>
	 * @param name_len The length of the following \a name.<br>
	 * @param name The name of the atom.<br>
	 * @return A cookie<br>
	 * Retrieves the identifier (xcb_atom_t TODO) for the atom with the specified<br>
	 * name. Atoms are used in protocols like EWMH, for example to store window titles<br>
	 * (`_NET_WM_NAME` atom) as property of a window.<br>
	 * <br>
	 * If \a only_if_exists is 0, the atom will be created if it does not already exist.<br>
	 * If \a only_if_exists is 1, `XCB_ATOM_NONE` will be returned if the atom does<br>
	 * not yet exist.<br>
	 * Original signature : <code>xcb_intern_atom_cookie_t xcb_intern_atom(xcb_connection_t*, uint8_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6675</i>
	 */
	com.yi.ylwm.xcb.xcb_intern_atom_cookie_t.ByValue xcb_intern_atom(PointerByReference c, byte only_if_exists, short name_len, Pointer name);
	/**
	 * @brief Get atom identifier by name<br>
	 * @param c The connection<br>
	 * @param only_if_exists Return a valid atom id only if the atom already exists.<br>
	 * @param name_len The length of the following \a name.<br>
	 * @param name The name of the atom.<br>
	 * @return A cookie<br>
	 * Retrieves the identifier (xcb_atom_t TODO) for the atom with the specified<br>
	 * name. Atoms are used in protocols like EWMH, for example to store window titles<br>
	 * (`_NET_WM_NAME` atom) as property of a window.<br>
	 * <br>
	 * If \a only_if_exists is 0, the atom will be created if it does not already exist.<br>
	 * If \a only_if_exists is 1, `XCB_ATOM_NONE` will be returned if the atom does<br>
	 * not yet exist.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_intern_atom_cookie_t xcb_intern_atom_unchecked(xcb_connection_t*, uint8_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6702</i><br>
	 * @deprecated use the safer methods {@link #xcb_intern_atom_unchecked(com.sun.jna.ptr.PointerByReference, byte, short, java.lang.String)} and {@link #xcb_intern_atom_unchecked(com.sun.jna.ptr.PointerByReference, byte, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_intern_atom_cookie_t.ByValue xcb_intern_atom_unchecked(Pointer c, byte only_if_exists, short name_len, Pointer name);
	/**
	 * @brief Get atom identifier by name<br>
	 * @param c The connection<br>
	 * @param only_if_exists Return a valid atom id only if the atom already exists.<br>
	 * @param name_len The length of the following \a name.<br>
	 * @param name The name of the atom.<br>
	 * @return A cookie<br>
	 * Retrieves the identifier (xcb_atom_t TODO) for the atom with the specified<br>
	 * name. Atoms are used in protocols like EWMH, for example to store window titles<br>
	 * (`_NET_WM_NAME` atom) as property of a window.<br>
	 * <br>
	 * If \a only_if_exists is 0, the atom will be created if it does not already exist.<br>
	 * If \a only_if_exists is 1, `XCB_ATOM_NONE` will be returned if the atom does<br>
	 * not yet exist.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_intern_atom_cookie_t xcb_intern_atom_unchecked(xcb_connection_t*, uint8_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6702</i>
	 */
	com.yi.ylwm.xcb.xcb_intern_atom_cookie_t.ByValue xcb_intern_atom_unchecked(PointerByReference c, byte only_if_exists, short name_len, String name);
	/**
	 * @brief Get atom identifier by name<br>
	 * @param c The connection<br>
	 * @param only_if_exists Return a valid atom id only if the atom already exists.<br>
	 * @param name_len The length of the following \a name.<br>
	 * @param name The name of the atom.<br>
	 * @return A cookie<br>
	 * Retrieves the identifier (xcb_atom_t TODO) for the atom with the specified<br>
	 * name. Atoms are used in protocols like EWMH, for example to store window titles<br>
	 * (`_NET_WM_NAME` atom) as property of a window.<br>
	 * <br>
	 * If \a only_if_exists is 0, the atom will be created if it does not already exist.<br>
	 * If \a only_if_exists is 1, `XCB_ATOM_NONE` will be returned if the atom does<br>
	 * not yet exist.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_intern_atom_cookie_t xcb_intern_atom_unchecked(xcb_connection_t*, uint8_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6702</i>
	 */
	com.yi.ylwm.xcb.xcb_intern_atom_cookie_t.ByValue xcb_intern_atom_unchecked(PointerByReference c, byte only_if_exists, short name_len, Pointer name);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_intern_atom_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_intern_atom_reply_t* xcb_intern_atom_reply(xcb_connection_t*, xcb_intern_atom_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6722</i><br>
	 * @deprecated use the safer method {@link #xcb_intern_atom_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_intern_atom_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_intern_atom_reply_t xcb_intern_atom_reply(Pointer c, com.yi.ylwm.xcb.xcb_intern_atom_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_intern_atom_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_intern_atom_reply_t* xcb_intern_atom_reply(xcb_connection_t*, xcb_intern_atom_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6722</i>
	 */
	xcb_intern_atom_reply_t xcb_intern_atom_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_intern_atom_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_get_atom_name_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6727</i>
	 */
	int xcb_get_atom_name_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_atom_name_cookie_t xcb_get_atom_name(xcb_connection_t*, xcb_atom_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6738</i><br>
	 * @deprecated use the safer method {@link #xcb_get_atom_name(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_atom_name_cookie_t.ByValue xcb_get_atom_name(Pointer c, int atom);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_atom_name_cookie_t xcb_get_atom_name(xcb_connection_t*, xcb_atom_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6738</i>
	 */
	com.yi.ylwm.xcb.xcb_get_atom_name_cookie_t.ByValue xcb_get_atom_name(PointerByReference c, int atom);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_atom_name_cookie_t xcb_get_atom_name_unchecked(xcb_connection_t*, xcb_atom_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6753</i><br>
	 * @deprecated use the safer method {@link #xcb_get_atom_name_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_atom_name_cookie_t.ByValue xcb_get_atom_name_unchecked(Pointer c, int atom);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_atom_name_cookie_t xcb_get_atom_name_unchecked(xcb_connection_t*, xcb_atom_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6753</i>
	 */
	com.yi.ylwm.xcb.xcb_get_atom_name_cookie_t.ByValue xcb_get_atom_name_unchecked(PointerByReference c, int atom);
	/**
	 * Original signature : <code>char* xcb_get_atom_name_name(const xcb_get_atom_name_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6757</i>
	 */
	Pointer xcb_get_atom_name_name(xcb_get_atom_name_reply_t R);
	/**
	 * Original signature : <code>int xcb_get_atom_name_name_length(const xcb_get_atom_name_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6760</i>
	 */
	int xcb_get_atom_name_name_length(xcb_get_atom_name_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_get_atom_name_name_end(const xcb_get_atom_name_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6763</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_get_atom_name_name_end(xcb_get_atom_name_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_atom_name_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_atom_name_reply_t* xcb_get_atom_name_reply(xcb_connection_t*, xcb_get_atom_name_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6780</i><br>
	 * @deprecated use the safer method {@link #xcb_get_atom_name_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_get_atom_name_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_atom_name_reply_t xcb_get_atom_name_reply(Pointer c, com.yi.ylwm.xcb.xcb_get_atom_name_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_atom_name_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_atom_name_reply_t* xcb_get_atom_name_reply(xcb_connection_t*, xcb_get_atom_name_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6780</i>
	 */
	xcb_get_atom_name_reply_t xcb_get_atom_name_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_get_atom_name_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_change_property_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6785</i>
	 */
	int xcb_change_property_sizeof(Pointer _buffer);
	/**
	 * @brief Changes a window property<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_prop_mode_t values.<br>
	 * @param mode \n<br>
	 * @param window The window whose property you want to change.<br>
	 * @param property The property you want to change (an atom).<br>
	 * @param type The type of the property you want to change (an atom).<br>
	 * @param format Specifies whether the data should be viewed as a list of 8-bit, 16-bit or<br>
	 * 32-bit quantities. Possible values are 8, 16 and 32. This information allows<br>
	 * the X server to correctly perform byte-swap operations as necessary.<br>
	 * @param data_len Specifies the number of elements (see \a format).<br>
	 * @param data The property data.<br>
	 * @return A cookie<br>
	 * Sets or updates a property on the specified \a window. Properties are for<br>
	 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).<br>
	 * Protocols such as EWMH also use properties - for example EWMH defines the<br>
	 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_property_checked(xcb_connection_t*, uint8_t, xcb_window_t, __declspec(property) xcb_atom_t, xcb_atom_t, uint8_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6813</i><br>
	 * @deprecated use the safer method {@link #xcb_change_property_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, int, byte, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_property_checked(Pointer c, byte mode, int window, int xcb_atom_t1, int type, byte format, int data_len, Pointer data);
	/**
	 * @brief Changes a window property<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_prop_mode_t values.<br>
	 * @param mode \n<br>
	 * @param window The window whose property you want to change.<br>
	 * @param property The property you want to change (an atom).<br>
	 * @param type The type of the property you want to change (an atom).<br>
	 * @param format Specifies whether the data should be viewed as a list of 8-bit, 16-bit or<br>
	 * 32-bit quantities. Possible values are 8, 16 and 32. This information allows<br>
	 * the X server to correctly perform byte-swap operations as necessary.<br>
	 * @param data_len Specifies the number of elements (see \a format).<br>
	 * @param data The property data.<br>
	 * @return A cookie<br>
	 * Sets or updates a property on the specified \a window. Properties are for<br>
	 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).<br>
	 * Protocols such as EWMH also use properties - for example EWMH defines the<br>
	 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_property_checked(xcb_connection_t*, uint8_t, xcb_window_t, __declspec(property) xcb_atom_t, xcb_atom_t, uint8_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6813</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_property_checked(PointerByReference c, byte mode, int window, int xcb_atom_t1, int type, byte format, int data_len, Pointer data);
	/**
	 * @brief Changes a window property<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_prop_mode_t values.<br>
	 * @param mode \n<br>
	 * @param window The window whose property you want to change.<br>
	 * @param property The property you want to change (an atom).<br>
	 * @param type The type of the property you want to change (an atom).<br>
	 * @param format Specifies whether the data should be viewed as a list of 8-bit, 16-bit or<br>
	 * 32-bit quantities. Possible values are 8, 16 and 32. This information allows<br>
	 * the X server to correctly perform byte-swap operations as necessary.<br>
	 * @param data_len Specifies the number of elements (see \a format).<br>
	 * @param data The property data.<br>
	 * @return A cookie<br>
	 * Sets or updates a property on the specified \a window. Properties are for<br>
	 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).<br>
	 * Protocols such as EWMH also use properties - for example EWMH defines the<br>
	 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_property(xcb_connection_t*, uint8_t, xcb_window_t, __declspec(property) xcb_atom_t, xcb_atom_t, uint8_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6845</i><br>
	 * @deprecated use the safer method {@link #xcb_change_property(com.sun.jna.ptr.PointerByReference, byte, int, int, int, byte, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_property(Pointer c, byte mode, int window, int xcb_atom_t1, int type, byte format, int data_len, Pointer data);
	/**
	 * @brief Changes a window property<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_prop_mode_t values.<br>
	 * @param mode \n<br>
	 * @param window The window whose property you want to change.<br>
	 * @param property The property you want to change (an atom).<br>
	 * @param type The type of the property you want to change (an atom).<br>
	 * @param format Specifies whether the data should be viewed as a list of 8-bit, 16-bit or<br>
	 * 32-bit quantities. Possible values are 8, 16 and 32. This information allows<br>
	 * the X server to correctly perform byte-swap operations as necessary.<br>
	 * @param data_len Specifies the number of elements (see \a format).<br>
	 * @param data The property data.<br>
	 * @return A cookie<br>
	 * Sets or updates a property on the specified \a window. Properties are for<br>
	 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).<br>
	 * Protocols such as EWMH also use properties - for example EWMH defines the<br>
	 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_property(xcb_connection_t*, uint8_t, xcb_window_t, __declspec(property) xcb_atom_t, xcb_atom_t, uint8_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6845</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_property(PointerByReference c, byte mode, int window, int xcb_atom_t1, int type, byte format, int data_len, Pointer data);
	/**
	 * Original signature : <code>void* xcb_change_property_data(const xcb_change_property_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6855</i>
	 */
	Pointer xcb_change_property_data(xcb_change_property_request_t R);
	/**
	 * Original signature : <code>int xcb_change_property_data_length(const xcb_change_property_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6858</i>
	 */
	int xcb_change_property_data_length(xcb_change_property_request_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_change_property_data_end(const xcb_change_property_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6861</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_change_property_data_end(xcb_change_property_request_t R);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_delete_property_checked(xcb_connection_t*, xcb_window_t, __declspec(property) xcb_atom_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6875</i><br>
	 * @deprecated use the safer method {@link #xcb_delete_property_checked(com.sun.jna.ptr.PointerByReference, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_delete_property_checked(Pointer c, int window, int xcb_atom_t1);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_delete_property_checked(xcb_connection_t*, xcb_window_t, __declspec(property) xcb_atom_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6875</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_delete_property_checked(PointerByReference c, int window, int xcb_atom_t1);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_delete_property(xcb_connection_t*, xcb_window_t, __declspec(property) xcb_atom_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6888</i><br>
	 * @deprecated use the safer method {@link #xcb_delete_property(com.sun.jna.ptr.PointerByReference, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_delete_property(Pointer c, int window, int xcb_atom_t1);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_delete_property(xcb_connection_t*, xcb_window_t, __declspec(property) xcb_atom_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6888</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_delete_property(PointerByReference c, int window, int xcb_atom_t1);
	/**
	 * Original signature : <code>int xcb_get_property_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6893</i>
	 */
	int xcb_get_property_sizeof(Pointer _buffer);
	/**
	 * @brief Gets a window property<br>
	 * @param c The connection<br>
	 * @param _delete Whether the property should actually be deleted. For deleting a property, the<br>
	 * specified \a type has to match the actual property type.<br>
	 * @param window The window whose property you want to get.<br>
	 * @param property The property you want to get (an atom).<br>
	 * @param type The type of the property you want to get (an atom).<br>
	 * @param long_offset Specifies the offset (in 32-bit multiples) in the specified property where the<br>
	 * data is to be retrieved.<br>
	 * @param long_length Specifies how many 32-bit multiples of data should be retrieved (e.g. if you<br>
	 * set \a long_length to 4, you will receive 16 bytes of data).<br>
	 * @return A cookie<br>
	 * Gets the specified \a property from the specified \a window. Properties are for<br>
	 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).<br>
	 * Protocols such as EWMH also use properties - for example EWMH defines the<br>
	 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.<br>
	 * <br>
	 * TODO: talk about \a type<br>
	 * <br>
	 * TODO: talk about `delete`<br>
	 * <br>
	 * TODO: talk about the offset/length thing. what's a valid use case?<br>
	 * Original signature : <code>xcb_get_property_cookie_t xcb_get_property(xcb_connection_t*, uint8_t, xcb_window_t, __declspec(property) xcb_atom_t, xcb_atom_t, uint32_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6923</i><br>
	 * @deprecated use the safer method {@link #xcb_get_property(com.sun.jna.ptr.PointerByReference, byte, int, int, int, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_property_cookie_t.ByValue xcb_get_property(Pointer c, byte _delete, int window, int xcb_atom_t1, int type, int long_offset, int long_length);
	/**
	 * @brief Gets a window property<br>
	 * @param c The connection<br>
	 * @param _delete Whether the property should actually be deleted. For deleting a property, the<br>
	 * specified \a type has to match the actual property type.<br>
	 * @param window The window whose property you want to get.<br>
	 * @param property The property you want to get (an atom).<br>
	 * @param type The type of the property you want to get (an atom).<br>
	 * @param long_offset Specifies the offset (in 32-bit multiples) in the specified property where the<br>
	 * data is to be retrieved.<br>
	 * @param long_length Specifies how many 32-bit multiples of data should be retrieved (e.g. if you<br>
	 * set \a long_length to 4, you will receive 16 bytes of data).<br>
	 * @return A cookie<br>
	 * Gets the specified \a property from the specified \a window. Properties are for<br>
	 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).<br>
	 * Protocols such as EWMH also use properties - for example EWMH defines the<br>
	 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.<br>
	 * <br>
	 * TODO: talk about \a type<br>
	 * <br>
	 * TODO: talk about `delete`<br>
	 * <br>
	 * TODO: talk about the offset/length thing. what's a valid use case?<br>
	 * Original signature : <code>xcb_get_property_cookie_t xcb_get_property(xcb_connection_t*, uint8_t, xcb_window_t, __declspec(property) xcb_atom_t, xcb_atom_t, uint32_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6923</i>
	 */
	com.yi.ylwm.xcb.xcb_get_property_cookie_t.ByValue xcb_get_property(PointerByReference c, byte _delete, int window, int xcb_atom_t1, int type, int long_offset, int long_length);
	/**
	 * @brief Gets a window property<br>
	 * @param c The connection<br>
	 * @param _delete Whether the property should actually be deleted. For deleting a property, the<br>
	 * specified \a type has to match the actual property type.<br>
	 * @param window The window whose property you want to get.<br>
	 * @param property The property you want to get (an atom).<br>
	 * @param type The type of the property you want to get (an atom).<br>
	 * @param long_offset Specifies the offset (in 32-bit multiples) in the specified property where the<br>
	 * data is to be retrieved.<br>
	 * @param long_length Specifies how many 32-bit multiples of data should be retrieved (e.g. if you<br>
	 * set \a long_length to 4, you will receive 16 bytes of data).<br>
	 * @return A cookie<br>
	 * Gets the specified \a property from the specified \a window. Properties are for<br>
	 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).<br>
	 * Protocols such as EWMH also use properties - for example EWMH defines the<br>
	 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.<br>
	 * <br>
	 * TODO: talk about \a type<br>
	 * <br>
	 * TODO: talk about `delete`<br>
	 * <br>
	 * TODO: talk about the offset/length thing. what's a valid use case?<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_property_cookie_t xcb_get_property_unchecked(xcb_connection_t*, uint8_t, xcb_window_t, __declspec(property) xcb_atom_t, xcb_atom_t, uint32_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6962</i><br>
	 * @deprecated use the safer method {@link #xcb_get_property_unchecked(com.sun.jna.ptr.PointerByReference, byte, int, int, int, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_property_cookie_t.ByValue xcb_get_property_unchecked(Pointer c, byte _delete, int window, int xcb_atom_t1, int type, int long_offset, int long_length);
	/**
	 * @brief Gets a window property<br>
	 * @param c The connection<br>
	 * @param _delete Whether the property should actually be deleted. For deleting a property, the<br>
	 * specified \a type has to match the actual property type.<br>
	 * @param window The window whose property you want to get.<br>
	 * @param property The property you want to get (an atom).<br>
	 * @param type The type of the property you want to get (an atom).<br>
	 * @param long_offset Specifies the offset (in 32-bit multiples) in the specified property where the<br>
	 * data is to be retrieved.<br>
	 * @param long_length Specifies how many 32-bit multiples of data should be retrieved (e.g. if you<br>
	 * set \a long_length to 4, you will receive 16 bytes of data).<br>
	 * @return A cookie<br>
	 * Gets the specified \a property from the specified \a window. Properties are for<br>
	 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).<br>
	 * Protocols such as EWMH also use properties - for example EWMH defines the<br>
	 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.<br>
	 * <br>
	 * TODO: talk about \a type<br>
	 * <br>
	 * TODO: talk about `delete`<br>
	 * <br>
	 * TODO: talk about the offset/length thing. what's a valid use case?<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_property_cookie_t xcb_get_property_unchecked(xcb_connection_t*, uint8_t, xcb_window_t, __declspec(property) xcb_atom_t, xcb_atom_t, uint32_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6962</i>
	 */
	com.yi.ylwm.xcb.xcb_get_property_cookie_t.ByValue xcb_get_property_unchecked(PointerByReference c, byte _delete, int window, int xcb_atom_t1, int type, int long_offset, int long_length);
	/**
	 * Original signature : <code>void* xcb_get_property_value(const xcb_get_property_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6971</i>
	 */
	Pointer xcb_get_property_value(xcb_get_property_reply_t R);
	/**
	 * Original signature : <code>int xcb_get_property_value_length(const xcb_get_property_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6974</i>
	 */
	int xcb_get_property_value_length(xcb_get_property_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_get_property_value_end(const xcb_get_property_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6977</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_get_property_value_end(xcb_get_property_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_property_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_property_reply_t* xcb_get_property_reply(xcb_connection_t*, xcb_get_property_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6994</i><br>
	 * @deprecated use the safer method {@link #xcb_get_property_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_get_property_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_property_reply_t xcb_get_property_reply(Pointer c, com.yi.ylwm.xcb.xcb_get_property_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_property_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_property_reply_t* xcb_get_property_reply(xcb_connection_t*, xcb_get_property_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6994</i>
	 */
	xcb_get_property_reply_t xcb_get_property_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_get_property_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_list_properties_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:6999</i>
	 */
	int xcb_list_properties_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_list_properties_cookie_t xcb_list_properties(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7010</i><br>
	 * @deprecated use the safer method {@link #xcb_list_properties(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_list_properties_cookie_t.ByValue xcb_list_properties(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_list_properties_cookie_t xcb_list_properties(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7010</i>
	 */
	com.yi.ylwm.xcb.xcb_list_properties_cookie_t.ByValue xcb_list_properties(PointerByReference c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_properties_cookie_t xcb_list_properties_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7025</i><br>
	 * @deprecated use the safer method {@link #xcb_list_properties_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_list_properties_cookie_t.ByValue xcb_list_properties_unchecked(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_properties_cookie_t xcb_list_properties_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7025</i>
	 */
	com.yi.ylwm.xcb.xcb_list_properties_cookie_t.ByValue xcb_list_properties_unchecked(PointerByReference c, int window);
	/**
	 * Original signature : <code>xcb_atom_t* xcb_list_properties_atoms(const xcb_list_properties_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7029</i>
	 */
	IntByReference xcb_list_properties_atoms(xcb_list_properties_reply_t R);
	/**
	 * Original signature : <code>int xcb_list_properties_atoms_length(const xcb_list_properties_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7032</i>
	 */
	int xcb_list_properties_atoms_length(xcb_list_properties_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_list_properties_atoms_end(const xcb_list_properties_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7035</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_list_properties_atoms_end(xcb_list_properties_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_properties_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_properties_reply_t* xcb_list_properties_reply(xcb_connection_t*, xcb_list_properties_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7052</i><br>
	 * @deprecated use the safer method {@link #xcb_list_properties_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_list_properties_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_list_properties_reply_t xcb_list_properties_reply(Pointer c, com.yi.ylwm.xcb.xcb_list_properties_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_properties_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_properties_reply_t* xcb_list_properties_reply(xcb_connection_t*, xcb_list_properties_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7052</i>
	 */
	xcb_list_properties_reply_t xcb_list_properties_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_list_properties_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * @brief Sets the owner of a selection<br>
	 * @param c The connection<br>
	 * @param owner The new owner of the selection.<br>
	 * \n<br>
	 * The special value `XCB_NONE` means that the selection will have no owner.<br>
	 * @param selection The selection.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The selection will not be changed if \a time is earlier than the current<br>
	 * last-change time of the \a selection or is later than the current X server time.<br>
	 * Otherwise, the last-change time is set to the specified time.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Makes `window` the owner of the selection \a selection and updates the<br>
	 * last-change time of the specified selection.<br>
	 * <br>
	 * TODO: briefly explain what a selection is.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_selection_owner_checked(xcb_connection_t*, xcb_window_t, xcb_atom_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7084</i><br>
	 * @deprecated use the safer method {@link #xcb_set_selection_owner_checked(com.sun.jna.ptr.PointerByReference, int, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_selection_owner_checked(Pointer c, int owner, int selection, int time);
	/**
	 * @brief Sets the owner of a selection<br>
	 * @param c The connection<br>
	 * @param owner The new owner of the selection.<br>
	 * \n<br>
	 * The special value `XCB_NONE` means that the selection will have no owner.<br>
	 * @param selection The selection.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The selection will not be changed if \a time is earlier than the current<br>
	 * last-change time of the \a selection or is later than the current X server time.<br>
	 * Otherwise, the last-change time is set to the specified time.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Makes `window` the owner of the selection \a selection and updates the<br>
	 * last-change time of the specified selection.<br>
	 * <br>
	 * TODO: briefly explain what a selection is.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_selection_owner_checked(xcb_connection_t*, xcb_window_t, xcb_atom_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7084</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_selection_owner_checked(PointerByReference c, int owner, int selection, int time);
	/**
	 * @brief Sets the owner of a selection<br>
	 * @param c The connection<br>
	 * @param owner The new owner of the selection.<br>
	 * \n<br>
	 * The special value `XCB_NONE` means that the selection will have no owner.<br>
	 * @param selection The selection.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The selection will not be changed if \a time is earlier than the current<br>
	 * last-change time of the \a selection or is later than the current X server time.<br>
	 * Otherwise, the last-change time is set to the specified time.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Makes `window` the owner of the selection \a selection and updates the<br>
	 * last-change time of the specified selection.<br>
	 * <br>
	 * TODO: briefly explain what a selection is.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_selection_owner(xcb_connection_t*, xcb_window_t, xcb_atom_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7114</i><br>
	 * @deprecated use the safer method {@link #xcb_set_selection_owner(com.sun.jna.ptr.PointerByReference, int, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_selection_owner(Pointer c, int owner, int selection, int time);
	/**
	 * @brief Sets the owner of a selection<br>
	 * @param c The connection<br>
	 * @param owner The new owner of the selection.<br>
	 * \n<br>
	 * The special value `XCB_NONE` means that the selection will have no owner.<br>
	 * @param selection The selection.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The selection will not be changed if \a time is earlier than the current<br>
	 * last-change time of the \a selection or is later than the current X server time.<br>
	 * Otherwise, the last-change time is set to the specified time.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Makes `window` the owner of the selection \a selection and updates the<br>
	 * last-change time of the specified selection.<br>
	 * <br>
	 * TODO: briefly explain what a selection is.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_selection_owner(xcb_connection_t*, xcb_window_t, xcb_atom_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7114</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_selection_owner(PointerByReference c, int owner, int selection, int time);
	/**
	 * @brief Gets the owner of a selection<br>
	 * @param c The connection<br>
	 * @param selection The selection.<br>
	 * @return A cookie<br>
	 * Gets the owner of the specified selection.<br>
	 * <br>
	 * TODO: briefly explain what a selection is.<br>
	 * Original signature : <code>xcb_get_selection_owner_cookie_t xcb_get_selection_owner(xcb_connection_t*, xcb_atom_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7132</i><br>
	 * @deprecated use the safer method {@link #xcb_get_selection_owner(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_selection_owner_cookie_t.ByValue xcb_get_selection_owner(Pointer c, int selection);
	/**
	 * @brief Gets the owner of a selection<br>
	 * @param c The connection<br>
	 * @param selection The selection.<br>
	 * @return A cookie<br>
	 * Gets the owner of the specified selection.<br>
	 * <br>
	 * TODO: briefly explain what a selection is.<br>
	 * Original signature : <code>xcb_get_selection_owner_cookie_t xcb_get_selection_owner(xcb_connection_t*, xcb_atom_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7132</i>
	 */
	com.yi.ylwm.xcb.xcb_get_selection_owner_cookie_t.ByValue xcb_get_selection_owner(PointerByReference c, int selection);
	/**
	 * @brief Gets the owner of a selection<br>
	 * @param c The connection<br>
	 * @param selection The selection.<br>
	 * @return A cookie<br>
	 * Gets the owner of the specified selection.<br>
	 * <br>
	 * TODO: briefly explain what a selection is.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_selection_owner_cookie_t xcb_get_selection_owner_unchecked(xcb_connection_t*, xcb_atom_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7151</i><br>
	 * @deprecated use the safer method {@link #xcb_get_selection_owner_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_selection_owner_cookie_t.ByValue xcb_get_selection_owner_unchecked(Pointer c, int selection);
	/**
	 * @brief Gets the owner of a selection<br>
	 * @param c The connection<br>
	 * @param selection The selection.<br>
	 * @return A cookie<br>
	 * Gets the owner of the specified selection.<br>
	 * <br>
	 * TODO: briefly explain what a selection is.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_selection_owner_cookie_t xcb_get_selection_owner_unchecked(xcb_connection_t*, xcb_atom_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7151</i>
	 */
	com.yi.ylwm.xcb.xcb_get_selection_owner_cookie_t.ByValue xcb_get_selection_owner_unchecked(PointerByReference c, int selection);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_selection_owner_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_selection_owner_reply_t* xcb_get_selection_owner_reply(xcb_connection_t*, xcb_get_selection_owner_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7169</i><br>
	 * @deprecated use the safer method {@link #xcb_get_selection_owner_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_get_selection_owner_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_selection_owner_reply_t xcb_get_selection_owner_reply(Pointer c, com.yi.ylwm.xcb.xcb_get_selection_owner_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_selection_owner_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_selection_owner_reply_t* xcb_get_selection_owner_reply(xcb_connection_t*, xcb_get_selection_owner_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7169</i>
	 */
	xcb_get_selection_owner_reply_t xcb_get_selection_owner_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_get_selection_owner_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_convert_selection_checked(xcb_connection_t*, xcb_window_t, xcb_atom_t, xcb_atom_t, __declspec(property) xcb_atom_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7185</i><br>
	 * @deprecated use the safer method {@link #xcb_convert_selection_checked(com.sun.jna.ptr.PointerByReference, int, int, int, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_convert_selection_checked(Pointer c, int requestor, int selection, int target, int xcb_atom_t1, int time);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_convert_selection_checked(xcb_connection_t*, xcb_window_t, xcb_atom_t, xcb_atom_t, __declspec(property) xcb_atom_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7185</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_convert_selection_checked(PointerByReference c, int requestor, int selection, int target, int xcb_atom_t1, int time);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_convert_selection(xcb_connection_t*, xcb_window_t, xcb_atom_t, xcb_atom_t, __declspec(property) xcb_atom_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7201</i><br>
	 * @deprecated use the safer method {@link #xcb_convert_selection(com.sun.jna.ptr.PointerByReference, int, int, int, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_convert_selection(Pointer c, int requestor, int selection, int target, int xcb_atom_t1, int time);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_convert_selection(xcb_connection_t*, xcb_window_t, xcb_atom_t, xcb_atom_t, __declspec(property) xcb_atom_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7201</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_convert_selection(PointerByReference c, int requestor, int selection, int target, int xcb_atom_t1, int time);
	/**
	 * @brief send an event<br>
	 * @param c The connection<br>
	 * @param propagate If \a propagate is true and no clients have selected any event on \a destination,<br>
	 * the destination is replaced with the closest ancestor of \a destination for<br>
	 * which some client has selected a type in \a event_mask and for which no<br>
	 * intervening window has that type in its do-not-propagate-mask. If no such<br>
	 * window exists or if the window is an ancestor of the focus window and<br>
	 * `InputFocus` was originally specified as the destination, the event is not sent<br>
	 * to any clients. Otherwise, the event is reported to every client selecting on<br>
	 * the final destination any of the types specified in \a event_mask.<br>
	 * @param destination The window to send this event to. Every client which selects any event within<br>
	 * \a event_mask on \a destination will get the event.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_POINTER_WINDOW` refers to the window<br>
	 * that contains the mouse pointer.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_ITEM_FOCUS` refers to the window which<br>
	 * has the keyboard focus.<br>
	 * @param event_mask Event_mask for determining which clients should receive the specified event.<br>
	 * See \a destination and \a propagate.<br>
	 * @param event The event to send to the specified \a destination.<br>
	 * @return A cookie<br>
	 * Identifies the \a destination window, determines which clients should receive<br>
	 * the specified event and ignores any active grabs.<br>
	 * <br>
	 * The \a event must be one of the core events or an event defined by an extension,<br>
	 * so that the X server can correctly byte-swap the contents as necessary. The<br>
	 * contents of \a event are otherwise unaltered and unchecked except for the<br>
	 * `send_event` field which is forced to 'true'.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_send_event_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint32_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7246</i><br>
	 * @deprecated use the safer methods {@link #xcb_send_event_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, java.lang.String)} and {@link #xcb_send_event_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_send_event_checked(Pointer c, byte propagate, int destination, int event_mask, Pointer event);
	/**
	 * @brief send an event<br>
	 * @param c The connection<br>
	 * @param propagate If \a propagate is true and no clients have selected any event on \a destination,<br>
	 * the destination is replaced with the closest ancestor of \a destination for<br>
	 * which some client has selected a type in \a event_mask and for which no<br>
	 * intervening window has that type in its do-not-propagate-mask. If no such<br>
	 * window exists or if the window is an ancestor of the focus window and<br>
	 * `InputFocus` was originally specified as the destination, the event is not sent<br>
	 * to any clients. Otherwise, the event is reported to every client selecting on<br>
	 * the final destination any of the types specified in \a event_mask.<br>
	 * @param destination The window to send this event to. Every client which selects any event within<br>
	 * \a event_mask on \a destination will get the event.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_POINTER_WINDOW` refers to the window<br>
	 * that contains the mouse pointer.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_ITEM_FOCUS` refers to the window which<br>
	 * has the keyboard focus.<br>
	 * @param event_mask Event_mask for determining which clients should receive the specified event.<br>
	 * See \a destination and \a propagate.<br>
	 * @param event The event to send to the specified \a destination.<br>
	 * @return A cookie<br>
	 * Identifies the \a destination window, determines which clients should receive<br>
	 * the specified event and ignores any active grabs.<br>
	 * <br>
	 * The \a event must be one of the core events or an event defined by an extension,<br>
	 * so that the X server can correctly byte-swap the contents as necessary. The<br>
	 * contents of \a event are otherwise unaltered and unchecked except for the<br>
	 * `send_event` field which is forced to 'true'.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_send_event_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint32_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7246</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_send_event_checked(PointerByReference c, byte propagate, int destination, int event_mask, String event);
	/**
	 * @brief send an event<br>
	 * @param c The connection<br>
	 * @param propagate If \a propagate is true and no clients have selected any event on \a destination,<br>
	 * the destination is replaced with the closest ancestor of \a destination for<br>
	 * which some client has selected a type in \a event_mask and for which no<br>
	 * intervening window has that type in its do-not-propagate-mask. If no such<br>
	 * window exists or if the window is an ancestor of the focus window and<br>
	 * `InputFocus` was originally specified as the destination, the event is not sent<br>
	 * to any clients. Otherwise, the event is reported to every client selecting on<br>
	 * the final destination any of the types specified in \a event_mask.<br>
	 * @param destination The window to send this event to. Every client which selects any event within<br>
	 * \a event_mask on \a destination will get the event.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_POINTER_WINDOW` refers to the window<br>
	 * that contains the mouse pointer.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_ITEM_FOCUS` refers to the window which<br>
	 * has the keyboard focus.<br>
	 * @param event_mask Event_mask for determining which clients should receive the specified event.<br>
	 * See \a destination and \a propagate.<br>
	 * @param event The event to send to the specified \a destination.<br>
	 * @return A cookie<br>
	 * Identifies the \a destination window, determines which clients should receive<br>
	 * the specified event and ignores any active grabs.<br>
	 * <br>
	 * The \a event must be one of the core events or an event defined by an extension,<br>
	 * so that the X server can correctly byte-swap the contents as necessary. The<br>
	 * contents of \a event are otherwise unaltered and unchecked except for the<br>
	 * `send_event` field which is forced to 'true'.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_send_event_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint32_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7246</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_send_event_checked(PointerByReference c, byte propagate, int destination, int event_mask, Pointer event);
	/**
	 * @brief send an event<br>
	 * @param c The connection<br>
	 * @param propagate If \a propagate is true and no clients have selected any event on \a destination,<br>
	 * the destination is replaced with the closest ancestor of \a destination for<br>
	 * which some client has selected a type in \a event_mask and for which no<br>
	 * intervening window has that type in its do-not-propagate-mask. If no such<br>
	 * window exists or if the window is an ancestor of the focus window and<br>
	 * `InputFocus` was originally specified as the destination, the event is not sent<br>
	 * to any clients. Otherwise, the event is reported to every client selecting on<br>
	 * the final destination any of the types specified in \a event_mask.<br>
	 * @param destination The window to send this event to. Every client which selects any event within<br>
	 * \a event_mask on \a destination will get the event.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_POINTER_WINDOW` refers to the window<br>
	 * that contains the mouse pointer.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_ITEM_FOCUS` refers to the window which<br>
	 * has the keyboard focus.<br>
	 * @param event_mask Event_mask for determining which clients should receive the specified event.<br>
	 * See \a destination and \a propagate.<br>
	 * @param event The event to send to the specified \a destination.<br>
	 * @return A cookie<br>
	 * Identifies the \a destination window, determines which clients should receive<br>
	 * the specified event and ignores any active grabs.<br>
	 * <br>
	 * The \a event must be one of the core events or an event defined by an extension,<br>
	 * so that the X server can correctly byte-swap the contents as necessary. The<br>
	 * contents of \a event are otherwise unaltered and unchecked except for the<br>
	 * `send_event` field which is forced to 'true'.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_send_event(xcb_connection_t*, uint8_t, xcb_window_t, uint32_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7287</i><br>
	 * @deprecated use the safer methods {@link #xcb_send_event(com.sun.jna.ptr.PointerByReference, byte, int, int, java.lang.String)} and {@link #xcb_send_event(com.sun.jna.ptr.PointerByReference, byte, int, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_send_event(Pointer c, byte propagate, int destination, int event_mask, Pointer event);
	/**
	 * @brief send an event<br>
	 * @param c The connection<br>
	 * @param propagate If \a propagate is true and no clients have selected any event on \a destination,<br>
	 * the destination is replaced with the closest ancestor of \a destination for<br>
	 * which some client has selected a type in \a event_mask and for which no<br>
	 * intervening window has that type in its do-not-propagate-mask. If no such<br>
	 * window exists or if the window is an ancestor of the focus window and<br>
	 * `InputFocus` was originally specified as the destination, the event is not sent<br>
	 * to any clients. Otherwise, the event is reported to every client selecting on<br>
	 * the final destination any of the types specified in \a event_mask.<br>
	 * @param destination The window to send this event to. Every client which selects any event within<br>
	 * \a event_mask on \a destination will get the event.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_POINTER_WINDOW` refers to the window<br>
	 * that contains the mouse pointer.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_ITEM_FOCUS` refers to the window which<br>
	 * has the keyboard focus.<br>
	 * @param event_mask Event_mask for determining which clients should receive the specified event.<br>
	 * See \a destination and \a propagate.<br>
	 * @param event The event to send to the specified \a destination.<br>
	 * @return A cookie<br>
	 * Identifies the \a destination window, determines which clients should receive<br>
	 * the specified event and ignores any active grabs.<br>
	 * <br>
	 * The \a event must be one of the core events or an event defined by an extension,<br>
	 * so that the X server can correctly byte-swap the contents as necessary. The<br>
	 * contents of \a event are otherwise unaltered and unchecked except for the<br>
	 * `send_event` field which is forced to 'true'.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_send_event(xcb_connection_t*, uint8_t, xcb_window_t, uint32_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7287</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_send_event(PointerByReference c, byte propagate, int destination, int event_mask, String event);
	/**
	 * @brief send an event<br>
	 * @param c The connection<br>
	 * @param propagate If \a propagate is true and no clients have selected any event on \a destination,<br>
	 * the destination is replaced with the closest ancestor of \a destination for<br>
	 * which some client has selected a type in \a event_mask and for which no<br>
	 * intervening window has that type in its do-not-propagate-mask. If no such<br>
	 * window exists or if the window is an ancestor of the focus window and<br>
	 * `InputFocus` was originally specified as the destination, the event is not sent<br>
	 * to any clients. Otherwise, the event is reported to every client selecting on<br>
	 * the final destination any of the types specified in \a event_mask.<br>
	 * @param destination The window to send this event to. Every client which selects any event within<br>
	 * \a event_mask on \a destination will get the event.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_POINTER_WINDOW` refers to the window<br>
	 * that contains the mouse pointer.<br>
	 * \n<br>
	 * The special value `XCB_SEND_EVENT_DEST_ITEM_FOCUS` refers to the window which<br>
	 * has the keyboard focus.<br>
	 * @param event_mask Event_mask for determining which clients should receive the specified event.<br>
	 * See \a destination and \a propagate.<br>
	 * @param event The event to send to the specified \a destination.<br>
	 * @return A cookie<br>
	 * Identifies the \a destination window, determines which clients should receive<br>
	 * the specified event and ignores any active grabs.<br>
	 * <br>
	 * The \a event must be one of the core events or an event defined by an extension,<br>
	 * so that the X server can correctly byte-swap the contents as necessary. The<br>
	 * contents of \a event are otherwise unaltered and unchecked except for the<br>
	 * `send_event` field which is forced to 'true'.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_send_event(xcb_connection_t*, uint8_t, xcb_window_t, uint32_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7287</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_send_event(PointerByReference c, byte propagate, int destination, int event_mask, Pointer event);
	/**
	 * @brief Grab the pointer<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param event_mask Specifies which pointer events are reported to the client.<br>
	 * \n<br>
	 * TODO: which values?<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to<br>
	 * move the pointer out of that window).<br>
	 * \n<br>
	 * The special value `XCB_NONE` means don't confine the pointer.<br>
	 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the<br>
	 * cursor.<br>
	 * @param time The time argument allows you to avoid certain circumstances that come up if<br>
	 * applications take a long time to respond or if there are long network delays.<br>
	 * Consider a situation where you have two applications, both of which normally<br>
	 * grab the pointer when clicked on. If both applications specify the timestamp<br>
	 * from the event, the second application may wake up faster and successfully grab<br>
	 * the pointer before the first application. The first application then will get<br>
	 * an indication that the other application grabbed the pointer before its request<br>
	 * was processed.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Actively grabs control of the pointer. Further pointer events are reported only to the grabbing client. Overrides any active pointer grab by this client.<br>
	 * Original signature : <code>xcb_grab_pointer_cookie_t xcb_grab_pointer(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, uint8_t, uint8_t, xcb_window_t, xcb_cursor_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7330</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_pointer(com.sun.jna.ptr.PointerByReference, byte, int, short, byte, byte, int, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_grab_pointer_cookie_t.ByValue xcb_grab_pointer(Pointer c, byte owner_events, int grab_window, short event_mask, byte pointer_mode, byte keyboard_mode, int confine_to, int cursor, int time);
	/**
	 * @brief Grab the pointer<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param event_mask Specifies which pointer events are reported to the client.<br>
	 * \n<br>
	 * TODO: which values?<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to<br>
	 * move the pointer out of that window).<br>
	 * \n<br>
	 * The special value `XCB_NONE` means don't confine the pointer.<br>
	 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the<br>
	 * cursor.<br>
	 * @param time The time argument allows you to avoid certain circumstances that come up if<br>
	 * applications take a long time to respond or if there are long network delays.<br>
	 * Consider a situation where you have two applications, both of which normally<br>
	 * grab the pointer when clicked on. If both applications specify the timestamp<br>
	 * from the event, the second application may wake up faster and successfully grab<br>
	 * the pointer before the first application. The first application then will get<br>
	 * an indication that the other application grabbed the pointer before its request<br>
	 * was processed.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Actively grabs control of the pointer. Further pointer events are reported only to the grabbing client. Overrides any active pointer grab by this client.<br>
	 * Original signature : <code>xcb_grab_pointer_cookie_t xcb_grab_pointer(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, uint8_t, uint8_t, xcb_window_t, xcb_cursor_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7330</i>
	 */
	com.yi.ylwm.xcb.xcb_grab_pointer_cookie_t.ByValue xcb_grab_pointer(PointerByReference c, byte owner_events, int grab_window, short event_mask, byte pointer_mode, byte keyboard_mode, int confine_to, int cursor, int time);
	/**
	 * @brief Grab the pointer<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param event_mask Specifies which pointer events are reported to the client.<br>
	 * \n<br>
	 * TODO: which values?<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to<br>
	 * move the pointer out of that window).<br>
	 * \n<br>
	 * The special value `XCB_NONE` means don't confine the pointer.<br>
	 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the<br>
	 * cursor.<br>
	 * @param time The time argument allows you to avoid certain circumstances that come up if<br>
	 * applications take a long time to respond or if there are long network delays.<br>
	 * Consider a situation where you have two applications, both of which normally<br>
	 * grab the pointer when clicked on. If both applications specify the timestamp<br>
	 * from the event, the second application may wake up faster and successfully grab<br>
	 * the pointer before the first application. The first application then will get<br>
	 * an indication that the other application grabbed the pointer before its request<br>
	 * was processed.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Actively grabs control of the pointer. Further pointer events are reported only to the grabbing client. Overrides any active pointer grab by this client.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_grab_pointer_cookie_t xcb_grab_pointer_unchecked(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, uint8_t, uint8_t, xcb_window_t, xcb_cursor_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7380</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_pointer_unchecked(com.sun.jna.ptr.PointerByReference, byte, int, short, byte, byte, int, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_grab_pointer_cookie_t.ByValue xcb_grab_pointer_unchecked(Pointer c, byte owner_events, int grab_window, short event_mask, byte pointer_mode, byte keyboard_mode, int confine_to, int cursor, int time);
	/**
	 * @brief Grab the pointer<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param event_mask Specifies which pointer events are reported to the client.<br>
	 * \n<br>
	 * TODO: which values?<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to<br>
	 * move the pointer out of that window).<br>
	 * \n<br>
	 * The special value `XCB_NONE` means don't confine the pointer.<br>
	 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the<br>
	 * cursor.<br>
	 * @param time The time argument allows you to avoid certain circumstances that come up if<br>
	 * applications take a long time to respond or if there are long network delays.<br>
	 * Consider a situation where you have two applications, both of which normally<br>
	 * grab the pointer when clicked on. If both applications specify the timestamp<br>
	 * from the event, the second application may wake up faster and successfully grab<br>
	 * the pointer before the first application. The first application then will get<br>
	 * an indication that the other application grabbed the pointer before its request<br>
	 * was processed.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Actively grabs control of the pointer. Further pointer events are reported only to the grabbing client. Overrides any active pointer grab by this client.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_grab_pointer_cookie_t xcb_grab_pointer_unchecked(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, uint8_t, uint8_t, xcb_window_t, xcb_cursor_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7380</i>
	 */
	com.yi.ylwm.xcb.xcb_grab_pointer_cookie_t.ByValue xcb_grab_pointer_unchecked(PointerByReference c, byte owner_events, int grab_window, short event_mask, byte pointer_mode, byte keyboard_mode, int confine_to, int cursor, int time);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_grab_pointer_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_grab_pointer_reply_t* xcb_grab_pointer_reply(xcb_connection_t*, xcb_grab_pointer_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7405</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_pointer_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_grab_pointer_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_grab_pointer_reply_t xcb_grab_pointer_reply(Pointer c, com.yi.ylwm.xcb.xcb_grab_pointer_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_grab_pointer_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_grab_pointer_reply_t* xcb_grab_pointer_reply(xcb_connection_t*, xcb_grab_pointer_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7405</i>
	 */
	xcb_grab_pointer_reply_t xcb_grab_pointer_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_grab_pointer_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * @brief release the pointer<br>
	 * @param c The connection<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The pointer will not be released if \a time is earlier than the<br>
	 * last-pointer-grab time or later than the current X server time.<br>
	 * @return A cookie<br>
	 * Releases the pointer and any queued events if you actively grabbed the pointer<br>
	 * before using `xcb_grab_pointer`, `xcb_grab_button` or within a normal button<br>
	 * press.<br>
	 * <br>
	 * EnterNotify and LeaveNotify events are generated.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_pointer_checked(xcb_connection_t*, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7430</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_pointer_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_pointer_checked(Pointer c, int time);
	/**
	 * @brief release the pointer<br>
	 * @param c The connection<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The pointer will not be released if \a time is earlier than the<br>
	 * last-pointer-grab time or later than the current X server time.<br>
	 * @return A cookie<br>
	 * Releases the pointer and any queued events if you actively grabbed the pointer<br>
	 * before using `xcb_grab_pointer`, `xcb_grab_button` or within a normal button<br>
	 * press.<br>
	 * <br>
	 * EnterNotify and LeaveNotify events are generated.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_pointer_checked(xcb_connection_t*, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7430</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_pointer_checked(PointerByReference c, int time);
	/**
	 * @brief release the pointer<br>
	 * @param c The connection<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The pointer will not be released if \a time is earlier than the<br>
	 * last-pointer-grab time or later than the current X server time.<br>
	 * @return A cookie<br>
	 * Releases the pointer and any queued events if you actively grabbed the pointer<br>
	 * before using `xcb_grab_pointer`, `xcb_grab_button` or within a normal button<br>
	 * press.<br>
	 * <br>
	 * EnterNotify and LeaveNotify events are generated.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_pointer(xcb_connection_t*, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7451</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_pointer(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_pointer(Pointer c, int time);
	/**
	 * @brief release the pointer<br>
	 * @param c The connection<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The pointer will not be released if \a time is earlier than the<br>
	 * last-pointer-grab time or later than the current X server time.<br>
	 * @return A cookie<br>
	 * Releases the pointer and any queued events if you actively grabbed the pointer<br>
	 * before using `xcb_grab_pointer`, `xcb_grab_button` or within a normal button<br>
	 * press.<br>
	 * <br>
	 * EnterNotify and LeaveNotify events are generated.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_pointer(xcb_connection_t*, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7451</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_pointer(PointerByReference c, int time);
	/**
	 * @brief Grab pointer button(s)<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param event_mask Specifies which pointer events are reported to the client.<br>
	 * \n<br>
	 * TODO: which values?<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to<br>
	 * move the pointer out of that window).<br>
	 * \n<br>
	 * The special value `XCB_NONE` means don't confine the pointer.<br>
	 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the<br>
	 * cursor.<br>
	 * @param button A bitmask of #xcb_button_index_t values.<br>
	 * @param button \n<br>
	 * @param modifiers The modifiers to grab.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all<br>
	 * possible modifier combinations.<br>
	 * @return A cookie<br>
	 * This request establishes a passive grab. The pointer is actively grabbed as<br>
	 * described in GrabPointer, the last-pointer-grab time is set to the time at<br>
	 * which the button was pressed (as transmitted in the ButtonPress event), and the<br>
	 * ButtonPress event is reported if all of the following conditions are true:<br>
	 * <br>
	 * The pointer is not grabbed and the specified button is logically pressed when<br>
	 * the specified modifier keys are logically down, and no other buttons or<br>
	 * modifier keys are logically down.<br>
	 * <br>
	 * The grab-window contains the pointer.<br>
	 * <br>
	 * The confine-to window (if any) is viewable.<br>
	 * <br>
	 * A passive grab on the same button/key combination does not exist on any<br>
	 * ancestor of grab-window.<br>
	 * <br>
	 * The interpretation of the remaining arguments is the same as for GrabPointer.<br>
	 * The active grab is terminated automatically when the logical state of the<br>
	 * pointer has all buttons released, independent of the logical state of modifier<br>
	 * keys. Note that the logical state of a device (as seen by means of the<br>
	 * protocol) may lag the physical state if device event processing is frozen. This<br>
	 * request overrides all previous passive grabs by the same client on the same<br>
	 * button/key combinations on the same window. A modifier of AnyModifier is<br>
	 * equivalent to issuing the request for all possible modifier combinations<br>
	 * (including the combination of no modifiers). It is not required that all<br>
	 * specified modifiers have currently assigned keycodes. A button of AnyButton is<br>
	 * equivalent to issuing the request for all possible buttons. Otherwise, it is<br>
	 * not required that the button specified currently be assigned to a physical<br>
	 * button.<br>
	 * <br>
	 * An Access error is generated if some other client has already issued a<br>
	 * GrabButton request with the same button/key combination on the same window.<br>
	 * When using AnyModifier or AnyButton, the request fails completely (no grabs are<br>
	 * established), and an Access error is generated if there is a conflicting grab<br>
	 * for any combination. The request has no effect on an active grab.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_button_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, uint8_t, uint8_t, xcb_window_t, xcb_cursor_t, uint8_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7523</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_button_checked(com.sun.jna.ptr.PointerByReference, byte, int, short, byte, byte, int, int, byte, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_grab_button_checked(Pointer c, byte owner_events, int grab_window, short event_mask, byte pointer_mode, byte keyboard_mode, int confine_to, int cursor, byte button, short modifiers);
	/**
	 * @brief Grab pointer button(s)<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param event_mask Specifies which pointer events are reported to the client.<br>
	 * \n<br>
	 * TODO: which values?<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to<br>
	 * move the pointer out of that window).<br>
	 * \n<br>
	 * The special value `XCB_NONE` means don't confine the pointer.<br>
	 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the<br>
	 * cursor.<br>
	 * @param button A bitmask of #xcb_button_index_t values.<br>
	 * @param button \n<br>
	 * @param modifiers The modifiers to grab.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all<br>
	 * possible modifier combinations.<br>
	 * @return A cookie<br>
	 * This request establishes a passive grab. The pointer is actively grabbed as<br>
	 * described in GrabPointer, the last-pointer-grab time is set to the time at<br>
	 * which the button was pressed (as transmitted in the ButtonPress event), and the<br>
	 * ButtonPress event is reported if all of the following conditions are true:<br>
	 * <br>
	 * The pointer is not grabbed and the specified button is logically pressed when<br>
	 * the specified modifier keys are logically down, and no other buttons or<br>
	 * modifier keys are logically down.<br>
	 * <br>
	 * The grab-window contains the pointer.<br>
	 * <br>
	 * The confine-to window (if any) is viewable.<br>
	 * <br>
	 * A passive grab on the same button/key combination does not exist on any<br>
	 * ancestor of grab-window.<br>
	 * <br>
	 * The interpretation of the remaining arguments is the same as for GrabPointer.<br>
	 * The active grab is terminated automatically when the logical state of the<br>
	 * pointer has all buttons released, independent of the logical state of modifier<br>
	 * keys. Note that the logical state of a device (as seen by means of the<br>
	 * protocol) may lag the physical state if device event processing is frozen. This<br>
	 * request overrides all previous passive grabs by the same client on the same<br>
	 * button/key combinations on the same window. A modifier of AnyModifier is<br>
	 * equivalent to issuing the request for all possible modifier combinations<br>
	 * (including the combination of no modifiers). It is not required that all<br>
	 * specified modifiers have currently assigned keycodes. A button of AnyButton is<br>
	 * equivalent to issuing the request for all possible buttons. Otherwise, it is<br>
	 * not required that the button specified currently be assigned to a physical<br>
	 * button.<br>
	 * <br>
	 * An Access error is generated if some other client has already issued a<br>
	 * GrabButton request with the same button/key combination on the same window.<br>
	 * When using AnyModifier or AnyButton, the request fails completely (no grabs are<br>
	 * established), and an Access error is generated if there is a conflicting grab<br>
	 * for any combination. The request has no effect on an active grab.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_button_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, uint8_t, uint8_t, xcb_window_t, xcb_cursor_t, uint8_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7523</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_grab_button_checked(PointerByReference c, byte owner_events, int grab_window, short event_mask, byte pointer_mode, byte keyboard_mode, int confine_to, int cursor, byte button, short modifiers);
	/**
	 * @brief Grab pointer button(s)<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param event_mask Specifies which pointer events are reported to the client.<br>
	 * \n<br>
	 * TODO: which values?<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to<br>
	 * move the pointer out of that window).<br>
	 * \n<br>
	 * The special value `XCB_NONE` means don't confine the pointer.<br>
	 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the<br>
	 * cursor.<br>
	 * @param button A bitmask of #xcb_button_index_t values.<br>
	 * @param button \n<br>
	 * @param modifiers The modifiers to grab.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all<br>
	 * possible modifier combinations.<br>
	 * @return A cookie<br>
	 * This request establishes a passive grab. The pointer is actively grabbed as<br>
	 * described in GrabPointer, the last-pointer-grab time is set to the time at<br>
	 * which the button was pressed (as transmitted in the ButtonPress event), and the<br>
	 * ButtonPress event is reported if all of the following conditions are true:<br>
	 * <br>
	 * The pointer is not grabbed and the specified button is logically pressed when<br>
	 * the specified modifier keys are logically down, and no other buttons or<br>
	 * modifier keys are logically down.<br>
	 * <br>
	 * The grab-window contains the pointer.<br>
	 * <br>
	 * The confine-to window (if any) is viewable.<br>
	 * <br>
	 * A passive grab on the same button/key combination does not exist on any<br>
	 * ancestor of grab-window.<br>
	 * <br>
	 * The interpretation of the remaining arguments is the same as for GrabPointer.<br>
	 * The active grab is terminated automatically when the logical state of the<br>
	 * pointer has all buttons released, independent of the logical state of modifier<br>
	 * keys. Note that the logical state of a device (as seen by means of the<br>
	 * protocol) may lag the physical state if device event processing is frozen. This<br>
	 * request overrides all previous passive grabs by the same client on the same<br>
	 * button/key combinations on the same window. A modifier of AnyModifier is<br>
	 * equivalent to issuing the request for all possible modifier combinations<br>
	 * (including the combination of no modifiers). It is not required that all<br>
	 * specified modifiers have currently assigned keycodes. A button of AnyButton is<br>
	 * equivalent to issuing the request for all possible buttons. Otherwise, it is<br>
	 * not required that the button specified currently be assigned to a physical<br>
	 * button.<br>
	 * <br>
	 * An Access error is generated if some other client has already issued a<br>
	 * GrabButton request with the same button/key combination on the same window.<br>
	 * When using AnyModifier or AnyButton, the request fails completely (no grabs are<br>
	 * established), and an Access error is generated if there is a conflicting grab<br>
	 * for any combination. The request has no effect on an active grab.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_button(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, uint8_t, uint8_t, xcb_window_t, xcb_cursor_t, uint8_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7600</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_button(com.sun.jna.ptr.PointerByReference, byte, int, short, byte, byte, int, int, byte, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_grab_button(Pointer c, byte owner_events, int grab_window, short event_mask, byte pointer_mode, byte keyboard_mode, int confine_to, int cursor, byte button, short modifiers);
	/**
	 * @brief Grab pointer button(s)<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param event_mask Specifies which pointer events are reported to the client.<br>
	 * \n<br>
	 * TODO: which values?<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to<br>
	 * move the pointer out of that window).<br>
	 * \n<br>
	 * The special value `XCB_NONE` means don't confine the pointer.<br>
	 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the<br>
	 * cursor.<br>
	 * @param button A bitmask of #xcb_button_index_t values.<br>
	 * @param button \n<br>
	 * @param modifiers The modifiers to grab.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all<br>
	 * possible modifier combinations.<br>
	 * @return A cookie<br>
	 * This request establishes a passive grab. The pointer is actively grabbed as<br>
	 * described in GrabPointer, the last-pointer-grab time is set to the time at<br>
	 * which the button was pressed (as transmitted in the ButtonPress event), and the<br>
	 * ButtonPress event is reported if all of the following conditions are true:<br>
	 * <br>
	 * The pointer is not grabbed and the specified button is logically pressed when<br>
	 * the specified modifier keys are logically down, and no other buttons or<br>
	 * modifier keys are logically down.<br>
	 * <br>
	 * The grab-window contains the pointer.<br>
	 * <br>
	 * The confine-to window (if any) is viewable.<br>
	 * <br>
	 * A passive grab on the same button/key combination does not exist on any<br>
	 * ancestor of grab-window.<br>
	 * <br>
	 * The interpretation of the remaining arguments is the same as for GrabPointer.<br>
	 * The active grab is terminated automatically when the logical state of the<br>
	 * pointer has all buttons released, independent of the logical state of modifier<br>
	 * keys. Note that the logical state of a device (as seen by means of the<br>
	 * protocol) may lag the physical state if device event processing is frozen. This<br>
	 * request overrides all previous passive grabs by the same client on the same<br>
	 * button/key combinations on the same window. A modifier of AnyModifier is<br>
	 * equivalent to issuing the request for all possible modifier combinations<br>
	 * (including the combination of no modifiers). It is not required that all<br>
	 * specified modifiers have currently assigned keycodes. A button of AnyButton is<br>
	 * equivalent to issuing the request for all possible buttons. Otherwise, it is<br>
	 * not required that the button specified currently be assigned to a physical<br>
	 * button.<br>
	 * <br>
	 * An Access error is generated if some other client has already issued a<br>
	 * GrabButton request with the same button/key combination on the same window.<br>
	 * When using AnyModifier or AnyButton, the request fails completely (no grabs are<br>
	 * established), and an Access error is generated if there is a conflicting grab<br>
	 * for any combination. The request has no effect on an active grab.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_button(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, uint8_t, uint8_t, xcb_window_t, xcb_cursor_t, uint8_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7600</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_grab_button(PointerByReference c, byte owner_events, int grab_window, short event_mask, byte pointer_mode, byte keyboard_mode, int confine_to, int cursor, byte button, short modifiers);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_button_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7623</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_button_checked(com.sun.jna.ptr.PointerByReference, byte, int, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_button_checked(Pointer c, byte button, int grab_window, short modifiers);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_button_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7623</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_button_checked(PointerByReference c, byte button, int grab_window, short modifiers);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_button(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7637</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_button(com.sun.jna.ptr.PointerByReference, byte, int, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_button(Pointer c, byte button, int grab_window, short modifiers);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_button(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7637</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_button(PointerByReference c, byte button, int grab_window, short modifiers);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_active_pointer_grab_checked(xcb_connection_t*, xcb_cursor_t, xcb_timestamp_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7654</i><br>
	 * @deprecated use the safer method {@link #xcb_change_active_pointer_grab_checked(com.sun.jna.ptr.PointerByReference, int, int, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_active_pointer_grab_checked(Pointer c, int cursor, int time, short event_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_active_pointer_grab_checked(xcb_connection_t*, xcb_cursor_t, xcb_timestamp_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7654</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_active_pointer_grab_checked(PointerByReference c, int cursor, int time, short event_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_active_pointer_grab(xcb_connection_t*, xcb_cursor_t, xcb_timestamp_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7668</i><br>
	 * @deprecated use the safer method {@link #xcb_change_active_pointer_grab(com.sun.jna.ptr.PointerByReference, int, int, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_active_pointer_grab(Pointer c, int cursor, int time, short event_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_active_pointer_grab(xcb_connection_t*, xcb_cursor_t, xcb_timestamp_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7668</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_active_pointer_grab(PointerByReference c, int cursor, int time, short event_mask);
	/**
	 * @brief Grab the keyboard<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @return A cookie<br>
	 * Actively grabs control of the keyboard and generates FocusIn and FocusOut<br>
	 * events. Further key events are reported only to the grabbing client.<br>
	 * <br>
	 * Any active keyboard grab by this client is overridden. If the keyboard is<br>
	 * actively grabbed by some other client, `AlreadyGrabbed` is returned. If<br>
	 * \a grab_window is not viewable, `GrabNotViewable` is returned. If the keyboard<br>
	 * is frozen by an active grab of another client, `GrabFrozen` is returned. If the<br>
	 * specified \a time is earlier than the last-keyboard-grab time or later than the<br>
	 * current X server time, `GrabInvalidTime` is returned. Otherwise, the<br>
	 * last-keyboard-grab time is set to the specified time.<br>
	 * Original signature : <code>xcb_grab_keyboard_cookie_t xcb_grab_keyboard(xcb_connection_t*, uint8_t, xcb_window_t, xcb_timestamp_t, uint8_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7703</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_keyboard(com.sun.jna.ptr.PointerByReference, byte, int, int, byte, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_grab_keyboard_cookie_t.ByValue xcb_grab_keyboard(Pointer c, byte owner_events, int grab_window, int time, byte pointer_mode, byte keyboard_mode);
	/**
	 * @brief Grab the keyboard<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @return A cookie<br>
	 * Actively grabs control of the keyboard and generates FocusIn and FocusOut<br>
	 * events. Further key events are reported only to the grabbing client.<br>
	 * <br>
	 * Any active keyboard grab by this client is overridden. If the keyboard is<br>
	 * actively grabbed by some other client, `AlreadyGrabbed` is returned. If<br>
	 * \a grab_window is not viewable, `GrabNotViewable` is returned. If the keyboard<br>
	 * is frozen by an active grab of another client, `GrabFrozen` is returned. If the<br>
	 * specified \a time is earlier than the last-keyboard-grab time or later than the<br>
	 * current X server time, `GrabInvalidTime` is returned. Otherwise, the<br>
	 * last-keyboard-grab time is set to the specified time.<br>
	 * Original signature : <code>xcb_grab_keyboard_cookie_t xcb_grab_keyboard(xcb_connection_t*, uint8_t, xcb_window_t, xcb_timestamp_t, uint8_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7703</i>
	 */
	com.yi.ylwm.xcb.xcb_grab_keyboard_cookie_t.ByValue xcb_grab_keyboard(PointerByReference c, byte owner_events, int grab_window, int time, byte pointer_mode, byte keyboard_mode);
	/**
	 * @brief Grab the keyboard<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @return A cookie<br>
	 * Actively grabs control of the keyboard and generates FocusIn and FocusOut<br>
	 * events. Further key events are reported only to the grabbing client.<br>
	 * <br>
	 * Any active keyboard grab by this client is overridden. If the keyboard is<br>
	 * actively grabbed by some other client, `AlreadyGrabbed` is returned. If<br>
	 * \a grab_window is not viewable, `GrabNotViewable` is returned. If the keyboard<br>
	 * is frozen by an active grab of another client, `GrabFrozen` is returned. If the<br>
	 * specified \a time is earlier than the last-keyboard-grab time or later than the<br>
	 * current X server time, `GrabInvalidTime` is returned. Otherwise, the<br>
	 * last-keyboard-grab time is set to the specified time.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_grab_keyboard_cookie_t xcb_grab_keyboard_unchecked(xcb_connection_t*, uint8_t, xcb_window_t, xcb_timestamp_t, uint8_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7743</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_keyboard_unchecked(com.sun.jna.ptr.PointerByReference, byte, int, int, byte, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_grab_keyboard_cookie_t.ByValue xcb_grab_keyboard_unchecked(Pointer c, byte owner_events, int grab_window, int time, byte pointer_mode, byte keyboard_mode);
	/**
	 * @brief Grab the keyboard<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @return A cookie<br>
	 * Actively grabs control of the keyboard and generates FocusIn and FocusOut<br>
	 * events. Further key events are reported only to the grabbing client.<br>
	 * <br>
	 * Any active keyboard grab by this client is overridden. If the keyboard is<br>
	 * actively grabbed by some other client, `AlreadyGrabbed` is returned. If<br>
	 * \a grab_window is not viewable, `GrabNotViewable` is returned. If the keyboard<br>
	 * is frozen by an active grab of another client, `GrabFrozen` is returned. If the<br>
	 * specified \a time is earlier than the last-keyboard-grab time or later than the<br>
	 * current X server time, `GrabInvalidTime` is returned. Otherwise, the<br>
	 * last-keyboard-grab time is set to the specified time.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_grab_keyboard_cookie_t xcb_grab_keyboard_unchecked(xcb_connection_t*, uint8_t, xcb_window_t, xcb_timestamp_t, uint8_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7743</i>
	 */
	com.yi.ylwm.xcb.xcb_grab_keyboard_cookie_t.ByValue xcb_grab_keyboard_unchecked(PointerByReference c, byte owner_events, int grab_window, int time, byte pointer_mode, byte keyboard_mode);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_grab_keyboard_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_grab_keyboard_reply_t* xcb_grab_keyboard_reply(xcb_connection_t*, xcb_grab_keyboard_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7765</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_keyboard_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_grab_keyboard_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_grab_keyboard_reply_t xcb_grab_keyboard_reply(Pointer c, com.yi.ylwm.xcb.xcb_grab_keyboard_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_grab_keyboard_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_grab_keyboard_reply_t* xcb_grab_keyboard_reply(xcb_connection_t*, xcb_grab_keyboard_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7765</i>
	 */
	xcb_grab_keyboard_reply_t xcb_grab_keyboard_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_grab_keyboard_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_keyboard_checked(xcb_connection_t*, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7781</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_keyboard_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_keyboard_checked(Pointer c, int time);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_keyboard_checked(xcb_connection_t*, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7781</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_keyboard_checked(PointerByReference c, int time);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_keyboard(xcb_connection_t*, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7793</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_keyboard(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_keyboard(Pointer c, int time);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_keyboard(xcb_connection_t*, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7793</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_keyboard(PointerByReference c, int time);
	/**
	 * @brief Grab keyboard key(s)<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param modifiers The modifiers to grab.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all<br>
	 * possible modifier combinations.<br>
	 * @param key The keycode of the key to grab.<br>
	 * \n<br>
	 * The special value `XCB_GRAB_ANY` means grab any key.<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @return A cookie<br>
	 * Establishes a passive grab on the keyboard. In the future, the keyboard is<br>
	 * actively grabbed (as for `GrabKeyboard`), the last-keyboard-grab time is set to<br>
	 * the time at which the key was pressed (as transmitted in the KeyPress event),<br>
	 * and the KeyPress event is reported if all of the following conditions are true:<br>
	 * <br>
	 * The keyboard is not grabbed and the specified key (which can itself be a<br>
	 * modifier key) is logically pressed when the specified modifier keys are<br>
	 * logically down, and no other modifier keys are logically down.<br>
	 * <br>
	 * Either the grab_window is an ancestor of (or is) the focus window, or the<br>
	 * grab_window is a descendant of the focus window and contains the pointer.<br>
	 * <br>
	 * A passive grab on the same key combination does not exist on any ancestor of<br>
	 * grab_window.<br>
	 * <br>
	 * The interpretation of the remaining arguments is as for XGrabKeyboard.  The active grab is terminated<br>
	 * automatically when the logical state of the keyboard has the specified key released (independent of the<br>
	 * logical state of the modifier keys), at which point a KeyRelease event is reported to the grabbing window.<br>
	 * <br>
	 * Note that the logical state of a device (as seen by client applications) may lag the physical state if<br>
	 * device event processing is frozen.<br>
	 * <br>
	 * A modifiers argument of AnyModifier is equivalent to issuing the request for all possible modifier combinations (including the combination of no modifiers).  It is not required that all modifiers specified<br>
	 * have currently assigned KeyCodes.  A keycode argument of AnyKey is equivalent to issuing the request for<br>
	 * all possible KeyCodes.  Otherwise, the specified keycode must be in the range specified by min_keycode<br>
	 * and max_keycode in the connection setup, or a BadValue error results.<br>
	 * <br>
	 * If some other client has issued a XGrabKey with the same key combination on the same window, a BadAccess<br>
	 * error results.  When using AnyModifier or AnyKey, the request fails completely, and a BadAccess error<br>
	 * results (no grabs are established) if there is a conflicting grab for any combination.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_key_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, xcb_keycode_t, uint8_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7852</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_key_checked(com.sun.jna.ptr.PointerByReference, byte, int, short, byte, byte, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_grab_key_checked(Pointer c, byte owner_events, int grab_window, short modifiers, byte key, byte pointer_mode, byte keyboard_mode);
	/**
	 * @brief Grab keyboard key(s)<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param modifiers The modifiers to grab.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all<br>
	 * possible modifier combinations.<br>
	 * @param key The keycode of the key to grab.<br>
	 * \n<br>
	 * The special value `XCB_GRAB_ANY` means grab any key.<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @return A cookie<br>
	 * Establishes a passive grab on the keyboard. In the future, the keyboard is<br>
	 * actively grabbed (as for `GrabKeyboard`), the last-keyboard-grab time is set to<br>
	 * the time at which the key was pressed (as transmitted in the KeyPress event),<br>
	 * and the KeyPress event is reported if all of the following conditions are true:<br>
	 * <br>
	 * The keyboard is not grabbed and the specified key (which can itself be a<br>
	 * modifier key) is logically pressed when the specified modifier keys are<br>
	 * logically down, and no other modifier keys are logically down.<br>
	 * <br>
	 * Either the grab_window is an ancestor of (or is) the focus window, or the<br>
	 * grab_window is a descendant of the focus window and contains the pointer.<br>
	 * <br>
	 * A passive grab on the same key combination does not exist on any ancestor of<br>
	 * grab_window.<br>
	 * <br>
	 * The interpretation of the remaining arguments is as for XGrabKeyboard.  The active grab is terminated<br>
	 * automatically when the logical state of the keyboard has the specified key released (independent of the<br>
	 * logical state of the modifier keys), at which point a KeyRelease event is reported to the grabbing window.<br>
	 * <br>
	 * Note that the logical state of a device (as seen by client applications) may lag the physical state if<br>
	 * device event processing is frozen.<br>
	 * <br>
	 * A modifiers argument of AnyModifier is equivalent to issuing the request for all possible modifier combinations (including the combination of no modifiers).  It is not required that all modifiers specified<br>
	 * have currently assigned KeyCodes.  A keycode argument of AnyKey is equivalent to issuing the request for<br>
	 * all possible KeyCodes.  Otherwise, the specified keycode must be in the range specified by min_keycode<br>
	 * and max_keycode in the connection setup, or a BadValue error results.<br>
	 * <br>
	 * If some other client has issued a XGrabKey with the same key combination on the same window, a BadAccess<br>
	 * error results.  When using AnyModifier or AnyKey, the request fails completely, and a BadAccess error<br>
	 * results (no grabs are established) if there is a conflicting grab for any combination.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_key_checked(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, xcb_keycode_t, uint8_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7852</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_grab_key_checked(PointerByReference c, byte owner_events, int grab_window, short modifiers, byte key, byte pointer_mode, byte keyboard_mode);
	/**
	 * @brief Grab keyboard key(s)<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param modifiers The modifiers to grab.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all<br>
	 * possible modifier combinations.<br>
	 * @param key The keycode of the key to grab.<br>
	 * \n<br>
	 * The special value `XCB_GRAB_ANY` means grab any key.<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @return A cookie<br>
	 * Establishes a passive grab on the keyboard. In the future, the keyboard is<br>
	 * actively grabbed (as for `GrabKeyboard`), the last-keyboard-grab time is set to<br>
	 * the time at which the key was pressed (as transmitted in the KeyPress event),<br>
	 * and the KeyPress event is reported if all of the following conditions are true:<br>
	 * <br>
	 * The keyboard is not grabbed and the specified key (which can itself be a<br>
	 * modifier key) is logically pressed when the specified modifier keys are<br>
	 * logically down, and no other modifier keys are logically down.<br>
	 * <br>
	 * Either the grab_window is an ancestor of (or is) the focus window, or the<br>
	 * grab_window is a descendant of the focus window and contains the pointer.<br>
	 * <br>
	 * A passive grab on the same key combination does not exist on any ancestor of<br>
	 * grab_window.<br>
	 * <br>
	 * The interpretation of the remaining arguments is as for XGrabKeyboard.  The active grab is terminated<br>
	 * automatically when the logical state of the keyboard has the specified key released (independent of the<br>
	 * logical state of the modifier keys), at which point a KeyRelease event is reported to the grabbing window.<br>
	 * <br>
	 * Note that the logical state of a device (as seen by client applications) may lag the physical state if<br>
	 * device event processing is frozen.<br>
	 * <br>
	 * A modifiers argument of AnyModifier is equivalent to issuing the request for all possible modifier combinations (including the combination of no modifiers).  It is not required that all modifiers specified<br>
	 * have currently assigned KeyCodes.  A keycode argument of AnyKey is equivalent to issuing the request for<br>
	 * all possible KeyCodes.  Otherwise, the specified keycode must be in the range specified by min_keycode<br>
	 * and max_keycode in the connection setup, or a BadValue error results.<br>
	 * <br>
	 * If some other client has issued a XGrabKey with the same key combination on the same window, a BadAccess<br>
	 * error results.  When using AnyModifier or AnyKey, the request fails completely, and a BadAccess error<br>
	 * results (no grabs are established) if there is a conflicting grab for any combination.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_key(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, xcb_keycode_t, uint8_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7913</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_key(com.sun.jna.ptr.PointerByReference, byte, int, short, byte, byte, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_grab_key(Pointer c, byte owner_events, int grab_window, short modifiers, byte key, byte pointer_mode, byte keyboard_mode);
	/**
	 * @brief Grab keyboard key(s)<br>
	 * @param c The connection<br>
	 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not<br>
	 * reported to the \a grab_window.<br>
	 * @param grab_window Specifies the window on which the pointer should be grabbed.<br>
	 * @param modifiers The modifiers to grab.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all<br>
	 * possible modifier combinations.<br>
	 * @param key The keycode of the key to grab.<br>
	 * \n<br>
	 * The special value `XCB_GRAB_ANY` means grab any key.<br>
	 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param pointer_mode \n<br>
	 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.<br>
	 * @param keyboard_mode \n<br>
	 * @return A cookie<br>
	 * Establishes a passive grab on the keyboard. In the future, the keyboard is<br>
	 * actively grabbed (as for `GrabKeyboard`), the last-keyboard-grab time is set to<br>
	 * the time at which the key was pressed (as transmitted in the KeyPress event),<br>
	 * and the KeyPress event is reported if all of the following conditions are true:<br>
	 * <br>
	 * The keyboard is not grabbed and the specified key (which can itself be a<br>
	 * modifier key) is logically pressed when the specified modifier keys are<br>
	 * logically down, and no other modifier keys are logically down.<br>
	 * <br>
	 * Either the grab_window is an ancestor of (or is) the focus window, or the<br>
	 * grab_window is a descendant of the focus window and contains the pointer.<br>
	 * <br>
	 * A passive grab on the same key combination does not exist on any ancestor of<br>
	 * grab_window.<br>
	 * <br>
	 * The interpretation of the remaining arguments is as for XGrabKeyboard.  The active grab is terminated<br>
	 * automatically when the logical state of the keyboard has the specified key released (independent of the<br>
	 * logical state of the modifier keys), at which point a KeyRelease event is reported to the grabbing window.<br>
	 * <br>
	 * Note that the logical state of a device (as seen by client applications) may lag the physical state if<br>
	 * device event processing is frozen.<br>
	 * <br>
	 * A modifiers argument of AnyModifier is equivalent to issuing the request for all possible modifier combinations (including the combination of no modifiers).  It is not required that all modifiers specified<br>
	 * have currently assigned KeyCodes.  A keycode argument of AnyKey is equivalent to issuing the request for<br>
	 * all possible KeyCodes.  Otherwise, the specified keycode must be in the range specified by min_keycode<br>
	 * and max_keycode in the connection setup, or a BadValue error results.<br>
	 * <br>
	 * If some other client has issued a XGrabKey with the same key combination on the same window, a BadAccess<br>
	 * error results.  When using AnyModifier or AnyKey, the request fails completely, and a BadAccess error<br>
	 * results (no grabs are established) if there is a conflicting grab for any combination.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_key(xcb_connection_t*, uint8_t, xcb_window_t, uint16_t, xcb_keycode_t, uint8_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7913</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_grab_key(PointerByReference c, byte owner_events, int grab_window, short modifiers, byte key, byte pointer_mode, byte keyboard_mode);
	/**
	 * @brief release a key combination<br>
	 * @param c The connection<br>
	 * @param key The keycode of the specified key combination.<br>
	 * \n<br>
	 * Using the special value `XCB_GRAB_ANY` means releasing all possible key codes.<br>
	 * @param grab_window The window on which the grabbed key combination will be released.<br>
	 * @param modifiers The modifiers of the specified key combination.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means releasing the key combination<br>
	 * with every possible modifier combination.<br>
	 * @return A cookie<br>
	 * Releases the key combination on \a grab_window if you grabbed it using<br>
	 * `xcb_grab_key` before.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_key_checked(xcb_connection_t*, xcb_keycode_t, xcb_window_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7943</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_key_checked(com.sun.jna.ptr.PointerByReference, byte, int, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_key_checked(Pointer c, byte key, int grab_window, short modifiers);
	/**
	 * @brief release a key combination<br>
	 * @param c The connection<br>
	 * @param key The keycode of the specified key combination.<br>
	 * \n<br>
	 * Using the special value `XCB_GRAB_ANY` means releasing all possible key codes.<br>
	 * @param grab_window The window on which the grabbed key combination will be released.<br>
	 * @param modifiers The modifiers of the specified key combination.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means releasing the key combination<br>
	 * with every possible modifier combination.<br>
	 * @return A cookie<br>
	 * Releases the key combination on \a grab_window if you grabbed it using<br>
	 * `xcb_grab_key` before.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_key_checked(xcb_connection_t*, xcb_keycode_t, xcb_window_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7943</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_key_checked(PointerByReference c, byte key, int grab_window, short modifiers);
	/**
	 * @brief release a key combination<br>
	 * @param c The connection<br>
	 * @param key The keycode of the specified key combination.<br>
	 * \n<br>
	 * Using the special value `XCB_GRAB_ANY` means releasing all possible key codes.<br>
	 * @param grab_window The window on which the grabbed key combination will be released.<br>
	 * @param modifiers The modifiers of the specified key combination.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means releasing the key combination<br>
	 * with every possible modifier combination.<br>
	 * @return A cookie<br>
	 * Releases the key combination on \a grab_window if you grabbed it using<br>
	 * `xcb_grab_key` before.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_key(xcb_connection_t*, xcb_keycode_t, xcb_window_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7967</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_key(com.sun.jna.ptr.PointerByReference, byte, int, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_key(Pointer c, byte key, int grab_window, short modifiers);
	/**
	 * @brief release a key combination<br>
	 * @param c The connection<br>
	 * @param key The keycode of the specified key combination.<br>
	 * \n<br>
	 * Using the special value `XCB_GRAB_ANY` means releasing all possible key codes.<br>
	 * @param grab_window The window on which the grabbed key combination will be released.<br>
	 * @param modifiers The modifiers of the specified key combination.<br>
	 * \n<br>
	 * Using the special value `XCB_MOD_MASK_ANY` means releasing the key combination<br>
	 * with every possible modifier combination.<br>
	 * @return A cookie<br>
	 * Releases the key combination on \a grab_window if you grabbed it using<br>
	 * `xcb_grab_key` before.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_key(xcb_connection_t*, xcb_keycode_t, xcb_window_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7967</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_key(PointerByReference c, byte key, int grab_window, short modifiers);
	/**
	 * @brief release queued events<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_allow_t values.<br>
	 * @param mode \n<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Releases queued events if the client has caused a device (pointer/keyboard) to<br>
	 * freeze due to grabbing it actively. This request has no effect if \a time is<br>
	 * earlier than the last-grab time of the most recent active grab for this client<br>
	 * or if \a time is later than the current X server time.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_allow_events_checked(xcb_connection_t*, uint8_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7994</i><br>
	 * @deprecated use the safer method {@link #xcb_allow_events_checked(com.sun.jna.ptr.PointerByReference, byte, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_allow_events_checked(Pointer c, byte mode, int time);
	/**
	 * @brief release queued events<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_allow_t values.<br>
	 * @param mode \n<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Releases queued events if the client has caused a device (pointer/keyboard) to<br>
	 * freeze due to grabbing it actively. This request has no effect if \a time is<br>
	 * earlier than the last-grab time of the most recent active grab for this client<br>
	 * or if \a time is later than the current X server time.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_allow_events_checked(xcb_connection_t*, uint8_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:7994</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_allow_events_checked(PointerByReference c, byte mode, int time);
	/**
	 * @brief release queued events<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_allow_t values.<br>
	 * @param mode \n<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Releases queued events if the client has caused a device (pointer/keyboard) to<br>
	 * freeze due to grabbing it actively. This request has no effect if \a time is<br>
	 * earlier than the last-grab time of the most recent active grab for this client<br>
	 * or if \a time is later than the current X server time.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_allow_events(xcb_connection_t*, uint8_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8017</i><br>
	 * @deprecated use the safer method {@link #xcb_allow_events(com.sun.jna.ptr.PointerByReference, byte, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_allow_events(Pointer c, byte mode, int time);
	/**
	 * @brief release queued events<br>
	 * @param c The connection<br>
	 * @param mode A bitmask of #xcb_allow_t values.<br>
	 * @param mode \n<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Releases queued events if the client has caused a device (pointer/keyboard) to<br>
	 * freeze due to grabbing it actively. This request has no effect if \a time is<br>
	 * earlier than the last-grab time of the most recent active grab for this client<br>
	 * or if \a time is later than the current X server time.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_allow_events(xcb_connection_t*, uint8_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8017</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_allow_events(PointerByReference c, byte mode, int time);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_server_checked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8033</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_server_checked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_grab_server_checked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_server_checked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8033</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_grab_server_checked(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_server(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8044</i><br>
	 * @deprecated use the safer method {@link #xcb_grab_server(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_grab_server(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_grab_server(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8044</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_grab_server(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_server_checked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8058</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_server_checked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_server_checked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_server_checked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8058</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_server_checked(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_server(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8069</i><br>
	 * @deprecated use the safer method {@link #xcb_ungrab_server(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_server(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_ungrab_server(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8069</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_ungrab_server(PointerByReference c);
	/**
	 * @brief get pointer coordinates<br>
	 * @param c The connection<br>
	 * @param window A window to check if the pointer is on the same screen as \a window (see the<br>
	 * `same_screen` field in the reply).<br>
	 * @return A cookie<br>
	 * Gets the root window the pointer is logically on and the pointer coordinates<br>
	 * relative to the root window's origin.<br>
	 * Original signature : <code>xcb_query_pointer_cookie_t xcb_query_pointer(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8084</i><br>
	 * @deprecated use the safer method {@link #xcb_query_pointer(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_query_pointer_cookie_t.ByValue xcb_query_pointer(Pointer c, int window);
	/**
	 * @brief get pointer coordinates<br>
	 * @param c The connection<br>
	 * @param window A window to check if the pointer is on the same screen as \a window (see the<br>
	 * `same_screen` field in the reply).<br>
	 * @return A cookie<br>
	 * Gets the root window the pointer is logically on and the pointer coordinates<br>
	 * relative to the root window's origin.<br>
	 * Original signature : <code>xcb_query_pointer_cookie_t xcb_query_pointer(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8084</i>
	 */
	com.yi.ylwm.xcb.xcb_query_pointer_cookie_t.ByValue xcb_query_pointer(PointerByReference c, int window);
	/**
	 * @brief get pointer coordinates<br>
	 * @param c The connection<br>
	 * @param window A window to check if the pointer is on the same screen as \a window (see the<br>
	 * `same_screen` field in the reply).<br>
	 * @return A cookie<br>
	 * Gets the root window the pointer is logically on and the pointer coordinates<br>
	 * relative to the root window's origin.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_pointer_cookie_t xcb_query_pointer_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8103</i><br>
	 * @deprecated use the safer method {@link #xcb_query_pointer_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_query_pointer_cookie_t.ByValue xcb_query_pointer_unchecked(Pointer c, int window);
	/**
	 * @brief get pointer coordinates<br>
	 * @param c The connection<br>
	 * @param window A window to check if the pointer is on the same screen as \a window (see the<br>
	 * `same_screen` field in the reply).<br>
	 * @return A cookie<br>
	 * Gets the root window the pointer is logically on and the pointer coordinates<br>
	 * relative to the root window's origin.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_pointer_cookie_t xcb_query_pointer_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8103</i>
	 */
	com.yi.ylwm.xcb.xcb_query_pointer_cookie_t.ByValue xcb_query_pointer_unchecked(PointerByReference c, int window);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_pointer_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_pointer_reply_t* xcb_query_pointer_reply(xcb_connection_t*, xcb_query_pointer_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8121</i><br>
	 * @deprecated use the safer method {@link #xcb_query_pointer_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_query_pointer_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_query_pointer_reply_t xcb_query_pointer_reply(Pointer c, com.yi.ylwm.xcb.xcb_query_pointer_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_pointer_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_pointer_reply_t* xcb_query_pointer_reply(xcb_connection_t*, xcb_query_pointer_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8121</i>
	 */
	xcb_query_pointer_reply_t xcb_query_pointer_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_query_pointer_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_timecoord_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_timecoord_t)<br>
	 * Original signature : <code>void xcb_timecoord_next(xcb_timecoord_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8134</i>
	 */
	void xcb_timecoord_next(xcb_timecoord_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_timecoord_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_timecoord_end(xcb_timecoord_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8146</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_timecoord_end(xcb_timecoord_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_get_motion_events_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8149</i>
	 */
	int xcb_get_motion_events_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_motion_events_cookie_t xcb_get_motion_events(xcb_connection_t*, xcb_window_t, xcb_timestamp_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8160</i><br>
	 * @deprecated use the safer method {@link #xcb_get_motion_events(com.sun.jna.ptr.PointerByReference, int, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_motion_events_cookie_t.ByValue xcb_get_motion_events(Pointer c, int window, int start, int stop);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_motion_events_cookie_t xcb_get_motion_events(xcb_connection_t*, xcb_window_t, xcb_timestamp_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8160</i>
	 */
	com.yi.ylwm.xcb.xcb_get_motion_events_cookie_t.ByValue xcb_get_motion_events(PointerByReference c, int window, int start, int stop);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_motion_events_cookie_t xcb_get_motion_events_unchecked(xcb_connection_t*, xcb_window_t, xcb_timestamp_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8177</i><br>
	 * @deprecated use the safer method {@link #xcb_get_motion_events_unchecked(com.sun.jna.ptr.PointerByReference, int, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_motion_events_cookie_t.ByValue xcb_get_motion_events_unchecked(Pointer c, int window, int start, int stop);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_motion_events_cookie_t xcb_get_motion_events_unchecked(xcb_connection_t*, xcb_window_t, xcb_timestamp_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8177</i>
	 */
	com.yi.ylwm.xcb.xcb_get_motion_events_cookie_t.ByValue xcb_get_motion_events_unchecked(PointerByReference c, int window, int start, int stop);
	/**
	 * Original signature : <code>xcb_timecoord_t* xcb_get_motion_events_events(const xcb_get_motion_events_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8183</i>
	 */
	xcb_timecoord_t xcb_get_motion_events_events(xcb_get_motion_events_reply_t R);
	/**
	 * Original signature : <code>int xcb_get_motion_events_events_length(const xcb_get_motion_events_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8186</i>
	 */
	int xcb_get_motion_events_events_length(xcb_get_motion_events_reply_t R);
	/**
	 * Original signature : <code>xcb_timecoord_iterator_t xcb_get_motion_events_events_iterator(const xcb_get_motion_events_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8189</i>
	 */
	xcb_timecoord_iterator_t.ByValue xcb_get_motion_events_events_iterator(xcb_get_motion_events_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_motion_events_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_motion_events_reply_t* xcb_get_motion_events_reply(xcb_connection_t*, xcb_get_motion_events_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8206</i><br>
	 * @deprecated use the safer method {@link #xcb_get_motion_events_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_get_motion_events_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_motion_events_reply_t xcb_get_motion_events_reply(Pointer c, com.yi.ylwm.xcb.xcb_get_motion_events_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_motion_events_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_motion_events_reply_t* xcb_get_motion_events_reply(xcb_connection_t*, xcb_get_motion_events_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8206</i>
	 */
	xcb_get_motion_events_reply_t xcb_get_motion_events_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_get_motion_events_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_translate_coordinates_cookie_t xcb_translate_coordinates(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8219</i><br>
	 * @deprecated use the safer method {@link #xcb_translate_coordinates(com.sun.jna.ptr.PointerByReference, int, int, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_translate_coordinates_cookie_t.ByValue xcb_translate_coordinates(Pointer c, int src_window, int dst_window, short src_x, short src_y);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_translate_coordinates_cookie_t xcb_translate_coordinates(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8219</i>
	 */
	com.yi.ylwm.xcb.xcb_translate_coordinates_cookie_t.ByValue xcb_translate_coordinates(PointerByReference c, int src_window, int dst_window, short src_x, short src_y);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_translate_coordinates_cookie_t xcb_translate_coordinates_unchecked(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8237</i><br>
	 * @deprecated use the safer method {@link #xcb_translate_coordinates_unchecked(com.sun.jna.ptr.PointerByReference, int, int, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_translate_coordinates_cookie_t.ByValue xcb_translate_coordinates_unchecked(Pointer c, int src_window, int dst_window, short src_x, short src_y);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_translate_coordinates_cookie_t xcb_translate_coordinates_unchecked(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8237</i>
	 */
	com.yi.ylwm.xcb.xcb_translate_coordinates_cookie_t.ByValue xcb_translate_coordinates_unchecked(PointerByReference c, int src_window, int dst_window, short src_x, short src_y);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_translate_coordinates_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_translate_coordinates_reply_t* xcb_translate_coordinates_reply(xcb_connection_t*, xcb_translate_coordinates_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8258</i><br>
	 * @deprecated use the safer method {@link #xcb_translate_coordinates_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_translate_coordinates_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_translate_coordinates_reply_t xcb_translate_coordinates_reply(Pointer c, com.yi.ylwm.xcb.xcb_translate_coordinates_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_translate_coordinates_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_translate_coordinates_reply_t* xcb_translate_coordinates_reply(xcb_connection_t*, xcb_translate_coordinates_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8258</i>
	 */
	xcb_translate_coordinates_reply_t xcb_translate_coordinates_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_translate_coordinates_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * @brief move mouse pointer<br>
	 * @param c The connection<br>
	 * @param src_window If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the<br>
	 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,<br>
	 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to<br>
	 * \a src_window.<br>
	 * @param dst_window If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the<br>
	 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is<br>
	 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)<br>
	 * relative to the current position of the pointer.<br>
	 * @return A cookie<br>
	 * Moves the mouse pointer to the specified position.<br>
	 * <br>
	 * If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the<br>
	 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,<br>
	 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to<br>
	 * \a src_window.<br>
	 * <br>
	 * If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the<br>
	 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is<br>
	 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)<br>
	 * relative to the current position of the pointer.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_warp_pointer_checked(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, int16_t, int16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8293</i><br>
	 * @deprecated use the safer method {@link #xcb_warp_pointer_checked(com.sun.jna.ptr.PointerByReference, int, int, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_warp_pointer_checked(Pointer c, int src_window, int dst_window, short src_x, short src_y, short src_width, short src_height, short dst_x, short dst_y);
	/**
	 * @brief move mouse pointer<br>
	 * @param c The connection<br>
	 * @param src_window If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the<br>
	 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,<br>
	 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to<br>
	 * \a src_window.<br>
	 * @param dst_window If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the<br>
	 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is<br>
	 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)<br>
	 * relative to the current position of the pointer.<br>
	 * @return A cookie<br>
	 * Moves the mouse pointer to the specified position.<br>
	 * <br>
	 * If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the<br>
	 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,<br>
	 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to<br>
	 * \a src_window.<br>
	 * <br>
	 * If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the<br>
	 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is<br>
	 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)<br>
	 * relative to the current position of the pointer.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_warp_pointer_checked(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, int16_t, int16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8293</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_warp_pointer_checked(PointerByReference c, int src_window, int dst_window, short src_x, short src_y, short src_width, short src_height, short dst_x, short dst_y);
	/**
	 * @brief move mouse pointer<br>
	 * @param c The connection<br>
	 * @param src_window If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the<br>
	 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,<br>
	 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to<br>
	 * \a src_window.<br>
	 * @param dst_window If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the<br>
	 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is<br>
	 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)<br>
	 * relative to the current position of the pointer.<br>
	 * @return A cookie<br>
	 * Moves the mouse pointer to the specified position.<br>
	 * <br>
	 * If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the<br>
	 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,<br>
	 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to<br>
	 * \a src_window.<br>
	 * <br>
	 * If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the<br>
	 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is<br>
	 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)<br>
	 * relative to the current position of the pointer.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_warp_pointer(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, int16_t, int16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8331</i><br>
	 * @deprecated use the safer method {@link #xcb_warp_pointer(com.sun.jna.ptr.PointerByReference, int, int, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_warp_pointer(Pointer c, int src_window, int dst_window, short src_x, short src_y, short src_width, short src_height, short dst_x, short dst_y);
	/**
	 * @brief move mouse pointer<br>
	 * @param c The connection<br>
	 * @param src_window If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the<br>
	 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,<br>
	 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to<br>
	 * \a src_window.<br>
	 * @param dst_window If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the<br>
	 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is<br>
	 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)<br>
	 * relative to the current position of the pointer.<br>
	 * @return A cookie<br>
	 * Moves the mouse pointer to the specified position.<br>
	 * <br>
	 * If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the<br>
	 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,<br>
	 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to<br>
	 * \a src_window.<br>
	 * <br>
	 * If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the<br>
	 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is<br>
	 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)<br>
	 * relative to the current position of the pointer.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_warp_pointer(xcb_connection_t*, xcb_window_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t, int16_t, int16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8331</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_warp_pointer(PointerByReference c, int src_window, int dst_window, short src_x, short src_y, short src_width, short src_height, short dst_x, short dst_y);
	/**
	 * @brief Sets input focus<br>
	 * @param c The connection<br>
	 * @param revert_to A bitmask of #xcb_input_focus_t values.<br>
	 * @param revert_to Specifies what happens when the \a focus window becomes unviewable (if \a focus<br>
	 * is neither `XCB_NONE` nor `XCB_POINTER_ROOT`).<br>
	 * @param focus The window to focus. All keyboard events will be reported to this window. The<br>
	 * window must be viewable (TODO), or a `xcb_match_error_t` occurs (TODO).<br>
	 * \n<br>
	 * If \a focus is `XCB_NONE` (TODO), all keyboard events are<br>
	 * discarded until a new focus window is set.<br>
	 * \n<br>
	 * If \a focus is `XCB_POINTER_ROOT` (TODO), focus is on the root window of the<br>
	 * screen on which the pointer is on currently.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Changes the input focus and the last-focus-change time. If the specified \a time<br>
	 * is earlier than the current last-focus-change time, the request is ignored (to<br>
	 * avoid race conditions when running X over the network).<br>
	 * <br>
	 * A FocusIn and FocusOut event is generated when focus is changed.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_input_focus_checked(xcb_connection_t*, uint8_t, xcb_window_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8373</i><br>
	 * @deprecated use the safer method {@link #xcb_set_input_focus_checked(com.sun.jna.ptr.PointerByReference, byte, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_input_focus_checked(Pointer c, byte revert_to, int focus, int time);
	/**
	 * @brief Sets input focus<br>
	 * @param c The connection<br>
	 * @param revert_to A bitmask of #xcb_input_focus_t values.<br>
	 * @param revert_to Specifies what happens when the \a focus window becomes unviewable (if \a focus<br>
	 * is neither `XCB_NONE` nor `XCB_POINTER_ROOT`).<br>
	 * @param focus The window to focus. All keyboard events will be reported to this window. The<br>
	 * window must be viewable (TODO), or a `xcb_match_error_t` occurs (TODO).<br>
	 * \n<br>
	 * If \a focus is `XCB_NONE` (TODO), all keyboard events are<br>
	 * discarded until a new focus window is set.<br>
	 * \n<br>
	 * If \a focus is `XCB_POINTER_ROOT` (TODO), focus is on the root window of the<br>
	 * screen on which the pointer is on currently.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Changes the input focus and the last-focus-change time. If the specified \a time<br>
	 * is earlier than the current last-focus-change time, the request is ignored (to<br>
	 * avoid race conditions when running X over the network).<br>
	 * <br>
	 * A FocusIn and FocusOut event is generated when focus is changed.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_input_focus_checked(xcb_connection_t*, uint8_t, xcb_window_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8373</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_input_focus_checked(PointerByReference c, byte revert_to, int focus, int time);
	/**
	 * @brief Sets input focus<br>
	 * @param c The connection<br>
	 * @param revert_to A bitmask of #xcb_input_focus_t values.<br>
	 * @param revert_to Specifies what happens when the \a focus window becomes unviewable (if \a focus<br>
	 * is neither `XCB_NONE` nor `XCB_POINTER_ROOT`).<br>
	 * @param focus The window to focus. All keyboard events will be reported to this window. The<br>
	 * window must be viewable (TODO), or a `xcb_match_error_t` occurs (TODO).<br>
	 * \n<br>
	 * If \a focus is `XCB_NONE` (TODO), all keyboard events are<br>
	 * discarded until a new focus window is set.<br>
	 * \n<br>
	 * If \a focus is `XCB_POINTER_ROOT` (TODO), focus is on the root window of the<br>
	 * screen on which the pointer is on currently.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Changes the input focus and the last-focus-change time. If the specified \a time<br>
	 * is earlier than the current last-focus-change time, the request is ignored (to<br>
	 * avoid race conditions when running X over the network).<br>
	 * <br>
	 * A FocusIn and FocusOut event is generated when focus is changed.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_input_focus(xcb_connection_t*, uint8_t, xcb_window_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8407</i><br>
	 * @deprecated use the safer method {@link #xcb_set_input_focus(com.sun.jna.ptr.PointerByReference, byte, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_input_focus(Pointer c, byte revert_to, int focus, int time);
	/**
	 * @brief Sets input focus<br>
	 * @param c The connection<br>
	 * @param revert_to A bitmask of #xcb_input_focus_t values.<br>
	 * @param revert_to Specifies what happens when the \a focus window becomes unviewable (if \a focus<br>
	 * is neither `XCB_NONE` nor `XCB_POINTER_ROOT`).<br>
	 * @param focus The window to focus. All keyboard events will be reported to this window. The<br>
	 * window must be viewable (TODO), or a `xcb_match_error_t` occurs (TODO).<br>
	 * \n<br>
	 * If \a focus is `XCB_NONE` (TODO), all keyboard events are<br>
	 * discarded until a new focus window is set.<br>
	 * \n<br>
	 * If \a focus is `XCB_POINTER_ROOT` (TODO), focus is on the root window of the<br>
	 * screen on which the pointer is on currently.<br>
	 * @param time Timestamp to avoid race conditions when running X over the network.<br>
	 * \n<br>
	 * The special value `XCB_CURRENT_TIME` will be replaced with the current server<br>
	 * time.<br>
	 * @return A cookie<br>
	 * Changes the input focus and the last-focus-change time. If the specified \a time<br>
	 * is earlier than the current last-focus-change time, the request is ignored (to<br>
	 * avoid race conditions when running X over the network).<br>
	 * <br>
	 * A FocusIn and FocusOut event is generated when focus is changed.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_input_focus(xcb_connection_t*, uint8_t, xcb_window_t, xcb_timestamp_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8407</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_input_focus(PointerByReference c, byte revert_to, int focus, int time);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_input_focus_cookie_t xcb_get_input_focus(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8421</i><br>
	 * @deprecated use the safer method {@link #xcb_get_input_focus(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_input_focus_cookie_t.ByValue xcb_get_input_focus(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_input_focus_cookie_t xcb_get_input_focus(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8421</i>
	 */
	com.yi.ylwm.xcb.xcb_get_input_focus_cookie_t.ByValue xcb_get_input_focus(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_input_focus_cookie_t xcb_get_input_focus_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8435</i><br>
	 * @deprecated use the safer method {@link #xcb_get_input_focus_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_input_focus_cookie_t.ByValue xcb_get_input_focus_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_input_focus_cookie_t xcb_get_input_focus_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8435</i>
	 */
	com.yi.ylwm.xcb.xcb_get_input_focus_cookie_t.ByValue xcb_get_input_focus_unchecked(PointerByReference c);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_input_focus_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_input_focus_reply_t* xcb_get_input_focus_reply(xcb_connection_t*, xcb_get_input_focus_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8452</i><br>
	 * @deprecated use the safer method {@link #xcb_get_input_focus_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_get_input_focus_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_input_focus_reply_t xcb_get_input_focus_reply(Pointer c, com.yi.ylwm.xcb.xcb_get_input_focus_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_input_focus_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_input_focus_reply_t* xcb_get_input_focus_reply(xcb_connection_t*, xcb_get_input_focus_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8452</i>
	 */
	xcb_get_input_focus_reply_t xcb_get_input_focus_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_get_input_focus_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_query_keymap_cookie_t xcb_query_keymap(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8465</i><br>
	 * @deprecated use the safer method {@link #xcb_query_keymap(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_query_keymap_cookie_t.ByValue xcb_query_keymap(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_query_keymap_cookie_t xcb_query_keymap(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8465</i>
	 */
	com.yi.ylwm.xcb.xcb_query_keymap_cookie_t.ByValue xcb_query_keymap(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_keymap_cookie_t xcb_query_keymap_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8479</i><br>
	 * @deprecated use the safer method {@link #xcb_query_keymap_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_query_keymap_cookie_t.ByValue xcb_query_keymap_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_keymap_cookie_t xcb_query_keymap_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8479</i>
	 */
	com.yi.ylwm.xcb.xcb_query_keymap_cookie_t.ByValue xcb_query_keymap_unchecked(PointerByReference c);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_keymap_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_keymap_reply_t* xcb_query_keymap_reply(xcb_connection_t*, xcb_query_keymap_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8496</i><br>
	 * @deprecated use the safer method {@link #xcb_query_keymap_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_query_keymap_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_query_keymap_reply_t xcb_query_keymap_reply(Pointer c, com.yi.ylwm.xcb.xcb_query_keymap_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_keymap_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_keymap_reply_t* xcb_query_keymap_reply(xcb_connection_t*, xcb_query_keymap_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8496</i>
	 */
	xcb_query_keymap_reply_t xcb_query_keymap_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_query_keymap_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_open_font_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8501</i>
	 */
	int xcb_open_font_sizeof(Pointer _buffer);
	/**
	 * @brief opens a font<br>
	 * @param c The connection<br>
	 * @param fid The ID with which you will refer to the font, created by `xcb_generate_id`.<br>
	 * @param name_len Length (in bytes) of \a name.<br>
	 * @param name A pattern describing an X core font.<br>
	 * @return A cookie<br>
	 * Opens any X core font matching the given \a name (for example "-misc-fixed-*").<br>
	 * <br>
	 * Note that X core fonts are deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_open_font_checked(xcb_connection_t*, xcb_font_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8522</i><br>
	 * @deprecated use the safer methods {@link #xcb_open_font_checked(com.sun.jna.ptr.PointerByReference, int, short, java.lang.String)} and {@link #xcb_open_font_checked(com.sun.jna.ptr.PointerByReference, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_open_font_checked(Pointer c, int fid, short name_len, Pointer name);
	/**
	 * @brief opens a font<br>
	 * @param c The connection<br>
	 * @param fid The ID with which you will refer to the font, created by `xcb_generate_id`.<br>
	 * @param name_len Length (in bytes) of \a name.<br>
	 * @param name A pattern describing an X core font.<br>
	 * @return A cookie<br>
	 * Opens any X core font matching the given \a name (for example "-misc-fixed-*").<br>
	 * <br>
	 * Note that X core fonts are deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_open_font_checked(xcb_connection_t*, xcb_font_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8522</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_open_font_checked(PointerByReference c, int fid, short name_len, String name);
	/**
	 * @brief opens a font<br>
	 * @param c The connection<br>
	 * @param fid The ID with which you will refer to the font, created by `xcb_generate_id`.<br>
	 * @param name_len Length (in bytes) of \a name.<br>
	 * @param name A pattern describing an X core font.<br>
	 * @return A cookie<br>
	 * Opens any X core font matching the given \a name (for example "-misc-fixed-*").<br>
	 * <br>
	 * Note that X core fonts are deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_open_font_checked(xcb_connection_t*, xcb_font_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8522</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_open_font_checked(PointerByReference c, int fid, short name_len, Pointer name);
	/**
	 * @brief opens a font<br>
	 * @param c The connection<br>
	 * @param fid The ID with which you will refer to the font, created by `xcb_generate_id`.<br>
	 * @param name_len Length (in bytes) of \a name.<br>
	 * @param name A pattern describing an X core font.<br>
	 * @return A cookie<br>
	 * Opens any X core font matching the given \a name (for example "-misc-fixed-*").<br>
	 * <br>
	 * Note that X core fonts are deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_open_font(xcb_connection_t*, xcb_font_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8543</i><br>
	 * @deprecated use the safer methods {@link #xcb_open_font(com.sun.jna.ptr.PointerByReference, int, short, java.lang.String)} and {@link #xcb_open_font(com.sun.jna.ptr.PointerByReference, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_open_font(Pointer c, int fid, short name_len, Pointer name);
	/**
	 * @brief opens a font<br>
	 * @param c The connection<br>
	 * @param fid The ID with which you will refer to the font, created by `xcb_generate_id`.<br>
	 * @param name_len Length (in bytes) of \a name.<br>
	 * @param name A pattern describing an X core font.<br>
	 * @return A cookie<br>
	 * Opens any X core font matching the given \a name (for example "-misc-fixed-*").<br>
	 * <br>
	 * Note that X core fonts are deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_open_font(xcb_connection_t*, xcb_font_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8543</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_open_font(PointerByReference c, int fid, short name_len, String name);
	/**
	 * @brief opens a font<br>
	 * @param c The connection<br>
	 * @param fid The ID with which you will refer to the font, created by `xcb_generate_id`.<br>
	 * @param name_len Length (in bytes) of \a name.<br>
	 * @param name A pattern describing an X core font.<br>
	 * @return A cookie<br>
	 * Opens any X core font matching the given \a name (for example "-misc-fixed-*").<br>
	 * <br>
	 * Note that X core fonts are deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_open_font(xcb_connection_t*, xcb_font_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8543</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_open_font(PointerByReference c, int fid, short name_len, Pointer name);
	/**
	 * Original signature : <code>char* xcb_open_font_name(const xcb_open_font_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8549</i>
	 */
	Pointer xcb_open_font_name(xcb_open_font_request_t R);
	/**
	 * Original signature : <code>int xcb_open_font_name_length(const xcb_open_font_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8552</i>
	 */
	int xcb_open_font_name_length(xcb_open_font_request_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_open_font_name_end(const xcb_open_font_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8555</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_open_font_name_end(xcb_open_font_request_t R);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_close_font_checked(xcb_connection_t*, xcb_font_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8569</i><br>
	 * @deprecated use the safer method {@link #xcb_close_font_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_close_font_checked(Pointer c, int font);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_close_font_checked(xcb_connection_t*, xcb_font_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8569</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_close_font_checked(PointerByReference c, int font);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_close_font(xcb_connection_t*, xcb_font_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8581</i><br>
	 * @deprecated use the safer method {@link #xcb_close_font(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_close_font(Pointer c, int font);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_close_font(xcb_connection_t*, xcb_font_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8581</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_close_font(PointerByReference c, int font);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_fontprop_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_fontprop_t)<br>
	 * Original signature : <code>void xcb_fontprop_next(xcb_fontprop_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8593</i>
	 */
	void xcb_fontprop_next(xcb_fontprop_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_fontprop_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_fontprop_end(xcb_fontprop_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8605</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_fontprop_end(xcb_fontprop_iterator_t.ByValue i);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_charinfo_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_charinfo_t)<br>
	 * Original signature : <code>void xcb_charinfo_next(xcb_charinfo_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8616</i>
	 */
	void xcb_charinfo_next(xcb_charinfo_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_charinfo_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_charinfo_end(xcb_charinfo_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8628</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_charinfo_end(xcb_charinfo_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_query_font_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8631</i>
	 */
	int xcb_query_font_sizeof(Pointer _buffer);
	/**
	 * @brief query font metrics<br>
	 * @param c The connection<br>
	 * @param font The fontable (Font or Graphics Context) to query.<br>
	 * @return A cookie<br>
	 * Queries information associated with the font.<br>
	 * Original signature : <code>xcb_query_font_cookie_t xcb_query_font(xcb_connection_t*, xcb_fontable_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8644</i><br>
	 * @deprecated use the safer method {@link #xcb_query_font(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_query_font_cookie_t.ByValue xcb_query_font(Pointer c, int font);
	/**
	 * @brief query font metrics<br>
	 * @param c The connection<br>
	 * @param font The fontable (Font or Graphics Context) to query.<br>
	 * @return A cookie<br>
	 * Queries information associated with the font.<br>
	 * Original signature : <code>xcb_query_font_cookie_t xcb_query_font(xcb_connection_t*, xcb_fontable_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8644</i>
	 */
	com.yi.ylwm.xcb.xcb_query_font_cookie_t.ByValue xcb_query_font(PointerByReference c, int font);
	/**
	 * @brief query font metrics<br>
	 * @param c The connection<br>
	 * @param font The fontable (Font or Graphics Context) to query.<br>
	 * @return A cookie<br>
	 * Queries information associated with the font.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_font_cookie_t xcb_query_font_unchecked(xcb_connection_t*, xcb_fontable_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8661</i><br>
	 * @deprecated use the safer method {@link #xcb_query_font_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_query_font_cookie_t.ByValue xcb_query_font_unchecked(Pointer c, int font);
	/**
	 * @brief query font metrics<br>
	 * @param c The connection<br>
	 * @param font The fontable (Font or Graphics Context) to query.<br>
	 * @return A cookie<br>
	 * Queries information associated with the font.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_font_cookie_t xcb_query_font_unchecked(xcb_connection_t*, xcb_fontable_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8661</i>
	 */
	com.yi.ylwm.xcb.xcb_query_font_cookie_t.ByValue xcb_query_font_unchecked(PointerByReference c, int font);
	/**
	 * Original signature : <code>xcb_fontprop_t* xcb_query_font_properties(const xcb_query_font_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8665</i>
	 */
	xcb_fontprop_t xcb_query_font_properties(xcb_query_font_reply_t R);
	/**
	 * Original signature : <code>int xcb_query_font_properties_length(const xcb_query_font_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8668</i>
	 */
	int xcb_query_font_properties_length(xcb_query_font_reply_t R);
	/**
	 * Original signature : <code>xcb_fontprop_iterator_t xcb_query_font_properties_iterator(const xcb_query_font_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8671</i>
	 */
	xcb_fontprop_iterator_t.ByValue xcb_query_font_properties_iterator(xcb_query_font_reply_t R);
	/**
	 * Original signature : <code>xcb_charinfo_t* xcb_query_font_char_infos(const xcb_query_font_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8674</i>
	 */
	xcb_charinfo_t xcb_query_font_char_infos(xcb_query_font_reply_t R);
	/**
	 * Original signature : <code>int xcb_query_font_char_infos_length(const xcb_query_font_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8677</i>
	 */
	int xcb_query_font_char_infos_length(xcb_query_font_reply_t R);
	/**
	 * Original signature : <code>xcb_charinfo_iterator_t xcb_query_font_char_infos_iterator(const xcb_query_font_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8680</i>
	 */
	xcb_charinfo_iterator_t.ByValue xcb_query_font_char_infos_iterator(xcb_query_font_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_font_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_font_reply_t* xcb_query_font_reply(xcb_connection_t*, xcb_query_font_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8697</i><br>
	 * @deprecated use the safer method {@link #xcb_query_font_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_query_font_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_query_font_reply_t xcb_query_font_reply(Pointer c, com.yi.ylwm.xcb.xcb_query_font_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_font_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_font_reply_t* xcb_query_font_reply(xcb_connection_t*, xcb_query_font_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8697</i>
	 */
	xcb_query_font_reply_t xcb_query_font_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_query_font_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_query_text_extents_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8702</i>
	 */
	int xcb_query_text_extents_sizeof(Pointer _buffer, int string_len);
	/**
	 * @brief get text extents<br>
	 * @param c The connection<br>
	 * @param font The \a font to calculate text extents in. You can also pass a graphics context.<br>
	 * @param string_len The number of characters in \a string.<br>
	 * @param string The text to get text extents for.<br>
	 * @return A cookie<br>
	 * Query text extents from the X11 server. This request returns the bounding box<br>
	 * of the specified 16-bit character string in the specified \a font or the font<br>
	 * contained in the specified graphics context.<br>
	 * <br>
	 * `font_ascent` is set to the maximum of the ascent metrics of all characters in<br>
	 * the string. `font_descent` is set to the maximum of the descent metrics.<br>
	 * `overall_width` is set to the sum of the character-width metrics of all<br>
	 * characters in the string. For each character in the string, let W be the sum of<br>
	 * the character-width metrics of all characters preceding it in the string. Let L<br>
	 * be the left-side-bearing metric of the character plus W. Let R be the<br>
	 * right-side-bearing metric of the character plus W. The lbearing member is set<br>
	 * to the minimum L of all characters in the string. The rbearing member is set to<br>
	 * the maximum R.<br>
	 * <br>
	 * For fonts defined with linear indexing rather than 2-byte matrix indexing, each<br>
	 * `xcb_char2b_t` structure is interpreted as a 16-bit number with byte1 as the<br>
	 * most significant byte. If the font has no defined default character, undefined<br>
	 * characters in the string are taken to have all zero metrics.<br>
	 * <br>
	 * Characters with all zero metrics are ignored. If the font has no defined<br>
	 * default_char, the undefined characters in the string are also ignored.<br>
	 * Original signature : <code>xcb_query_text_extents_cookie_t xcb_query_text_extents(xcb_connection_t*, xcb_fontable_t, uint32_t, const xcb_char2b_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8738</i><br>
	 * @deprecated use the safer method {@link #xcb_query_text_extents(com.sun.jna.ptr.PointerByReference, int, int, com.yi.ylwm.xcb.xcb_char2b_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_query_text_extents_cookie_t.ByValue xcb_query_text_extents(Pointer c, int font, int string_len, xcb_char2b_t string);
	/**
	 * @brief get text extents<br>
	 * @param c The connection<br>
	 * @param font The \a font to calculate text extents in. You can also pass a graphics context.<br>
	 * @param string_len The number of characters in \a string.<br>
	 * @param string The text to get text extents for.<br>
	 * @return A cookie<br>
	 * Query text extents from the X11 server. This request returns the bounding box<br>
	 * of the specified 16-bit character string in the specified \a font or the font<br>
	 * contained in the specified graphics context.<br>
	 * <br>
	 * `font_ascent` is set to the maximum of the ascent metrics of all characters in<br>
	 * the string. `font_descent` is set to the maximum of the descent metrics.<br>
	 * `overall_width` is set to the sum of the character-width metrics of all<br>
	 * characters in the string. For each character in the string, let W be the sum of<br>
	 * the character-width metrics of all characters preceding it in the string. Let L<br>
	 * be the left-side-bearing metric of the character plus W. Let R be the<br>
	 * right-side-bearing metric of the character plus W. The lbearing member is set<br>
	 * to the minimum L of all characters in the string. The rbearing member is set to<br>
	 * the maximum R.<br>
	 * <br>
	 * For fonts defined with linear indexing rather than 2-byte matrix indexing, each<br>
	 * `xcb_char2b_t` structure is interpreted as a 16-bit number with byte1 as the<br>
	 * most significant byte. If the font has no defined default character, undefined<br>
	 * characters in the string are taken to have all zero metrics.<br>
	 * <br>
	 * Characters with all zero metrics are ignored. If the font has no defined<br>
	 * default_char, the undefined characters in the string are also ignored.<br>
	 * Original signature : <code>xcb_query_text_extents_cookie_t xcb_query_text_extents(xcb_connection_t*, xcb_fontable_t, uint32_t, const xcb_char2b_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8738</i>
	 */
	com.yi.ylwm.xcb.xcb_query_text_extents_cookie_t.ByValue xcb_query_text_extents(PointerByReference c, int font, int string_len, xcb_char2b_t string);
	/**
	 * @brief get text extents<br>
	 * @param c The connection<br>
	 * @param font The \a font to calculate text extents in. You can also pass a graphics context.<br>
	 * @param string_len The number of characters in \a string.<br>
	 * @param string The text to get text extents for.<br>
	 * @return A cookie<br>
	 * Query text extents from the X11 server. This request returns the bounding box<br>
	 * of the specified 16-bit character string in the specified \a font or the font<br>
	 * contained in the specified graphics context.<br>
	 * <br>
	 * `font_ascent` is set to the maximum of the ascent metrics of all characters in<br>
	 * the string. `font_descent` is set to the maximum of the descent metrics.<br>
	 * `overall_width` is set to the sum of the character-width metrics of all<br>
	 * characters in the string. For each character in the string, let W be the sum of<br>
	 * the character-width metrics of all characters preceding it in the string. Let L<br>
	 * be the left-side-bearing metric of the character plus W. Let R be the<br>
	 * right-side-bearing metric of the character plus W. The lbearing member is set<br>
	 * to the minimum L of all characters in the string. The rbearing member is set to<br>
	 * the maximum R.<br>
	 * <br>
	 * For fonts defined with linear indexing rather than 2-byte matrix indexing, each<br>
	 * `xcb_char2b_t` structure is interpreted as a 16-bit number with byte1 as the<br>
	 * most significant byte. If the font has no defined default character, undefined<br>
	 * characters in the string are taken to have all zero metrics.<br>
	 * <br>
	 * Characters with all zero metrics are ignored. If the font has no defined<br>
	 * default_char, the undefined characters in the string are also ignored.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_text_extents_cookie_t xcb_query_text_extents_unchecked(xcb_connection_t*, xcb_fontable_t, uint32_t, const xcb_char2b_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8779</i><br>
	 * @deprecated use the safer method {@link #xcb_query_text_extents_unchecked(com.sun.jna.ptr.PointerByReference, int, int, com.yi.ylwm.xcb.xcb_char2b_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_query_text_extents_cookie_t.ByValue xcb_query_text_extents_unchecked(Pointer c, int font, int string_len, xcb_char2b_t string);
	/**
	 * @brief get text extents<br>
	 * @param c The connection<br>
	 * @param font The \a font to calculate text extents in. You can also pass a graphics context.<br>
	 * @param string_len The number of characters in \a string.<br>
	 * @param string The text to get text extents for.<br>
	 * @return A cookie<br>
	 * Query text extents from the X11 server. This request returns the bounding box<br>
	 * of the specified 16-bit character string in the specified \a font or the font<br>
	 * contained in the specified graphics context.<br>
	 * <br>
	 * `font_ascent` is set to the maximum of the ascent metrics of all characters in<br>
	 * the string. `font_descent` is set to the maximum of the descent metrics.<br>
	 * `overall_width` is set to the sum of the character-width metrics of all<br>
	 * characters in the string. For each character in the string, let W be the sum of<br>
	 * the character-width metrics of all characters preceding it in the string. Let L<br>
	 * be the left-side-bearing metric of the character plus W. Let R be the<br>
	 * right-side-bearing metric of the character plus W. The lbearing member is set<br>
	 * to the minimum L of all characters in the string. The rbearing member is set to<br>
	 * the maximum R.<br>
	 * <br>
	 * For fonts defined with linear indexing rather than 2-byte matrix indexing, each<br>
	 * `xcb_char2b_t` structure is interpreted as a 16-bit number with byte1 as the<br>
	 * most significant byte. If the font has no defined default character, undefined<br>
	 * characters in the string are taken to have all zero metrics.<br>
	 * <br>
	 * Characters with all zero metrics are ignored. If the font has no defined<br>
	 * default_char, the undefined characters in the string are also ignored.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_text_extents_cookie_t xcb_query_text_extents_unchecked(xcb_connection_t*, xcb_fontable_t, uint32_t, const xcb_char2b_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8779</i>
	 */
	com.yi.ylwm.xcb.xcb_query_text_extents_cookie_t.ByValue xcb_query_text_extents_unchecked(PointerByReference c, int font, int string_len, xcb_char2b_t string);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_text_extents_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_text_extents_reply_t* xcb_query_text_extents_reply(xcb_connection_t*, xcb_query_text_extents_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8799</i><br>
	 * @deprecated use the safer method {@link #xcb_query_text_extents_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_query_text_extents_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_query_text_extents_reply_t xcb_query_text_extents_reply(Pointer c, com.yi.ylwm.xcb.xcb_query_text_extents_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_text_extents_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_text_extents_reply_t* xcb_query_text_extents_reply(xcb_connection_t*, xcb_query_text_extents_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8799</i>
	 */
	xcb_query_text_extents_reply_t xcb_query_text_extents_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_query_text_extents_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_str_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8804</i>
	 */
	int xcb_str_sizeof(Pointer _buffer);
	/**
	 * Original signature : <code>char* xcb_str_name(const xcb_str_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8807</i>
	 */
	Pointer xcb_str_name(xcb_str_t R);
	/**
	 * Original signature : <code>int xcb_str_name_length(const xcb_str_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8810</i>
	 */
	int xcb_str_name_length(xcb_str_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_str_name_end(const xcb_str_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8813</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_str_name_end(xcb_str_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_str_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_str_t)<br>
	 * Original signature : <code>void xcb_str_next(xcb_str_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8824</i>
	 */
	void xcb_str_next(xcb_str_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_str_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_str_end(xcb_str_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8836</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_str_end(xcb_str_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_list_fonts_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8839</i>
	 */
	int xcb_list_fonts_sizeof(Pointer _buffer);
	/**
	 * @brief get matching font names<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * Original signature : <code>xcb_list_fonts_cookie_t xcb_list_fonts(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8858</i><br>
	 * @deprecated use the safer methods {@link #xcb_list_fonts(com.sun.jna.ptr.PointerByReference, short, short, java.lang.String)} and {@link #xcb_list_fonts(com.sun.jna.ptr.PointerByReference, short, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_list_fonts_cookie_t.ByValue xcb_list_fonts(Pointer c, short max_names, short pattern_len, Pointer pattern);
	/**
	 * @brief get matching font names<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * Original signature : <code>xcb_list_fonts_cookie_t xcb_list_fonts(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8858</i>
	 */
	com.yi.ylwm.xcb.xcb_list_fonts_cookie_t.ByValue xcb_list_fonts(PointerByReference c, short max_names, short pattern_len, String pattern);
	/**
	 * @brief get matching font names<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * Original signature : <code>xcb_list_fonts_cookie_t xcb_list_fonts(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8858</i>
	 */
	com.yi.ylwm.xcb.xcb_list_fonts_cookie_t.ByValue xcb_list_fonts(PointerByReference c, short max_names, short pattern_len, Pointer pattern);
	/**
	 * @brief get matching font names<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_fonts_cookie_t xcb_list_fonts_unchecked(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8883</i><br>
	 * @deprecated use the safer methods {@link #xcb_list_fonts_unchecked(com.sun.jna.ptr.PointerByReference, short, short, java.lang.String)} and {@link #xcb_list_fonts_unchecked(com.sun.jna.ptr.PointerByReference, short, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_list_fonts_cookie_t.ByValue xcb_list_fonts_unchecked(Pointer c, short max_names, short pattern_len, Pointer pattern);
	/**
	 * @brief get matching font names<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_fonts_cookie_t xcb_list_fonts_unchecked(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8883</i>
	 */
	com.yi.ylwm.xcb.xcb_list_fonts_cookie_t.ByValue xcb_list_fonts_unchecked(PointerByReference c, short max_names, short pattern_len, String pattern);
	/**
	 * @brief get matching font names<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_fonts_cookie_t xcb_list_fonts_unchecked(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8883</i>
	 */
	com.yi.ylwm.xcb.xcb_list_fonts_cookie_t.ByValue xcb_list_fonts_unchecked(PointerByReference c, short max_names, short pattern_len, Pointer pattern);
	/**
	 * Original signature : <code>int xcb_list_fonts_names_length(const xcb_list_fonts_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8889</i>
	 */
	int xcb_list_fonts_names_length(xcb_list_fonts_reply_t R);
	/**
	 * Original signature : <code>xcb_str_iterator_t xcb_list_fonts_names_iterator(const xcb_list_fonts_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8892</i>
	 */
	xcb_str_iterator_t.ByValue xcb_list_fonts_names_iterator(xcb_list_fonts_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_fonts_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_fonts_reply_t* xcb_list_fonts_reply(xcb_connection_t*, xcb_list_fonts_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8909</i><br>
	 * @deprecated use the safer method {@link #xcb_list_fonts_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_list_fonts_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_list_fonts_reply_t xcb_list_fonts_reply(Pointer c, com.yi.ylwm.xcb.xcb_list_fonts_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_fonts_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_fonts_reply_t* xcb_list_fonts_reply(xcb_connection_t*, xcb_list_fonts_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8909</i>
	 */
	xcb_list_fonts_reply_t xcb_list_fonts_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_list_fonts_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_list_fonts_with_info_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8914</i>
	 */
	int xcb_list_fonts_with_info_sizeof(Pointer _buffer);
	/**
	 * @brief get matching font names and information<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * Original signature : <code>xcb_list_fonts_with_info_cookie_t xcb_list_fonts_with_info(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8933</i><br>
	 * @deprecated use the safer methods {@link #xcb_list_fonts_with_info(com.sun.jna.ptr.PointerByReference, short, short, java.lang.String)} and {@link #xcb_list_fonts_with_info(com.sun.jna.ptr.PointerByReference, short, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_list_fonts_with_info_cookie_t.ByValue xcb_list_fonts_with_info(Pointer c, short max_names, short pattern_len, Pointer pattern);
	/**
	 * @brief get matching font names and information<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * Original signature : <code>xcb_list_fonts_with_info_cookie_t xcb_list_fonts_with_info(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8933</i>
	 */
	com.yi.ylwm.xcb.xcb_list_fonts_with_info_cookie_t.ByValue xcb_list_fonts_with_info(PointerByReference c, short max_names, short pattern_len, String pattern);
	/**
	 * @brief get matching font names and information<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * Original signature : <code>xcb_list_fonts_with_info_cookie_t xcb_list_fonts_with_info(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8933</i>
	 */
	com.yi.ylwm.xcb.xcb_list_fonts_with_info_cookie_t.ByValue xcb_list_fonts_with_info(PointerByReference c, short max_names, short pattern_len, Pointer pattern);
	/**
	 * @brief get matching font names and information<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_fonts_with_info_cookie_t xcb_list_fonts_with_info_unchecked(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8958</i><br>
	 * @deprecated use the safer methods {@link #xcb_list_fonts_with_info_unchecked(com.sun.jna.ptr.PointerByReference, short, short, java.lang.String)} and {@link #xcb_list_fonts_with_info_unchecked(com.sun.jna.ptr.PointerByReference, short, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_list_fonts_with_info_cookie_t.ByValue xcb_list_fonts_with_info_unchecked(Pointer c, short max_names, short pattern_len, Pointer pattern);
	/**
	 * @brief get matching font names and information<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_fonts_with_info_cookie_t xcb_list_fonts_with_info_unchecked(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8958</i>
	 */
	com.yi.ylwm.xcb.xcb_list_fonts_with_info_cookie_t.ByValue xcb_list_fonts_with_info_unchecked(PointerByReference c, short max_names, short pattern_len, String pattern);
	/**
	 * @brief get matching font names and information<br>
	 * @param c The connection<br>
	 * @param max_names The maximum number of fonts to be returned.<br>
	 * @param pattern_len The length (in bytes) of \a pattern.<br>
	 * @param pattern A font pattern, for example "-misc-fixed-*".<br>
	 * \n<br>
	 * The asterisk (*) is a wildcard for any number of characters. The question mark<br>
	 * (?) is a wildcard for a single character. Use of uppercase or lowercase does<br>
	 * not matter.<br>
	 * @return A cookie<br>
	 * Gets a list of available font names which match the given \a pattern.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_fonts_with_info_cookie_t xcb_list_fonts_with_info_unchecked(xcb_connection_t*, uint16_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8958</i>
	 */
	com.yi.ylwm.xcb.xcb_list_fonts_with_info_cookie_t.ByValue xcb_list_fonts_with_info_unchecked(PointerByReference c, short max_names, short pattern_len, Pointer pattern);
	/**
	 * Original signature : <code>xcb_fontprop_t* xcb_list_fonts_with_info_properties(const xcb_list_fonts_with_info_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8964</i>
	 */
	xcb_fontprop_t xcb_list_fonts_with_info_properties(xcb_list_fonts_with_info_reply_t R);
	/**
	 * Original signature : <code>int xcb_list_fonts_with_info_properties_length(const xcb_list_fonts_with_info_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8967</i>
	 */
	int xcb_list_fonts_with_info_properties_length(xcb_list_fonts_with_info_reply_t R);
	/**
	 * Original signature : <code>xcb_fontprop_iterator_t xcb_list_fonts_with_info_properties_iterator(const xcb_list_fonts_with_info_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8970</i>
	 */
	xcb_fontprop_iterator_t.ByValue xcb_list_fonts_with_info_properties_iterator(xcb_list_fonts_with_info_reply_t R);
	/**
	 * Original signature : <code>char* xcb_list_fonts_with_info_name(const xcb_list_fonts_with_info_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8973</i>
	 */
	Pointer xcb_list_fonts_with_info_name(xcb_list_fonts_with_info_reply_t R);
	/**
	 * Original signature : <code>int xcb_list_fonts_with_info_name_length(const xcb_list_fonts_with_info_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8976</i>
	 */
	int xcb_list_fonts_with_info_name_length(xcb_list_fonts_with_info_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_list_fonts_with_info_name_end(const xcb_list_fonts_with_info_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8979</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_list_fonts_with_info_name_end(xcb_list_fonts_with_info_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_fonts_with_info_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_fonts_with_info_reply_t* xcb_list_fonts_with_info_reply(xcb_connection_t*, xcb_list_fonts_with_info_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8996</i><br>
	 * @deprecated use the safer method {@link #xcb_list_fonts_with_info_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_list_fonts_with_info_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_list_fonts_with_info_reply_t xcb_list_fonts_with_info_reply(Pointer c, com.yi.ylwm.xcb.xcb_list_fonts_with_info_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_fonts_with_info_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_fonts_with_info_reply_t* xcb_list_fonts_with_info_reply(xcb_connection_t*, xcb_list_fonts_with_info_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:8996</i>
	 */
	xcb_list_fonts_with_info_reply_t xcb_list_fonts_with_info_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_list_fonts_with_info_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_set_font_path_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9001</i>
	 */
	int xcb_set_font_path_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_font_path_checked(xcb_connection_t*, uint16_t, const xcb_str_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9015</i><br>
	 * @deprecated use the safer method {@link #xcb_set_font_path_checked(com.sun.jna.ptr.PointerByReference, short, com.yi.ylwm.xcb.xcb_str_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_font_path_checked(Pointer c, short font_qty, xcb_str_t font);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_font_path_checked(xcb_connection_t*, uint16_t, const xcb_str_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9015</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_font_path_checked(PointerByReference c, short font_qty, xcb_str_t font);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_font_path(xcb_connection_t*, uint16_t, const xcb_str_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9028</i><br>
	 * @deprecated use the safer method {@link #xcb_set_font_path(com.sun.jna.ptr.PointerByReference, short, com.yi.ylwm.xcb.xcb_str_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_font_path(Pointer c, short font_qty, xcb_str_t font);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_font_path(xcb_connection_t*, uint16_t, const xcb_str_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9028</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_font_path(PointerByReference c, short font_qty, xcb_str_t font);
	/**
	 * Original signature : <code>int xcb_set_font_path_font_length(const xcb_set_font_path_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9033</i>
	 */
	int xcb_set_font_path_font_length(xcb_set_font_path_request_t R);
	/**
	 * Original signature : <code>xcb_str_iterator_t xcb_set_font_path_font_iterator(const xcb_set_font_path_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9036</i>
	 */
	xcb_str_iterator_t.ByValue xcb_set_font_path_font_iterator(xcb_set_font_path_request_t R);
	/**
	 * Original signature : <code>int xcb_get_font_path_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9039</i>
	 */
	int xcb_get_font_path_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_font_path_cookie_t xcb_get_font_path(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9050</i><br>
	 * @deprecated use the safer method {@link #xcb_get_font_path(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_font_path_cookie_t.ByValue xcb_get_font_path(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_font_path_cookie_t xcb_get_font_path(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9050</i>
	 */
	com.yi.ylwm.xcb.xcb_get_font_path_cookie_t.ByValue xcb_get_font_path(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_font_path_cookie_t xcb_get_font_path_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9064</i><br>
	 * @deprecated use the safer method {@link #xcb_get_font_path_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_font_path_cookie_t.ByValue xcb_get_font_path_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_font_path_cookie_t xcb_get_font_path_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9064</i>
	 */
	com.yi.ylwm.xcb.xcb_get_font_path_cookie_t.ByValue xcb_get_font_path_unchecked(PointerByReference c);
	/**
	 * Original signature : <code>int xcb_get_font_path_path_length(const xcb_get_font_path_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9067</i>
	 */
	int xcb_get_font_path_path_length(xcb_get_font_path_reply_t R);
	/**
	 * Original signature : <code>xcb_str_iterator_t xcb_get_font_path_path_iterator(const xcb_get_font_path_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9070</i>
	 */
	xcb_str_iterator_t.ByValue xcb_get_font_path_path_iterator(xcb_get_font_path_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_font_path_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_font_path_reply_t* xcb_get_font_path_reply(xcb_connection_t*, xcb_get_font_path_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9087</i><br>
	 * @deprecated use the safer method {@link #xcb_get_font_path_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_get_font_path_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_font_path_reply_t xcb_get_font_path_reply(Pointer c, com.yi.ylwm.xcb.xcb_get_font_path_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_font_path_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_font_path_reply_t* xcb_get_font_path_reply(xcb_connection_t*, xcb_get_font_path_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9087</i>
	 */
	xcb_get_font_path_reply_t xcb_get_font_path_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_get_font_path_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * @brief Creates a pixmap<br>
	 * @param c The connection<br>
	 * @param depth TODO<br>
	 * @param pid The ID with which you will refer to the new pixmap, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the screen from.<br>
	 * @param width The width of the new pixmap.<br>
	 * @param height The height of the new pixmap.<br>
	 * @return A cookie<br>
	 * Creates a pixmap. The pixmap can only be used on the same screen as \a drawable<br>
	 * is on and only with drawables of the same \a depth.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_pixmap_checked(xcb_connection_t*, uint8_t, xcb_pixmap_t, xcb_drawable_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9111</i><br>
	 * @deprecated use the safer method {@link #xcb_create_pixmap_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_pixmap_checked(Pointer c, byte depth, int pid, int drawable, short width, short height);
	/**
	 * @brief Creates a pixmap<br>
	 * @param c The connection<br>
	 * @param depth TODO<br>
	 * @param pid The ID with which you will refer to the new pixmap, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the screen from.<br>
	 * @param width The width of the new pixmap.<br>
	 * @param height The height of the new pixmap.<br>
	 * @return A cookie<br>
	 * Creates a pixmap. The pixmap can only be used on the same screen as \a drawable<br>
	 * is on and only with drawables of the same \a depth.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_pixmap_checked(xcb_connection_t*, uint8_t, xcb_pixmap_t, xcb_drawable_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9111</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_pixmap_checked(PointerByReference c, byte depth, int pid, int drawable, short width, short height);
	/**
	 * @brief Creates a pixmap<br>
	 * @param c The connection<br>
	 * @param depth TODO<br>
	 * @param pid The ID with which you will refer to the new pixmap, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the screen from.<br>
	 * @param width The width of the new pixmap.<br>
	 * @param height The height of the new pixmap.<br>
	 * @return A cookie<br>
	 * Creates a pixmap. The pixmap can only be used on the same screen as \a drawable<br>
	 * is on and only with drawables of the same \a depth.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_pixmap(xcb_connection_t*, uint8_t, xcb_pixmap_t, xcb_drawable_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9135</i><br>
	 * @deprecated use the safer method {@link #xcb_create_pixmap(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_pixmap(Pointer c, byte depth, int pid, int drawable, short width, short height);
	/**
	 * @brief Creates a pixmap<br>
	 * @param c The connection<br>
	 * @param depth TODO<br>
	 * @param pid The ID with which you will refer to the new pixmap, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the screen from.<br>
	 * @param width The width of the new pixmap.<br>
	 * @param height The height of the new pixmap.<br>
	 * @return A cookie<br>
	 * Creates a pixmap. The pixmap can only be used on the same screen as \a drawable<br>
	 * is on and only with drawables of the same \a depth.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_pixmap(xcb_connection_t*, uint8_t, xcb_pixmap_t, xcb_drawable_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9135</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_pixmap(PointerByReference c, byte depth, int pid, int drawable, short width, short height);
	/**
	 * @brief Destroys a pixmap<br>
	 * @param c The connection<br>
	 * @param pixmap The pixmap to destroy.<br>
	 * @return A cookie<br>
	 * Deletes the association between the pixmap ID and the pixmap. The pixmap<br>
	 * storage will be freed when there are no more references to it.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_pixmap_checked(xcb_connection_t*, xcb_pixmap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9157</i><br>
	 * @deprecated use the safer method {@link #xcb_free_pixmap_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_pixmap_checked(Pointer c, int pixmap);
	/**
	 * @brief Destroys a pixmap<br>
	 * @param c The connection<br>
	 * @param pixmap The pixmap to destroy.<br>
	 * @return A cookie<br>
	 * Deletes the association between the pixmap ID and the pixmap. The pixmap<br>
	 * storage will be freed when there are no more references to it.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_pixmap_checked(xcb_connection_t*, xcb_pixmap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9157</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_pixmap_checked(PointerByReference c, int pixmap);
	/**
	 * @brief Destroys a pixmap<br>
	 * @param c The connection<br>
	 * @param pixmap The pixmap to destroy.<br>
	 * @return A cookie<br>
	 * Deletes the association between the pixmap ID and the pixmap. The pixmap<br>
	 * storage will be freed when there are no more references to it.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_pixmap(xcb_connection_t*, xcb_pixmap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9172</i><br>
	 * @deprecated use the safer method {@link #xcb_free_pixmap(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_pixmap(Pointer c, int pixmap);
	/**
	 * @brief Destroys a pixmap<br>
	 * @param c The connection<br>
	 * @param pixmap The pixmap to destroy.<br>
	 * @return A cookie<br>
	 * Deletes the association between the pixmap ID and the pixmap. The pixmap<br>
	 * storage will be freed when there are no more references to it.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_pixmap(xcb_connection_t*, xcb_pixmap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9172</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_pixmap(PointerByReference c, int pixmap);
	/**
	 * Original signature : <code>int xcb_create_gc_value_list_serialize(void**, uint32_t, const xcb_create_gc_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9176</i>
	 */
	int xcb_create_gc_value_list_serialize(PointerByReference _buffer, int value_mask, xcb_create_gc_value_list_t _aux);
	/**
	 * Original signature : <code>int xcb_create_gc_value_list_unpack(const void*, uint32_t, xcb_create_gc_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9181</i>
	 */
	int xcb_create_gc_value_list_unpack(Pointer _buffer, int value_mask, xcb_create_gc_value_list_t _aux);
	/**
	 * Original signature : <code>int xcb_create_gc_value_list_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9186</i>
	 */
	int xcb_create_gc_value_list_sizeof(Pointer _buffer, int value_mask);
	/**
	 * Original signature : <code>int xcb_create_gc_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9190</i>
	 */
	int xcb_create_gc_sizeof(Pointer _buffer);
	/**
	 * @brief Creates a graphics context<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the graphics context, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the root/depth from.<br>
	 * @return A cookie<br>
	 * Creates a graphics context. The graphics context can be used with any drawable<br>
	 * that has the same root and depth as the specified drawable.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_gc_checked(xcb_connection_t*, xcb_gcontext_t, xcb_drawable_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9209</i><br>
	 * @deprecated use the safer method {@link #xcb_create_gc_checked(com.sun.jna.ptr.PointerByReference, int, int, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_gc_checked(Pointer c, int cid, int drawable, int value_mask, Pointer value_list);
	/**
	 * @brief Creates a graphics context<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the graphics context, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the root/depth from.<br>
	 * @return A cookie<br>
	 * Creates a graphics context. The graphics context can be used with any drawable<br>
	 * that has the same root and depth as the specified drawable.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_gc_checked(xcb_connection_t*, xcb_gcontext_t, xcb_drawable_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9209</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_gc_checked(PointerByReference c, int cid, int drawable, int value_mask, Pointer value_list);
	/**
	 * @brief Creates a graphics context<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the graphics context, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the root/depth from.<br>
	 * @return A cookie<br>
	 * Creates a graphics context. The graphics context can be used with any drawable<br>
	 * that has the same root and depth as the specified drawable.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_gc(xcb_connection_t*, xcb_gcontext_t, xcb_drawable_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9229</i><br>
	 * @deprecated use the safer method {@link #xcb_create_gc(com.sun.jna.ptr.PointerByReference, int, int, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_gc(Pointer c, int cid, int drawable, int value_mask, Pointer value_list);
	/**
	 * @brief Creates a graphics context<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the graphics context, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the root/depth from.<br>
	 * @return A cookie<br>
	 * Creates a graphics context. The graphics context can be used with any drawable<br>
	 * that has the same root and depth as the specified drawable.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_gc(xcb_connection_t*, xcb_gcontext_t, xcb_drawable_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9229</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_gc(PointerByReference c, int cid, int drawable, int value_mask, Pointer value_list);
	/**
	 * @brief Creates a graphics context<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the graphics context, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the root/depth from.<br>
	 * @return A cookie<br>
	 * Creates a graphics context. The graphics context can be used with any drawable<br>
	 * that has the same root and depth as the specified drawable.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_gc_aux_checked(xcb_connection_t*, xcb_gcontext_t, xcb_drawable_t, uint32_t, const xcb_create_gc_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9252</i><br>
	 * @deprecated use the safer method {@link #xcb_create_gc_aux_checked(com.sun.jna.ptr.PointerByReference, int, int, int, com.yi.ylwm.xcb.xcb_create_gc_value_list_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_gc_aux_checked(Pointer c, int cid, int drawable, int value_mask, xcb_create_gc_value_list_t value_list);
	/**
	 * @brief Creates a graphics context<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the graphics context, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the root/depth from.<br>
	 * @return A cookie<br>
	 * Creates a graphics context. The graphics context can be used with any drawable<br>
	 * that has the same root and depth as the specified drawable.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_gc_aux_checked(xcb_connection_t*, xcb_gcontext_t, xcb_drawable_t, uint32_t, const xcb_create_gc_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9252</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_gc_aux_checked(PointerByReference c, int cid, int drawable, int value_mask, xcb_create_gc_value_list_t value_list);
	/**
	 * @brief Creates a graphics context<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the graphics context, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the root/depth from.<br>
	 * @return A cookie<br>
	 * Creates a graphics context. The graphics context can be used with any drawable<br>
	 * that has the same root and depth as the specified drawable.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_gc_aux(xcb_connection_t*, xcb_gcontext_t, xcb_drawable_t, uint32_t, const xcb_create_gc_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9272</i><br>
	 * @deprecated use the safer method {@link #xcb_create_gc_aux(com.sun.jna.ptr.PointerByReference, int, int, int, com.yi.ylwm.xcb.xcb_create_gc_value_list_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_gc_aux(Pointer c, int cid, int drawable, int value_mask, xcb_create_gc_value_list_t value_list);
	/**
	 * @brief Creates a graphics context<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the graphics context, created by<br>
	 * `xcb_generate_id`.<br>
	 * @param drawable Drawable to get the root/depth from.<br>
	 * @return A cookie<br>
	 * Creates a graphics context. The graphics context can be used with any drawable<br>
	 * that has the same root and depth as the specified drawable.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_gc_aux(xcb_connection_t*, xcb_gcontext_t, xcb_drawable_t, uint32_t, const xcb_create_gc_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9272</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_gc_aux(PointerByReference c, int cid, int drawable, int value_mask, xcb_create_gc_value_list_t value_list);
	/**
	 * Original signature : <code>void* xcb_create_gc_value_list(const xcb_create_gc_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9279</i>
	 */
	Pointer xcb_create_gc_value_list(xcb_create_gc_request_t R);
	/**
	 * Original signature : <code>int xcb_change_gc_value_list_serialize(void**, uint32_t, const xcb_change_gc_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9282</i>
	 */
	int xcb_change_gc_value_list_serialize(PointerByReference _buffer, int value_mask, xcb_change_gc_value_list_t _aux);
	/**
	 * Original signature : <code>int xcb_change_gc_value_list_unpack(const void*, uint32_t, xcb_change_gc_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9287</i>
	 */
	int xcb_change_gc_value_list_unpack(Pointer _buffer, int value_mask, xcb_change_gc_value_list_t _aux);
	/**
	 * Original signature : <code>int xcb_change_gc_value_list_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9292</i>
	 */
	int xcb_change_gc_value_list_sizeof(Pointer _buffer, int value_mask);
	/**
	 * Original signature : <code>int xcb_change_gc_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9296</i>
	 */
	int xcb_change_gc_sizeof(Pointer _buffer);
	/**
	 * @brief change graphics context components<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to change.<br>
	 * @param value_mask A bitmask of #xcb_gc_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the components specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the components specified by \a value_mask for the specified graphics context.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_gc_checked(xcb_connection_t*, xcb_gcontext_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9317</i><br>
	 * @deprecated use the safer method {@link #xcb_change_gc_checked(com.sun.jna.ptr.PointerByReference, int, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_gc_checked(Pointer c, int gc, int value_mask, Pointer value_list);
	/**
	 * @brief change graphics context components<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to change.<br>
	 * @param value_mask A bitmask of #xcb_gc_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the components specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the components specified by \a value_mask for the specified graphics context.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_gc_checked(xcb_connection_t*, xcb_gcontext_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9317</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_gc_checked(PointerByReference c, int gc, int value_mask, Pointer value_list);
	/**
	 * @brief change graphics context components<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to change.<br>
	 * @param value_mask A bitmask of #xcb_gc_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the components specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the components specified by \a value_mask for the specified graphics context.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_gc(xcb_connection_t*, xcb_gcontext_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9338</i><br>
	 * @deprecated use the safer method {@link #xcb_change_gc(com.sun.jna.ptr.PointerByReference, int, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_gc(Pointer c, int gc, int value_mask, Pointer value_list);
	/**
	 * @brief change graphics context components<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to change.<br>
	 * @param value_mask A bitmask of #xcb_gc_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the components specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the components specified by \a value_mask for the specified graphics context.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_gc(xcb_connection_t*, xcb_gcontext_t, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9338</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_gc(PointerByReference c, int gc, int value_mask, Pointer value_list);
	/**
	 * @brief change graphics context components<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to change.<br>
	 * @param value_mask A bitmask of #xcb_gc_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the components specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the components specified by \a value_mask for the specified graphics context.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_gc_aux_checked(xcb_connection_t*, xcb_gcontext_t, uint32_t, const xcb_change_gc_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9362</i><br>
	 * @deprecated use the safer method {@link #xcb_change_gc_aux_checked(com.sun.jna.ptr.PointerByReference, int, int, com.yi.ylwm.xcb.xcb_change_gc_value_list_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_gc_aux_checked(Pointer c, int gc, int value_mask, xcb_change_gc_value_list_t value_list);
	/**
	 * @brief change graphics context components<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to change.<br>
	 * @param value_mask A bitmask of #xcb_gc_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the components specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the components specified by \a value_mask for the specified graphics context.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_gc_aux_checked(xcb_connection_t*, xcb_gcontext_t, uint32_t, const xcb_change_gc_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9362</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_gc_aux_checked(PointerByReference c, int gc, int value_mask, xcb_change_gc_value_list_t value_list);
	/**
	 * @brief change graphics context components<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to change.<br>
	 * @param value_mask A bitmask of #xcb_gc_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the components specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the components specified by \a value_mask for the specified graphics context.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_gc_aux(xcb_connection_t*, xcb_gcontext_t, uint32_t, const xcb_change_gc_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9383</i><br>
	 * @deprecated use the safer method {@link #xcb_change_gc_aux(com.sun.jna.ptr.PointerByReference, int, int, com.yi.ylwm.xcb.xcb_change_gc_value_list_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_gc_aux(Pointer c, int gc, int value_mask, xcb_change_gc_value_list_t value_list);
	/**
	 * @brief change graphics context components<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to change.<br>
	 * @param value_mask A bitmask of #xcb_gc_t values.<br>
	 * @param value_mask \n<br>
	 * @param value_list Values for each of the components specified in the bitmask \a value_mask. The<br>
	 * order has to correspond to the order of possible \a value_mask bits. See the<br>
	 * example.<br>
	 * @return A cookie<br>
	 * Changes the components specified by \a value_mask for the specified graphics context.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_gc_aux(xcb_connection_t*, xcb_gcontext_t, uint32_t, const xcb_change_gc_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9383</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_gc_aux(PointerByReference c, int gc, int value_mask, xcb_change_gc_value_list_t value_list);
	/**
	 * Original signature : <code>void* xcb_change_gc_value_list(const xcb_change_gc_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9389</i>
	 */
	Pointer xcb_change_gc_value_list(xcb_change_gc_request_t R);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_gc_checked(xcb_connection_t*, xcb_gcontext_t, xcb_gcontext_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9403</i><br>
	 * @deprecated use the safer method {@link #xcb_copy_gc_checked(com.sun.jna.ptr.PointerByReference, int, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_copy_gc_checked(Pointer c, int src_gc, int dst_gc, int value_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_gc_checked(xcb_connection_t*, xcb_gcontext_t, xcb_gcontext_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9403</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_copy_gc_checked(PointerByReference c, int src_gc, int dst_gc, int value_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_gc(xcb_connection_t*, xcb_gcontext_t, xcb_gcontext_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9417</i><br>
	 * @deprecated use the safer method {@link #xcb_copy_gc(com.sun.jna.ptr.PointerByReference, int, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_copy_gc(Pointer c, int src_gc, int dst_gc, int value_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_gc(xcb_connection_t*, xcb_gcontext_t, xcb_gcontext_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9417</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_copy_gc(PointerByReference c, int src_gc, int dst_gc, int value_mask);
	/**
	 * Original signature : <code>int xcb_set_dashes_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9423</i>
	 */
	int xcb_set_dashes_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_dashes_checked(xcb_connection_t*, xcb_gcontext_t, uint16_t, uint16_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9437</i><br>
	 * @deprecated use the safer methods {@link #xcb_set_dashes_checked(com.sun.jna.ptr.PointerByReference, int, short, short, byte[])} and {@link #xcb_set_dashes_checked(com.sun.jna.ptr.PointerByReference, int, short, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_dashes_checked(Pointer c, int gc, short dash_offset, short dashes_len, Pointer dashes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_dashes_checked(xcb_connection_t*, xcb_gcontext_t, uint16_t, uint16_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9437</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_dashes_checked(PointerByReference c, int gc, short dash_offset, short dashes_len, byte dashes[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_dashes_checked(xcb_connection_t*, xcb_gcontext_t, uint16_t, uint16_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9437</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_dashes_checked(PointerByReference c, int gc, short dash_offset, short dashes_len, Pointer dashes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_dashes(xcb_connection_t*, xcb_gcontext_t, uint16_t, uint16_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9452</i><br>
	 * @deprecated use the safer methods {@link #xcb_set_dashes(com.sun.jna.ptr.PointerByReference, int, short, short, byte[])} and {@link #xcb_set_dashes(com.sun.jna.ptr.PointerByReference, int, short, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_dashes(Pointer c, int gc, short dash_offset, short dashes_len, Pointer dashes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_dashes(xcb_connection_t*, xcb_gcontext_t, uint16_t, uint16_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9452</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_dashes(PointerByReference c, int gc, short dash_offset, short dashes_len, byte dashes[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_dashes(xcb_connection_t*, xcb_gcontext_t, uint16_t, uint16_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9452</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_dashes(PointerByReference c, int gc, short dash_offset, short dashes_len, Pointer dashes);
	/**
	 * Original signature : <code>uint8_t* xcb_set_dashes_dashes(const xcb_set_dashes_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9459</i>
	 */
	Pointer xcb_set_dashes_dashes(xcb_set_dashes_request_t R);
	/**
	 * Original signature : <code>int xcb_set_dashes_dashes_length(const xcb_set_dashes_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9462</i>
	 */
	int xcb_set_dashes_dashes_length(xcb_set_dashes_request_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_set_dashes_dashes_end(const xcb_set_dashes_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9465</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_set_dashes_dashes_end(xcb_set_dashes_request_t R);
	/**
	 * Original signature : <code>int xcb_set_clip_rectangles_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9468</i>
	 */
	int xcb_set_clip_rectangles_sizeof(Pointer _buffer, int rectangles_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_clip_rectangles_checked(xcb_connection_t*, uint8_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9483</i><br>
	 * @deprecated use the safer method {@link #xcb_set_clip_rectangles_checked(com.sun.jna.ptr.PointerByReference, byte, int, short, short, int, com.yi.ylwm.xcb.xcb_rectangle_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_clip_rectangles_checked(Pointer c, byte ordering, int gc, short clip_x_origin, short clip_y_origin, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_clip_rectangles_checked(xcb_connection_t*, uint8_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9483</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_clip_rectangles_checked(PointerByReference c, byte ordering, int gc, short clip_x_origin, short clip_y_origin, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_clip_rectangles(xcb_connection_t*, uint8_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9500</i><br>
	 * @deprecated use the safer method {@link #xcb_set_clip_rectangles(com.sun.jna.ptr.PointerByReference, byte, int, short, short, int, com.yi.ylwm.xcb.xcb_rectangle_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_clip_rectangles(Pointer c, byte ordering, int gc, short clip_x_origin, short clip_y_origin, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_clip_rectangles(xcb_connection_t*, uint8_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9500</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_clip_rectangles(PointerByReference c, byte ordering, int gc, short clip_x_origin, short clip_y_origin, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * Original signature : <code>xcb_rectangle_t* xcb_set_clip_rectangles_rectangles(const xcb_set_clip_rectangles_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9509</i>
	 */
	xcb_rectangle_t xcb_set_clip_rectangles_rectangles(xcb_set_clip_rectangles_request_t R);
	/**
	 * Original signature : <code>int xcb_set_clip_rectangles_rectangles_length(const xcb_set_clip_rectangles_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9512</i>
	 */
	int xcb_set_clip_rectangles_rectangles_length(xcb_set_clip_rectangles_request_t R);
	/**
	 * Original signature : <code>xcb_rectangle_iterator_t xcb_set_clip_rectangles_rectangles_iterator(const xcb_set_clip_rectangles_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9515</i>
	 */
	xcb_rectangle_iterator_t.ByValue xcb_set_clip_rectangles_rectangles_iterator(xcb_set_clip_rectangles_request_t R);
	/**
	 * @brief Destroys a graphics context<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to destroy.<br>
	 * @return A cookie<br>
	 * Destroys the specified \a gc and all associated storage.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_gc_checked(xcb_connection_t*, xcb_gcontext_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9531</i><br>
	 * @deprecated use the safer method {@link #xcb_free_gc_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_gc_checked(Pointer c, int gc);
	/**
	 * @brief Destroys a graphics context<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to destroy.<br>
	 * @return A cookie<br>
	 * Destroys the specified \a gc and all associated storage.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_gc_checked(xcb_connection_t*, xcb_gcontext_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9531</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_gc_checked(PointerByReference c, int gc);
	/**
	 * @brief Destroys a graphics context<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to destroy.<br>
	 * @return A cookie<br>
	 * Destroys the specified \a gc and all associated storage.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_gc(xcb_connection_t*, xcb_gcontext_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9545</i><br>
	 * @deprecated use the safer method {@link #xcb_free_gc(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_gc(Pointer c, int gc);
	/**
	 * @brief Destroys a graphics context<br>
	 * @param c The connection<br>
	 * @param gc The graphics context to destroy.<br>
	 * @return A cookie<br>
	 * Destroys the specified \a gc and all associated storage.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_gc(xcb_connection_t*, xcb_gcontext_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9545</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_gc(PointerByReference c, int gc);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_clear_area_checked(xcb_connection_t*, uint8_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9560</i><br>
	 * @deprecated use the safer method {@link #xcb_clear_area_checked(com.sun.jna.ptr.PointerByReference, byte, int, short, short, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_clear_area_checked(Pointer c, byte exposures, int window, short x, short y, short width, short height);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_clear_area_checked(xcb_connection_t*, uint8_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9560</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_clear_area_checked(PointerByReference c, byte exposures, int window, short x, short y, short width, short height);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_clear_area(xcb_connection_t*, uint8_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9577</i><br>
	 * @deprecated use the safer method {@link #xcb_clear_area(com.sun.jna.ptr.PointerByReference, byte, int, short, short, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_clear_area(Pointer c, byte exposures, int window, short x, short y, short width, short height);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_clear_area(xcb_connection_t*, uint8_t, xcb_window_t, int16_t, int16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9577</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_clear_area(PointerByReference c, byte exposures, int window, short x, short y, short width, short height);
	/**
	 * @brief copy areas<br>
	 * @param c The connection<br>
	 * @param src_drawable The source drawable (Window or Pixmap).<br>
	 * @param dst_drawable The destination drawable (Window or Pixmap).<br>
	 * @param gc The graphics context to use.<br>
	 * @param src_x The source X coordinate.<br>
	 * @param src_y The source Y coordinate.<br>
	 * @param dst_x The destination X coordinate.<br>
	 * @param dst_y The destination Y coordinate.<br>
	 * @param width The width of the area to copy (in pixels).<br>
	 * @param height The height of the area to copy (in pixels).<br>
	 * @return A cookie<br>
	 * Copies the specified rectangle from \a src_drawable to \a dst_drawable.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_area_checked(xcb_connection_t*, xcb_drawable_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, int16_t, int16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9607</i><br>
	 * @deprecated use the safer method {@link #xcb_copy_area_checked(com.sun.jna.ptr.PointerByReference, int, int, int, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_copy_area_checked(Pointer c, int src_drawable, int dst_drawable, int gc, short src_x, short src_y, short dst_x, short dst_y, short width, short height);
	/**
	 * @brief copy areas<br>
	 * @param c The connection<br>
	 * @param src_drawable The source drawable (Window or Pixmap).<br>
	 * @param dst_drawable The destination drawable (Window or Pixmap).<br>
	 * @param gc The graphics context to use.<br>
	 * @param src_x The source X coordinate.<br>
	 * @param src_y The source Y coordinate.<br>
	 * @param dst_x The destination X coordinate.<br>
	 * @param dst_y The destination Y coordinate.<br>
	 * @param width The width of the area to copy (in pixels).<br>
	 * @param height The height of the area to copy (in pixels).<br>
	 * @return A cookie<br>
	 * Copies the specified rectangle from \a src_drawable to \a dst_drawable.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_area_checked(xcb_connection_t*, xcb_drawable_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, int16_t, int16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9607</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_copy_area_checked(PointerByReference c, int src_drawable, int dst_drawable, int gc, short src_x, short src_y, short dst_x, short dst_y, short width, short height);
	/**
	 * @brief copy areas<br>
	 * @param c The connection<br>
	 * @param src_drawable The source drawable (Window or Pixmap).<br>
	 * @param dst_drawable The destination drawable (Window or Pixmap).<br>
	 * @param gc The graphics context to use.<br>
	 * @param src_x The source X coordinate.<br>
	 * @param src_y The source Y coordinate.<br>
	 * @param dst_x The destination X coordinate.<br>
	 * @param dst_y The destination Y coordinate.<br>
	 * @param width The width of the area to copy (in pixels).<br>
	 * @param height The height of the area to copy (in pixels).<br>
	 * @return A cookie<br>
	 * Copies the specified rectangle from \a src_drawable to \a dst_drawable.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_area(xcb_connection_t*, xcb_drawable_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, int16_t, int16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9637</i><br>
	 * @deprecated use the safer method {@link #xcb_copy_area(com.sun.jna.ptr.PointerByReference, int, int, int, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_copy_area(Pointer c, int src_drawable, int dst_drawable, int gc, short src_x, short src_y, short dst_x, short dst_y, short width, short height);
	/**
	 * @brief copy areas<br>
	 * @param c The connection<br>
	 * @param src_drawable The source drawable (Window or Pixmap).<br>
	 * @param dst_drawable The destination drawable (Window or Pixmap).<br>
	 * @param gc The graphics context to use.<br>
	 * @param src_x The source X coordinate.<br>
	 * @param src_y The source Y coordinate.<br>
	 * @param dst_x The destination X coordinate.<br>
	 * @param dst_y The destination Y coordinate.<br>
	 * @param width The width of the area to copy (in pixels).<br>
	 * @param height The height of the area to copy (in pixels).<br>
	 * @return A cookie<br>
	 * Copies the specified rectangle from \a src_drawable to \a dst_drawable.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_area(xcb_connection_t*, xcb_drawable_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, int16_t, int16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9637</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_copy_area(PointerByReference c, int src_drawable, int dst_drawable, int gc, short src_x, short src_y, short dst_x, short dst_y, short width, short height);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_plane_checked(xcb_connection_t*, xcb_drawable_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, int16_t, int16_t, uint16_t, uint16_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9660</i><br>
	 * @deprecated use the safer method {@link #xcb_copy_plane_checked(com.sun.jna.ptr.PointerByReference, int, int, int, short, short, short, short, short, short, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_copy_plane_checked(Pointer c, int src_drawable, int dst_drawable, int gc, short src_x, short src_y, short dst_x, short dst_y, short width, short height, int bit_plane);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_plane_checked(xcb_connection_t*, xcb_drawable_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, int16_t, int16_t, uint16_t, uint16_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9660</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_copy_plane_checked(PointerByReference c, int src_drawable, int dst_drawable, int gc, short src_x, short src_y, short dst_x, short dst_y, short width, short height, int bit_plane);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_plane(xcb_connection_t*, xcb_drawable_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, int16_t, int16_t, uint16_t, uint16_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9681</i><br>
	 * @deprecated use the safer method {@link #xcb_copy_plane(com.sun.jna.ptr.PointerByReference, int, int, int, short, short, short, short, short, short, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_copy_plane(Pointer c, int src_drawable, int dst_drawable, int gc, short src_x, short src_y, short dst_x, short dst_y, short width, short height, int bit_plane);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_plane(xcb_connection_t*, xcb_drawable_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, int16_t, int16_t, uint16_t, uint16_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9681</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_copy_plane(PointerByReference c, int src_drawable, int dst_drawable, int gc, short src_x, short src_y, short dst_x, short dst_y, short width, short height, int bit_plane);
	/**
	 * Original signature : <code>int xcb_poly_point_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9694</i>
	 */
	int xcb_poly_point_sizeof(Pointer _buffer, int points_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_point_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_point_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9709</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_point_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, int, com.yi.ylwm.xcb.xcb_point_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_point_checked(Pointer c, byte coordinate_mode, int drawable, int gc, int points_len, xcb_point_t points);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_point_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_point_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9709</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_point_checked(PointerByReference c, byte coordinate_mode, int drawable, int gc, int points_len, xcb_point_t points);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_point(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_point_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9725</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_point(com.sun.jna.ptr.PointerByReference, byte, int, int, int, com.yi.ylwm.xcb.xcb_point_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_point(Pointer c, byte coordinate_mode, int drawable, int gc, int points_len, xcb_point_t points);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_point(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_point_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9725</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_point(PointerByReference c, byte coordinate_mode, int drawable, int gc, int points_len, xcb_point_t points);
	/**
	 * Original signature : <code>xcb_point_t* xcb_poly_point_points(const xcb_poly_point_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9733</i>
	 */
	xcb_point_t xcb_poly_point_points(xcb_poly_point_request_t R);
	/**
	 * Original signature : <code>int xcb_poly_point_points_length(const xcb_poly_point_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9736</i>
	 */
	int xcb_poly_point_points_length(xcb_poly_point_request_t R);
	/**
	 * Original signature : <code>xcb_point_iterator_t xcb_poly_point_points_iterator(const xcb_poly_point_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9739</i>
	 */
	xcb_point_iterator_t.ByValue xcb_poly_point_points_iterator(xcb_poly_point_request_t R);
	/**
	 * Original signature : <code>int xcb_poly_line_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9742</i>
	 */
	int xcb_poly_line_sizeof(Pointer _buffer, int points_len);
	/**
	 * @brief draw lines<br>
	 * @param c The connection<br>
	 * @param coordinate_mode A bitmask of #xcb_coord_mode_t values.<br>
	 * @param coordinate_mode \n<br>
	 * @param drawable The drawable to draw the line(s) on.<br>
	 * @param gc The graphics context to use.<br>
	 * @param points_len The number of `xcb_point_t` structures in \a points.<br>
	 * @param points An array of points.<br>
	 * @return A cookie<br>
	 * Draws \a points_len-1 lines between each pair of points (point[i], point[i+1])<br>
	 * in the \a points array. The lines are drawn in the order listed in the array.<br>
	 * They join correctly at all intermediate points, and if the first and last<br>
	 * points coincide, the first and last lines also join correctly. For any given<br>
	 * line, a pixel is not drawn more than once. If thin (zero line-width) lines<br>
	 * intersect, the intersecting pixels are drawn multiple times. If wide lines<br>
	 * intersect, the intersecting pixels are drawn only once, as though the entire<br>
	 * request were a single, filled shape.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_line_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_point_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9771</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_line_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, int, com.yi.ylwm.xcb.xcb_point_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_line_checked(Pointer c, byte coordinate_mode, int drawable, int gc, int points_len, xcb_point_t points);
	/**
	 * @brief draw lines<br>
	 * @param c The connection<br>
	 * @param coordinate_mode A bitmask of #xcb_coord_mode_t values.<br>
	 * @param coordinate_mode \n<br>
	 * @param drawable The drawable to draw the line(s) on.<br>
	 * @param gc The graphics context to use.<br>
	 * @param points_len The number of `xcb_point_t` structures in \a points.<br>
	 * @param points An array of points.<br>
	 * @return A cookie<br>
	 * Draws \a points_len-1 lines between each pair of points (point[i], point[i+1])<br>
	 * in the \a points array. The lines are drawn in the order listed in the array.<br>
	 * They join correctly at all intermediate points, and if the first and last<br>
	 * points coincide, the first and last lines also join correctly. For any given<br>
	 * line, a pixel is not drawn more than once. If thin (zero line-width) lines<br>
	 * intersect, the intersecting pixels are drawn multiple times. If wide lines<br>
	 * intersect, the intersecting pixels are drawn only once, as though the entire<br>
	 * request were a single, filled shape.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_line_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_point_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9771</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_line_checked(PointerByReference c, byte coordinate_mode, int drawable, int gc, int points_len, xcb_point_t points);
	/**
	 * @brief draw lines<br>
	 * @param c The connection<br>
	 * @param coordinate_mode A bitmask of #xcb_coord_mode_t values.<br>
	 * @param coordinate_mode \n<br>
	 * @param drawable The drawable to draw the line(s) on.<br>
	 * @param gc The graphics context to use.<br>
	 * @param points_len The number of `xcb_point_t` structures in \a points.<br>
	 * @param points An array of points.<br>
	 * @return A cookie<br>
	 * Draws \a points_len-1 lines between each pair of points (point[i], point[i+1])<br>
	 * in the \a points array. The lines are drawn in the order listed in the array.<br>
	 * They join correctly at all intermediate points, and if the first and last<br>
	 * points coincide, the first and last lines also join correctly. For any given<br>
	 * line, a pixel is not drawn more than once. If thin (zero line-width) lines<br>
	 * intersect, the intersecting pixels are drawn multiple times. If wide lines<br>
	 * intersect, the intersecting pixels are drawn only once, as though the entire<br>
	 * request were a single, filled shape.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_line(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_point_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9801</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_line(com.sun.jna.ptr.PointerByReference, byte, int, int, int, com.yi.ylwm.xcb.xcb_point_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_line(Pointer c, byte coordinate_mode, int drawable, int gc, int points_len, xcb_point_t points);
	/**
	 * @brief draw lines<br>
	 * @param c The connection<br>
	 * @param coordinate_mode A bitmask of #xcb_coord_mode_t values.<br>
	 * @param coordinate_mode \n<br>
	 * @param drawable The drawable to draw the line(s) on.<br>
	 * @param gc The graphics context to use.<br>
	 * @param points_len The number of `xcb_point_t` structures in \a points.<br>
	 * @param points An array of points.<br>
	 * @return A cookie<br>
	 * Draws \a points_len-1 lines between each pair of points (point[i], point[i+1])<br>
	 * in the \a points array. The lines are drawn in the order listed in the array.<br>
	 * They join correctly at all intermediate points, and if the first and last<br>
	 * points coincide, the first and last lines also join correctly. For any given<br>
	 * line, a pixel is not drawn more than once. If thin (zero line-width) lines<br>
	 * intersect, the intersecting pixels are drawn multiple times. If wide lines<br>
	 * intersect, the intersecting pixels are drawn only once, as though the entire<br>
	 * request were a single, filled shape.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_line(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_point_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9801</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_line(PointerByReference c, byte coordinate_mode, int drawable, int gc, int points_len, xcb_point_t points);
	/**
	 * Original signature : <code>xcb_point_t* xcb_poly_line_points(const xcb_poly_line_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9809</i>
	 */
	xcb_point_t xcb_poly_line_points(xcb_poly_line_request_t R);
	/**
	 * Original signature : <code>int xcb_poly_line_points_length(const xcb_poly_line_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9812</i>
	 */
	int xcb_poly_line_points_length(xcb_poly_line_request_t R);
	/**
	 * Original signature : <code>xcb_point_iterator_t xcb_poly_line_points_iterator(const xcb_poly_line_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9815</i>
	 */
	xcb_point_iterator_t.ByValue xcb_poly_line_points_iterator(xcb_poly_line_request_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_segment_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_segment_t)<br>
	 * Original signature : <code>void xcb_segment_next(xcb_segment_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9826</i>
	 */
	void xcb_segment_next(xcb_segment_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_segment_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_segment_end(xcb_segment_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9838</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_segment_end(xcb_segment_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_poly_segment_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9841</i>
	 */
	int xcb_poly_segment_sizeof(Pointer _buffer, int segments_len);
	/**
	 * @brief draw lines<br>
	 * @param c The connection<br>
	 * @param drawable A drawable (Window or Pixmap) to draw on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * TODO: document which attributes of a gc are used<br>
	 * @param segments_len The number of `xcb_segment_t` structures in \a segments.<br>
	 * @param segments An array of `xcb_segment_t` structures.<br>
	 * @return A cookie<br>
	 * Draws multiple, unconnected lines. For each segment, a line is drawn between<br>
	 * (x1, y1) and (x2, y2). The lines are drawn in the order listed in the array of<br>
	 * `xcb_segment_t` structures and does not perform joining at coincident<br>
	 * endpoints. For any given line, a pixel is not drawn more than once. If lines<br>
	 * intersect, the intersecting pixels are drawn multiple times.<br>
	 * <br>
	 * TODO: include the xcb_segment_t data structure<br>
	 * <br>
	 * TODO: an example<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_segment_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_segment_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9871</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_segment_checked(com.sun.jna.ptr.PointerByReference, int, int, int, com.yi.ylwm.xcb.xcb_segment_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_segment_checked(Pointer c, int drawable, int gc, int segments_len, xcb_segment_t segments);
	/**
	 * @brief draw lines<br>
	 * @param c The connection<br>
	 * @param drawable A drawable (Window or Pixmap) to draw on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * TODO: document which attributes of a gc are used<br>
	 * @param segments_len The number of `xcb_segment_t` structures in \a segments.<br>
	 * @param segments An array of `xcb_segment_t` structures.<br>
	 * @return A cookie<br>
	 * Draws multiple, unconnected lines. For each segment, a line is drawn between<br>
	 * (x1, y1) and (x2, y2). The lines are drawn in the order listed in the array of<br>
	 * `xcb_segment_t` structures and does not perform joining at coincident<br>
	 * endpoints. For any given line, a pixel is not drawn more than once. If lines<br>
	 * intersect, the intersecting pixels are drawn multiple times.<br>
	 * <br>
	 * TODO: include the xcb_segment_t data structure<br>
	 * <br>
	 * TODO: an example<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_segment_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_segment_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9871</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_segment_checked(PointerByReference c, int drawable, int gc, int segments_len, xcb_segment_t segments);
	/**
	 * @brief draw lines<br>
	 * @param c The connection<br>
	 * @param drawable A drawable (Window or Pixmap) to draw on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * TODO: document which attributes of a gc are used<br>
	 * @param segments_len The number of `xcb_segment_t` structures in \a segments.<br>
	 * @param segments An array of `xcb_segment_t` structures.<br>
	 * @return A cookie<br>
	 * Draws multiple, unconnected lines. For each segment, a line is drawn between<br>
	 * (x1, y1) and (x2, y2). The lines are drawn in the order listed in the array of<br>
	 * `xcb_segment_t` structures and does not perform joining at coincident<br>
	 * endpoints. For any given line, a pixel is not drawn more than once. If lines<br>
	 * intersect, the intersecting pixels are drawn multiple times.<br>
	 * <br>
	 * TODO: include the xcb_segment_t data structure<br>
	 * <br>
	 * TODO: an example<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_segment(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_segment_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9901</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_segment(com.sun.jna.ptr.PointerByReference, int, int, int, com.yi.ylwm.xcb.xcb_segment_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_segment(Pointer c, int drawable, int gc, int segments_len, xcb_segment_t segments);
	/**
	 * @brief draw lines<br>
	 * @param c The connection<br>
	 * @param drawable A drawable (Window or Pixmap) to draw on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * TODO: document which attributes of a gc are used<br>
	 * @param segments_len The number of `xcb_segment_t` structures in \a segments.<br>
	 * @param segments An array of `xcb_segment_t` structures.<br>
	 * @return A cookie<br>
	 * Draws multiple, unconnected lines. For each segment, a line is drawn between<br>
	 * (x1, y1) and (x2, y2). The lines are drawn in the order listed in the array of<br>
	 * `xcb_segment_t` structures and does not perform joining at coincident<br>
	 * endpoints. For any given line, a pixel is not drawn more than once. If lines<br>
	 * intersect, the intersecting pixels are drawn multiple times.<br>
	 * <br>
	 * TODO: include the xcb_segment_t data structure<br>
	 * <br>
	 * TODO: an example<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_segment(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_segment_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9901</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_segment(PointerByReference c, int drawable, int gc, int segments_len, xcb_segment_t segments);
	/**
	 * Original signature : <code>xcb_segment_t* xcb_poly_segment_segments(const xcb_poly_segment_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9908</i>
	 */
	xcb_segment_t xcb_poly_segment_segments(xcb_poly_segment_request_t R);
	/**
	 * Original signature : <code>int xcb_poly_segment_segments_length(const xcb_poly_segment_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9911</i>
	 */
	int xcb_poly_segment_segments_length(xcb_poly_segment_request_t R);
	/**
	 * Original signature : <code>xcb_segment_iterator_t xcb_poly_segment_segments_iterator(const xcb_poly_segment_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9914</i>
	 */
	xcb_segment_iterator_t.ByValue xcb_poly_segment_segments_iterator(xcb_poly_segment_request_t R);
	/**
	 * Original signature : <code>int xcb_poly_rectangle_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9917</i>
	 */
	int xcb_poly_rectangle_sizeof(Pointer _buffer, int rectangles_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_rectangle_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9932</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_rectangle_checked(com.sun.jna.ptr.PointerByReference, int, int, int, com.yi.ylwm.xcb.xcb_rectangle_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_rectangle_checked(Pointer c, int drawable, int gc, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_rectangle_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9932</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_rectangle_checked(PointerByReference c, int drawable, int gc, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_rectangle(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9947</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_rectangle(com.sun.jna.ptr.PointerByReference, int, int, int, com.yi.ylwm.xcb.xcb_rectangle_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_rectangle(Pointer c, int drawable, int gc, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_rectangle(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9947</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_rectangle(PointerByReference c, int drawable, int gc, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * Original signature : <code>xcb_rectangle_t* xcb_poly_rectangle_rectangles(const xcb_poly_rectangle_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9954</i>
	 */
	xcb_rectangle_t xcb_poly_rectangle_rectangles(xcb_poly_rectangle_request_t R);
	/**
	 * Original signature : <code>int xcb_poly_rectangle_rectangles_length(const xcb_poly_rectangle_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9957</i>
	 */
	int xcb_poly_rectangle_rectangles_length(xcb_poly_rectangle_request_t R);
	/**
	 * Original signature : <code>xcb_rectangle_iterator_t xcb_poly_rectangle_rectangles_iterator(const xcb_poly_rectangle_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9960</i>
	 */
	xcb_rectangle_iterator_t.ByValue xcb_poly_rectangle_rectangles_iterator(xcb_poly_rectangle_request_t R);
	/**
	 * Original signature : <code>int xcb_poly_arc_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9963</i>
	 */
	int xcb_poly_arc_sizeof(Pointer _buffer, int arcs_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_arc_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_arc_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9978</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_arc_checked(com.sun.jna.ptr.PointerByReference, int, int, int, com.yi.ylwm.xcb.xcb_arc_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_arc_checked(Pointer c, int drawable, int gc, int arcs_len, xcb_arc_t arcs);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_arc_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_arc_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9978</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_arc_checked(PointerByReference c, int drawable, int gc, int arcs_len, xcb_arc_t arcs);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_arc(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_arc_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9993</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_arc(com.sun.jna.ptr.PointerByReference, int, int, int, com.yi.ylwm.xcb.xcb_arc_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_arc(Pointer c, int drawable, int gc, int arcs_len, xcb_arc_t arcs);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_arc(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_arc_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:9993</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_arc(PointerByReference c, int drawable, int gc, int arcs_len, xcb_arc_t arcs);
	/**
	 * Original signature : <code>xcb_arc_t* xcb_poly_arc_arcs(const xcb_poly_arc_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10000</i>
	 */
	xcb_arc_t xcb_poly_arc_arcs(xcb_poly_arc_request_t R);
	/**
	 * Original signature : <code>int xcb_poly_arc_arcs_length(const xcb_poly_arc_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10003</i>
	 */
	int xcb_poly_arc_arcs_length(xcb_poly_arc_request_t R);
	/**
	 * Original signature : <code>xcb_arc_iterator_t xcb_poly_arc_arcs_iterator(const xcb_poly_arc_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10006</i>
	 */
	xcb_arc_iterator_t.ByValue xcb_poly_arc_arcs_iterator(xcb_poly_arc_request_t R);
	/**
	 * Original signature : <code>int xcb_fill_poly_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10009</i>
	 */
	int xcb_fill_poly_sizeof(Pointer _buffer, int points_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_fill_poly_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint8_t, uint8_t, uint32_t, const xcb_point_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10024</i><br>
	 * @deprecated use the safer method {@link #xcb_fill_poly_checked(com.sun.jna.ptr.PointerByReference, int, int, byte, byte, int, com.yi.ylwm.xcb.xcb_point_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_fill_poly_checked(Pointer c, int drawable, int gc, byte shape, byte coordinate_mode, int points_len, xcb_point_t points);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_fill_poly_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint8_t, uint8_t, uint32_t, const xcb_point_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10024</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_fill_poly_checked(PointerByReference c, int drawable, int gc, byte shape, byte coordinate_mode, int points_len, xcb_point_t points);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_fill_poly(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint8_t, uint8_t, uint32_t, const xcb_point_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10041</i><br>
	 * @deprecated use the safer method {@link #xcb_fill_poly(com.sun.jna.ptr.PointerByReference, int, int, byte, byte, int, com.yi.ylwm.xcb.xcb_point_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_fill_poly(Pointer c, int drawable, int gc, byte shape, byte coordinate_mode, int points_len, xcb_point_t points);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_fill_poly(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint8_t, uint8_t, uint32_t, const xcb_point_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10041</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_fill_poly(PointerByReference c, int drawable, int gc, byte shape, byte coordinate_mode, int points_len, xcb_point_t points);
	/**
	 * Original signature : <code>xcb_point_t* xcb_fill_poly_points(const xcb_fill_poly_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10050</i>
	 */
	xcb_point_t xcb_fill_poly_points(xcb_fill_poly_request_t R);
	/**
	 * Original signature : <code>int xcb_fill_poly_points_length(const xcb_fill_poly_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10053</i>
	 */
	int xcb_fill_poly_points_length(xcb_fill_poly_request_t R);
	/**
	 * Original signature : <code>xcb_point_iterator_t xcb_fill_poly_points_iterator(const xcb_fill_poly_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10056</i>
	 */
	xcb_point_iterator_t.ByValue xcb_fill_poly_points_iterator(xcb_fill_poly_request_t R);
	/**
	 * Original signature : <code>int xcb_poly_fill_rectangle_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10059</i>
	 */
	int xcb_poly_fill_rectangle_sizeof(Pointer _buffer, int rectangles_len);
	/**
	 * @brief Fills rectangles<br>
	 * @param c The connection<br>
	 * @param drawable The drawable (Window or Pixmap) to draw on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: function, plane-mask,<br>
	 * fill-style, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * \n<br>
	 * The following graphics context mode-dependent components are used:<br>
	 * foreground, background, tile, stipple, tile-stipple-x-origin, and<br>
	 * tile-stipple-y-origin.<br>
	 * @param rectangles_len The number of `xcb_rectangle_t` structures in \a rectangles.<br>
	 * @param rectangles The rectangles to fill.<br>
	 * @return A cookie<br>
	 * Fills the specified rectangle(s) in the order listed in the array. For any<br>
	 * given rectangle, each pixel is not drawn more than once. If rectangles<br>
	 * intersect, the intersecting pixels are drawn multiple times.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_fill_rectangle_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10088</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_fill_rectangle_checked(com.sun.jna.ptr.PointerByReference, int, int, int, com.yi.ylwm.xcb.xcb_rectangle_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_fill_rectangle_checked(Pointer c, int drawable, int gc, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * @brief Fills rectangles<br>
	 * @param c The connection<br>
	 * @param drawable The drawable (Window or Pixmap) to draw on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: function, plane-mask,<br>
	 * fill-style, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * \n<br>
	 * The following graphics context mode-dependent components are used:<br>
	 * foreground, background, tile, stipple, tile-stipple-x-origin, and<br>
	 * tile-stipple-y-origin.<br>
	 * @param rectangles_len The number of `xcb_rectangle_t` structures in \a rectangles.<br>
	 * @param rectangles The rectangles to fill.<br>
	 * @return A cookie<br>
	 * Fills the specified rectangle(s) in the order listed in the array. For any<br>
	 * given rectangle, each pixel is not drawn more than once. If rectangles<br>
	 * intersect, the intersecting pixels are drawn multiple times.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_fill_rectangle_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10088</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_fill_rectangle_checked(PointerByReference c, int drawable, int gc, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * @brief Fills rectangles<br>
	 * @param c The connection<br>
	 * @param drawable The drawable (Window or Pixmap) to draw on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: function, plane-mask,<br>
	 * fill-style, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * \n<br>
	 * The following graphics context mode-dependent components are used:<br>
	 * foreground, background, tile, stipple, tile-stipple-x-origin, and<br>
	 * tile-stipple-y-origin.<br>
	 * @param rectangles_len The number of `xcb_rectangle_t` structures in \a rectangles.<br>
	 * @param rectangles The rectangles to fill.<br>
	 * @return A cookie<br>
	 * Fills the specified rectangle(s) in the order listed in the array. For any<br>
	 * given rectangle, each pixel is not drawn more than once. If rectangles<br>
	 * intersect, the intersecting pixels are drawn multiple times.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_fill_rectangle(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10117</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_fill_rectangle(com.sun.jna.ptr.PointerByReference, int, int, int, com.yi.ylwm.xcb.xcb_rectangle_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_fill_rectangle(Pointer c, int drawable, int gc, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * @brief Fills rectangles<br>
	 * @param c The connection<br>
	 * @param drawable The drawable (Window or Pixmap) to draw on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: function, plane-mask,<br>
	 * fill-style, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * \n<br>
	 * The following graphics context mode-dependent components are used:<br>
	 * foreground, background, tile, stipple, tile-stipple-x-origin, and<br>
	 * tile-stipple-y-origin.<br>
	 * @param rectangles_len The number of `xcb_rectangle_t` structures in \a rectangles.<br>
	 * @param rectangles The rectangles to fill.<br>
	 * @return A cookie<br>
	 * Fills the specified rectangle(s) in the order listed in the array. For any<br>
	 * given rectangle, each pixel is not drawn more than once. If rectangles<br>
	 * intersect, the intersecting pixels are drawn multiple times.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_fill_rectangle(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_rectangle_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10117</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_fill_rectangle(PointerByReference c, int drawable, int gc, int rectangles_len, xcb_rectangle_t rectangles);
	/**
	 * Original signature : <code>xcb_rectangle_t* xcb_poly_fill_rectangle_rectangles(const xcb_poly_fill_rectangle_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10124</i>
	 */
	xcb_rectangle_t xcb_poly_fill_rectangle_rectangles(xcb_poly_fill_rectangle_request_t R);
	/**
	 * Original signature : <code>int xcb_poly_fill_rectangle_rectangles_length(const xcb_poly_fill_rectangle_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10127</i>
	 */
	int xcb_poly_fill_rectangle_rectangles_length(xcb_poly_fill_rectangle_request_t R);
	/**
	 * Original signature : <code>xcb_rectangle_iterator_t xcb_poly_fill_rectangle_rectangles_iterator(const xcb_poly_fill_rectangle_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10130</i>
	 */
	xcb_rectangle_iterator_t.ByValue xcb_poly_fill_rectangle_rectangles_iterator(xcb_poly_fill_rectangle_request_t R);
	/**
	 * Original signature : <code>int xcb_poly_fill_arc_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10133</i>
	 */
	int xcb_poly_fill_arc_sizeof(Pointer _buffer, int arcs_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_fill_arc_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_arc_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10148</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_fill_arc_checked(com.sun.jna.ptr.PointerByReference, int, int, int, com.yi.ylwm.xcb.xcb_arc_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_fill_arc_checked(Pointer c, int drawable, int gc, int arcs_len, xcb_arc_t arcs);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_fill_arc_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_arc_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10148</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_fill_arc_checked(PointerByReference c, int drawable, int gc, int arcs_len, xcb_arc_t arcs);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_fill_arc(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_arc_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10163</i><br>
	 * @deprecated use the safer method {@link #xcb_poly_fill_arc(com.sun.jna.ptr.PointerByReference, int, int, int, com.yi.ylwm.xcb.xcb_arc_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_fill_arc(Pointer c, int drawable, int gc, int arcs_len, xcb_arc_t arcs);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_fill_arc(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, uint32_t, const xcb_arc_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10163</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_fill_arc(PointerByReference c, int drawable, int gc, int arcs_len, xcb_arc_t arcs);
	/**
	 * Original signature : <code>xcb_arc_t* xcb_poly_fill_arc_arcs(const xcb_poly_fill_arc_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10170</i>
	 */
	xcb_arc_t xcb_poly_fill_arc_arcs(xcb_poly_fill_arc_request_t R);
	/**
	 * Original signature : <code>int xcb_poly_fill_arc_arcs_length(const xcb_poly_fill_arc_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10173</i>
	 */
	int xcb_poly_fill_arc_arcs_length(xcb_poly_fill_arc_request_t R);
	/**
	 * Original signature : <code>xcb_arc_iterator_t xcb_poly_fill_arc_arcs_iterator(const xcb_poly_fill_arc_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10176</i>
	 */
	xcb_arc_iterator_t.ByValue xcb_poly_fill_arc_arcs_iterator(xcb_poly_fill_arc_request_t R);
	/**
	 * Original signature : <code>int xcb_put_image_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10179</i>
	 */
	int xcb_put_image_sizeof(Pointer _buffer, int data_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_put_image_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint16_t, uint16_t, int16_t, int16_t, uint8_t, uint8_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10194</i><br>
	 * @deprecated use the safer methods {@link #xcb_put_image_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, short, short, byte, byte, int, byte[])} and {@link #xcb_put_image_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, short, short, byte, byte, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_put_image_checked(Pointer c, byte format, int drawable, int gc, short width, short height, short dst_x, short dst_y, byte left_pad, byte depth, int data_len, Pointer data);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_put_image_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint16_t, uint16_t, int16_t, int16_t, uint8_t, uint8_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10194</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_put_image_checked(PointerByReference c, byte format, int drawable, int gc, short width, short height, short dst_x, short dst_y, byte left_pad, byte depth, int data_len, byte data[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_put_image_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint16_t, uint16_t, int16_t, int16_t, uint8_t, uint8_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10194</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_put_image_checked(PointerByReference c, byte format, int drawable, int gc, short width, short height, short dst_x, short dst_y, byte left_pad, byte depth, int data_len, Pointer data);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_put_image(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint16_t, uint16_t, int16_t, int16_t, uint8_t, uint8_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10216</i><br>
	 * @deprecated use the safer methods {@link #xcb_put_image(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, short, short, byte, byte, int, byte[])} and {@link #xcb_put_image(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, short, short, byte, byte, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_put_image(Pointer c, byte format, int drawable, int gc, short width, short height, short dst_x, short dst_y, byte left_pad, byte depth, int data_len, Pointer data);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_put_image(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint16_t, uint16_t, int16_t, int16_t, uint8_t, uint8_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10216</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_put_image(PointerByReference c, byte format, int drawable, int gc, short width, short height, short dst_x, short dst_y, byte left_pad, byte depth, int data_len, byte data[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_put_image(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, uint16_t, uint16_t, int16_t, int16_t, uint8_t, uint8_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10216</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_put_image(PointerByReference c, byte format, int drawable, int gc, short width, short height, short dst_x, short dst_y, byte left_pad, byte depth, int data_len, Pointer data);
	/**
	 * Original signature : <code>uint8_t* xcb_put_image_data(const xcb_put_image_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10230</i>
	 */
	Pointer xcb_put_image_data(xcb_put_image_request_t R);
	/**
	 * Original signature : <code>int xcb_put_image_data_length(const xcb_put_image_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10233</i>
	 */
	int xcb_put_image_data_length(xcb_put_image_request_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_put_image_data_end(const xcb_put_image_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10236</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_put_image_data_end(xcb_put_image_request_t R);
	/**
	 * Original signature : <code>int xcb_get_image_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10239</i>
	 */
	int xcb_get_image_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_image_cookie_t xcb_get_image(xcb_connection_t*, uint8_t, xcb_drawable_t, int16_t, int16_t, uint16_t, uint16_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10250</i><br>
	 * @deprecated use the safer method {@link #xcb_get_image(com.sun.jna.ptr.PointerByReference, byte, int, short, short, short, short, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_image_cookie_t.ByValue xcb_get_image(Pointer c, byte format, int drawable, short x, short y, short width, short height, int plane_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_image_cookie_t xcb_get_image(xcb_connection_t*, uint8_t, xcb_drawable_t, int16_t, int16_t, uint16_t, uint16_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10250</i>
	 */
	com.yi.ylwm.xcb.xcb_get_image_cookie_t.ByValue xcb_get_image(PointerByReference c, byte format, int drawable, short x, short y, short width, short height, int plane_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_image_cookie_t xcb_get_image_unchecked(xcb_connection_t*, uint8_t, xcb_drawable_t, int16_t, int16_t, uint16_t, uint16_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10271</i><br>
	 * @deprecated use the safer method {@link #xcb_get_image_unchecked(com.sun.jna.ptr.PointerByReference, byte, int, short, short, short, short, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_image_cookie_t.ByValue xcb_get_image_unchecked(Pointer c, byte format, int drawable, short x, short y, short width, short height, int plane_mask);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_image_cookie_t xcb_get_image_unchecked(xcb_connection_t*, uint8_t, xcb_drawable_t, int16_t, int16_t, uint16_t, uint16_t, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10271</i>
	 */
	com.yi.ylwm.xcb.xcb_get_image_cookie_t.ByValue xcb_get_image_unchecked(PointerByReference c, byte format, int drawable, short x, short y, short width, short height, int plane_mask);
	/**
	 * Original signature : <code>uint8_t* xcb_get_image_data(const xcb_get_image_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10281</i>
	 */
	Pointer xcb_get_image_data(xcb_get_image_reply_t R);
	/**
	 * Original signature : <code>int xcb_get_image_data_length(const xcb_get_image_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10284</i>
	 */
	int xcb_get_image_data_length(xcb_get_image_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_get_image_data_end(const xcb_get_image_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10287</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_get_image_data_end(xcb_get_image_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_image_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_image_reply_t* xcb_get_image_reply(xcb_connection_t*, xcb_get_image_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10304</i><br>
	 * @deprecated use the safer method {@link #xcb_get_image_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_get_image_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_image_reply_t xcb_get_image_reply(Pointer c, com.yi.ylwm.xcb.xcb_get_image_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_image_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_image_reply_t* xcb_get_image_reply(xcb_connection_t*, xcb_get_image_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10304</i>
	 */
	xcb_get_image_reply_t xcb_get_image_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_get_image_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_poly_text_8_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10309</i>
	 */
	int xcb_poly_text_8_sizeof(Pointer _buffer, int items_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_8_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10324</i><br>
	 * @deprecated use the safer methods {@link #xcb_poly_text_8_checked(com.sun.jna.ptr.PointerByReference, int, int, short, short, int, byte[])} and {@link #xcb_poly_text_8_checked(com.sun.jna.ptr.PointerByReference, int, int, short, short, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_text_8_checked(Pointer c, int drawable, int gc, short x, short y, int items_len, Pointer items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_8_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10324</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_text_8_checked(PointerByReference c, int drawable, int gc, short x, short y, int items_len, byte items[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_8_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10324</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_text_8_checked(PointerByReference c, int drawable, int gc, short x, short y, int items_len, Pointer items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_8(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10341</i><br>
	 * @deprecated use the safer methods {@link #xcb_poly_text_8(com.sun.jna.ptr.PointerByReference, int, int, short, short, int, byte[])} and {@link #xcb_poly_text_8(com.sun.jna.ptr.PointerByReference, int, int, short, short, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_text_8(Pointer c, int drawable, int gc, short x, short y, int items_len, Pointer items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_8(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10341</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_text_8(PointerByReference c, int drawable, int gc, short x, short y, int items_len, byte items[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_8(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10341</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_text_8(PointerByReference c, int drawable, int gc, short x, short y, int items_len, Pointer items);
	/**
	 * Original signature : <code>uint8_t* xcb_poly_text_8_items(const xcb_poly_text_8_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10350</i>
	 */
	Pointer xcb_poly_text_8_items(xcb_poly_text_8_request_t R);
	/**
	 * Original signature : <code>int xcb_poly_text_8_items_length(const xcb_poly_text_8_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10353</i>
	 */
	int xcb_poly_text_8_items_length(xcb_poly_text_8_request_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_poly_text_8_items_end(const xcb_poly_text_8_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10356</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_poly_text_8_items_end(xcb_poly_text_8_request_t R);
	/**
	 * Original signature : <code>int xcb_poly_text_16_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10359</i>
	 */
	int xcb_poly_text_16_sizeof(Pointer _buffer, int items_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_16_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10374</i><br>
	 * @deprecated use the safer methods {@link #xcb_poly_text_16_checked(com.sun.jna.ptr.PointerByReference, int, int, short, short, int, byte[])} and {@link #xcb_poly_text_16_checked(com.sun.jna.ptr.PointerByReference, int, int, short, short, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_text_16_checked(Pointer c, int drawable, int gc, short x, short y, int items_len, Pointer items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_16_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10374</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_text_16_checked(PointerByReference c, int drawable, int gc, short x, short y, int items_len, byte items[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_16_checked(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10374</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_text_16_checked(PointerByReference c, int drawable, int gc, short x, short y, int items_len, Pointer items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_16(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10391</i><br>
	 * @deprecated use the safer methods {@link #xcb_poly_text_16(com.sun.jna.ptr.PointerByReference, int, int, short, short, int, byte[])} and {@link #xcb_poly_text_16(com.sun.jna.ptr.PointerByReference, int, int, short, short, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_text_16(Pointer c, int drawable, int gc, short x, short y, int items_len, Pointer items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_16(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10391</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_text_16(PointerByReference c, int drawable, int gc, short x, short y, int items_len, byte items[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_poly_text_16(xcb_connection_t*, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, uint32_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10391</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_poly_text_16(PointerByReference c, int drawable, int gc, short x, short y, int items_len, Pointer items);
	/**
	 * Original signature : <code>uint8_t* xcb_poly_text_16_items(const xcb_poly_text_16_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10400</i>
	 */
	Pointer xcb_poly_text_16_items(xcb_poly_text_16_request_t R);
	/**
	 * Original signature : <code>int xcb_poly_text_16_items_length(const xcb_poly_text_16_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10403</i>
	 */
	int xcb_poly_text_16_items_length(xcb_poly_text_16_request_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_poly_text_16_items_end(const xcb_poly_text_16_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10406</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_poly_text_16_items_end(xcb_poly_text_16_request_t R);
	/**
	 * Original signature : <code>int xcb_image_text_8_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10409</i>
	 */
	int xcb_image_text_8_sizeof(Pointer _buffer);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string. Note that this parameter limited by 255 due to<br>
	 * using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len.<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_8_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10442</i><br>
	 * @deprecated use the safer methods {@link #xcb_image_text_8_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, java.lang.String)} and {@link #xcb_image_text_8_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_image_text_8_checked(Pointer c, byte string_len, int drawable, int gc, short x, short y, Pointer string);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string. Note that this parameter limited by 255 due to<br>
	 * using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len.<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_8_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10442</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_image_text_8_checked(PointerByReference c, byte string_len, int drawable, int gc, short x, short y, String string);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string. Note that this parameter limited by 255 due to<br>
	 * using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len.<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_8_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10442</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_image_text_8_checked(PointerByReference c, byte string_len, int drawable, int gc, short x, short y, Pointer string);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string. Note that this parameter limited by 255 due to<br>
	 * using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len.<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_8(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10478</i><br>
	 * @deprecated use the safer methods {@link #xcb_image_text_8(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, java.lang.String)} and {@link #xcb_image_text_8(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_image_text_8(Pointer c, byte string_len, int drawable, int gc, short x, short y, Pointer string);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string. Note that this parameter limited by 255 due to<br>
	 * using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len.<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_8(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10478</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_image_text_8(PointerByReference c, byte string_len, int drawable, int gc, short x, short y, String string);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string. Note that this parameter limited by 255 due to<br>
	 * using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len.<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_8(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10478</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_image_text_8(PointerByReference c, byte string_len, int drawable, int gc, short x, short y, Pointer string);
	/**
	 * Original signature : <code>char* xcb_image_text_8_string(const xcb_image_text_8_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10487</i>
	 */
	Pointer xcb_image_text_8_string(xcb_image_text_8_request_t R);
	/**
	 * Original signature : <code>int xcb_image_text_8_string_length(const xcb_image_text_8_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10490</i>
	 */
	int xcb_image_text_8_string_length(xcb_image_text_8_request_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_image_text_8_string_end(const xcb_image_text_8_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10493</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_image_text_8_string_end(xcb_image_text_8_request_t R);
	/**
	 * Original signature : <code>int xcb_image_text_16_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10496</i>
	 */
	int xcb_image_text_16_sizeof(Pointer _buffer);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string in characters. Note that this parameter limited by<br>
	 * 255 due to using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len. Every character uses 2 bytes (hence the 16 in this<br>
	 * request's name).<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_16_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const xcb_char2b_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10530</i><br>
	 * @deprecated use the safer method {@link #xcb_image_text_16_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, com.yi.ylwm.xcb.xcb_char2b_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_image_text_16_checked(Pointer c, byte string_len, int drawable, int gc, short x, short y, xcb_char2b_t string);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string in characters. Note that this parameter limited by<br>
	 * 255 due to using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len. Every character uses 2 bytes (hence the 16 in this<br>
	 * request's name).<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_16_checked(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const xcb_char2b_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10530</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_image_text_16_checked(PointerByReference c, byte string_len, int drawable, int gc, short x, short y, xcb_char2b_t string);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string in characters. Note that this parameter limited by<br>
	 * 255 due to using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len. Every character uses 2 bytes (hence the 16 in this<br>
	 * request's name).<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_16(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const xcb_char2b_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10567</i><br>
	 * @deprecated use the safer method {@link #xcb_image_text_16(com.sun.jna.ptr.PointerByReference, byte, int, int, short, short, com.yi.ylwm.xcb.xcb_char2b_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_image_text_16(Pointer c, byte string_len, int drawable, int gc, short x, short y, xcb_char2b_t string);
	/**
	 * @brief Draws text<br>
	 * @param c The connection<br>
	 * @param string_len The length of the \a string in characters. Note that this parameter limited by<br>
	 * 255 due to using 8 bits!<br>
	 * @param drawable The drawable (Window or Pixmap) to draw text on.<br>
	 * @param gc The graphics context to use.<br>
	 * \n<br>
	 * The following graphics context components are used: plane-mask, foreground,<br>
	 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.<br>
	 * @param x The x coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param y The y coordinate of the first character, relative to the origin of \a drawable.<br>
	 * @param string The string to draw. Only the first 255 characters are relevant due to the data<br>
	 * type of \a string_len. Every character uses 2 bytes (hence the 16 in this<br>
	 * request's name).<br>
	 * @return A cookie<br>
	 * Fills the destination rectangle with the background pixel from \a gc, then<br>
	 * paints the text with the foreground pixel from \a gc. The upper-left corner of<br>
	 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,<br>
	 * the height is font-ascent + font-descent. The overall-width, font-ascent and<br>
	 * font-descent are as returned by `xcb_query_text_extents` (TODO).<br>
	 * <br>
	 * Note that using X core fonts is deprecated (but still supported) in favor of<br>
	 * client-side rendering using Xft.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_image_text_16(xcb_connection_t*, uint8_t, xcb_drawable_t, xcb_gcontext_t, int16_t, int16_t, const xcb_char2b_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10567</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_image_text_16(PointerByReference c, byte string_len, int drawable, int gc, short x, short y, xcb_char2b_t string);
	/**
	 * Original signature : <code>xcb_char2b_t* xcb_image_text_16_string(const xcb_image_text_16_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10576</i>
	 */
	xcb_char2b_t xcb_image_text_16_string(xcb_image_text_16_request_t R);
	/**
	 * Original signature : <code>int xcb_image_text_16_string_length(const xcb_image_text_16_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10579</i>
	 */
	int xcb_image_text_16_string_length(xcb_image_text_16_request_t R);
	/**
	 * Original signature : <code>xcb_char2b_iterator_t xcb_image_text_16_string_iterator(const xcb_image_text_16_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10582</i>
	 */
	xcb_char2b_iterator_t.ByValue xcb_image_text_16_string_iterator(xcb_image_text_16_request_t R);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_colormap_checked(xcb_connection_t*, uint8_t, xcb_colormap_t, xcb_window_t, xcb_visualid_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10596</i><br>
	 * @deprecated use the safer method {@link #xcb_create_colormap_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_colormap_checked(Pointer c, byte alloc, int mid, int window, int visual);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_colormap_checked(xcb_connection_t*, uint8_t, xcb_colormap_t, xcb_window_t, xcb_visualid_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10596</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_colormap_checked(PointerByReference c, byte alloc, int mid, int window, int visual);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_colormap(xcb_connection_t*, uint8_t, xcb_colormap_t, xcb_window_t, xcb_visualid_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10611</i><br>
	 * @deprecated use the safer method {@link #xcb_create_colormap(com.sun.jna.ptr.PointerByReference, byte, int, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_colormap(Pointer c, byte alloc, int mid, int window, int visual);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_colormap(xcb_connection_t*, uint8_t, xcb_colormap_t, xcb_window_t, xcb_visualid_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10611</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_colormap(PointerByReference c, byte alloc, int mid, int window, int visual);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colormap_checked(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10629</i><br>
	 * @deprecated use the safer method {@link #xcb_free_colormap_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_colormap_checked(Pointer c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colormap_checked(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10629</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_colormap_checked(PointerByReference c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colormap(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10641</i><br>
	 * @deprecated use the safer method {@link #xcb_free_colormap(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_colormap(Pointer c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colormap(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10641</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_colormap(PointerByReference c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_colormap_and_free_checked(xcb_connection_t*, xcb_colormap_t, xcb_colormap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10656</i><br>
	 * @deprecated use the safer method {@link #xcb_copy_colormap_and_free_checked(com.sun.jna.ptr.PointerByReference, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_copy_colormap_and_free_checked(Pointer c, int mid, int src_cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_colormap_and_free_checked(xcb_connection_t*, xcb_colormap_t, xcb_colormap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10656</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_copy_colormap_and_free_checked(PointerByReference c, int mid, int src_cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_colormap_and_free(xcb_connection_t*, xcb_colormap_t, xcb_colormap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10669</i><br>
	 * @deprecated use the safer method {@link #xcb_copy_colormap_and_free(com.sun.jna.ptr.PointerByReference, int, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_copy_colormap_and_free(Pointer c, int mid, int src_cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_copy_colormap_and_free(xcb_connection_t*, xcb_colormap_t, xcb_colormap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10669</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_copy_colormap_and_free(PointerByReference c, int mid, int src_cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_install_colormap_checked(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10685</i><br>
	 * @deprecated use the safer method {@link #xcb_install_colormap_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_install_colormap_checked(Pointer c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_install_colormap_checked(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10685</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_install_colormap_checked(PointerByReference c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_install_colormap(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10697</i><br>
	 * @deprecated use the safer method {@link #xcb_install_colormap(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_install_colormap(Pointer c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_install_colormap(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10697</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_install_colormap(PointerByReference c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_uninstall_colormap_checked(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10712</i><br>
	 * @deprecated use the safer method {@link #xcb_uninstall_colormap_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_uninstall_colormap_checked(Pointer c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_uninstall_colormap_checked(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10712</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_uninstall_colormap_checked(PointerByReference c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_uninstall_colormap(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10724</i><br>
	 * @deprecated use the safer method {@link #xcb_uninstall_colormap(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_uninstall_colormap(Pointer c, int cmap);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_uninstall_colormap(xcb_connection_t*, xcb_colormap_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10724</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_uninstall_colormap(PointerByReference c, int cmap);
	/**
	 * Original signature : <code>int xcb_list_installed_colormaps_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10728</i>
	 */
	int xcb_list_installed_colormaps_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_list_installed_colormaps_cookie_t xcb_list_installed_colormaps(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10739</i><br>
	 * @deprecated use the safer method {@link #xcb_list_installed_colormaps(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_list_installed_colormaps_cookie_t.ByValue xcb_list_installed_colormaps(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_list_installed_colormaps_cookie_t xcb_list_installed_colormaps(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10739</i>
	 */
	com.yi.ylwm.xcb.xcb_list_installed_colormaps_cookie_t.ByValue xcb_list_installed_colormaps(PointerByReference c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_installed_colormaps_cookie_t xcb_list_installed_colormaps_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10754</i><br>
	 * @deprecated use the safer method {@link #xcb_list_installed_colormaps_unchecked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_list_installed_colormaps_cookie_t.ByValue xcb_list_installed_colormaps_unchecked(Pointer c, int window);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_installed_colormaps_cookie_t xcb_list_installed_colormaps_unchecked(xcb_connection_t*, xcb_window_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10754</i>
	 */
	com.yi.ylwm.xcb.xcb_list_installed_colormaps_cookie_t.ByValue xcb_list_installed_colormaps_unchecked(PointerByReference c, int window);
	/**
	 * Original signature : <code>xcb_colormap_t* xcb_list_installed_colormaps_cmaps(const xcb_list_installed_colormaps_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10758</i>
	 */
	IntByReference xcb_list_installed_colormaps_cmaps(xcb_list_installed_colormaps_reply_t R);
	/**
	 * Original signature : <code>int xcb_list_installed_colormaps_cmaps_length(const xcb_list_installed_colormaps_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10761</i>
	 */
	int xcb_list_installed_colormaps_cmaps_length(xcb_list_installed_colormaps_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_list_installed_colormaps_cmaps_end(const xcb_list_installed_colormaps_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10764</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_list_installed_colormaps_cmaps_end(xcb_list_installed_colormaps_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_installed_colormaps_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_installed_colormaps_reply_t* xcb_list_installed_colormaps_reply(xcb_connection_t*, xcb_list_installed_colormaps_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10781</i><br>
	 * @deprecated use the safer method {@link #xcb_list_installed_colormaps_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_list_installed_colormaps_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_list_installed_colormaps_reply_t xcb_list_installed_colormaps_reply(Pointer c, com.yi.ylwm.xcb.xcb_list_installed_colormaps_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_installed_colormaps_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_installed_colormaps_reply_t* xcb_list_installed_colormaps_reply(xcb_connection_t*, xcb_list_installed_colormaps_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10781</i>
	 */
	xcb_list_installed_colormaps_reply_t xcb_list_installed_colormaps_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_list_installed_colormaps_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * @brief Allocate a color<br>
	 * @param c The connection<br>
	 * @param cmap TODO<br>
	 * @param red The red value of your color.<br>
	 * @param green The green value of your color.<br>
	 * @param blue The blue value of your color.<br>
	 * @return A cookie<br>
	 * Allocates a read-only colormap entry corresponding to the closest RGB value<br>
	 * supported by the hardware. If you are using TrueColor, you can take a shortcut<br>
	 * and directly calculate the color pixel value to avoid the round trip. But, for<br>
	 * example, on 16-bit color setups (VNC), you can easily get the closest supported<br>
	 * RGB value to the RGB value you are specifying.<br>
	 * Original signature : <code>xcb_alloc_color_cookie_t xcb_alloc_color(xcb_connection_t*, xcb_colormap_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10803</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color(com.sun.jna.ptr.PointerByReference, int, short, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_alloc_color_cookie_t.ByValue xcb_alloc_color(Pointer c, int cmap, short red, short green, short blue);
	/**
	 * @brief Allocate a color<br>
	 * @param c The connection<br>
	 * @param cmap TODO<br>
	 * @param red The red value of your color.<br>
	 * @param green The green value of your color.<br>
	 * @param blue The blue value of your color.<br>
	 * @return A cookie<br>
	 * Allocates a read-only colormap entry corresponding to the closest RGB value<br>
	 * supported by the hardware. If you are using TrueColor, you can take a shortcut<br>
	 * and directly calculate the color pixel value to avoid the round trip. But, for<br>
	 * example, on 16-bit color setups (VNC), you can easily get the closest supported<br>
	 * RGB value to the RGB value you are specifying.<br>
	 * Original signature : <code>xcb_alloc_color_cookie_t xcb_alloc_color(xcb_connection_t*, xcb_colormap_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10803</i>
	 */
	com.yi.ylwm.xcb.xcb_alloc_color_cookie_t.ByValue xcb_alloc_color(PointerByReference c, int cmap, short red, short green, short blue);
	/**
	 * @brief Allocate a color<br>
	 * @param c The connection<br>
	 * @param cmap TODO<br>
	 * @param red The red value of your color.<br>
	 * @param green The green value of your color.<br>
	 * @param blue The blue value of your color.<br>
	 * @return A cookie<br>
	 * Allocates a read-only colormap entry corresponding to the closest RGB value<br>
	 * supported by the hardware. If you are using TrueColor, you can take a shortcut<br>
	 * and directly calculate the color pixel value to avoid the round trip. But, for<br>
	 * example, on 16-bit color setups (VNC), you can easily get the closest supported<br>
	 * RGB value to the RGB value you are specifying.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_color_cookie_t xcb_alloc_color_unchecked(xcb_connection_t*, xcb_colormap_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10830</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color_unchecked(com.sun.jna.ptr.PointerByReference, int, short, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_alloc_color_cookie_t.ByValue xcb_alloc_color_unchecked(Pointer c, int cmap, short red, short green, short blue);
	/**
	 * @brief Allocate a color<br>
	 * @param c The connection<br>
	 * @param cmap TODO<br>
	 * @param red The red value of your color.<br>
	 * @param green The green value of your color.<br>
	 * @param blue The blue value of your color.<br>
	 * @return A cookie<br>
	 * Allocates a read-only colormap entry corresponding to the closest RGB value<br>
	 * supported by the hardware. If you are using TrueColor, you can take a shortcut<br>
	 * and directly calculate the color pixel value to avoid the round trip. But, for<br>
	 * example, on 16-bit color setups (VNC), you can easily get the closest supported<br>
	 * RGB value to the RGB value you are specifying.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_color_cookie_t xcb_alloc_color_unchecked(xcb_connection_t*, xcb_colormap_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10830</i>
	 */
	com.yi.ylwm.xcb.xcb_alloc_color_cookie_t.ByValue xcb_alloc_color_unchecked(PointerByReference c, int cmap, short red, short green, short blue);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_alloc_color_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_alloc_color_reply_t* xcb_alloc_color_reply(xcb_connection_t*, xcb_alloc_color_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10851</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_alloc_color_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_alloc_color_reply_t xcb_alloc_color_reply(Pointer c, com.yi.ylwm.xcb.xcb_alloc_color_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_alloc_color_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_alloc_color_reply_t* xcb_alloc_color_reply(xcb_connection_t*, xcb_alloc_color_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10851</i>
	 */
	xcb_alloc_color_reply_t xcb_alloc_color_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_alloc_color_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_alloc_named_color_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10856</i>
	 */
	int xcb_alloc_named_color_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_alloc_named_color_cookie_t xcb_alloc_named_color(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10867</i><br>
	 * @deprecated use the safer methods {@link #xcb_alloc_named_color(com.sun.jna.ptr.PointerByReference, int, short, java.lang.String)} and {@link #xcb_alloc_named_color(com.sun.jna.ptr.PointerByReference, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_alloc_named_color_cookie_t.ByValue xcb_alloc_named_color(Pointer c, int cmap, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_alloc_named_color_cookie_t xcb_alloc_named_color(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10867</i>
	 */
	com.yi.ylwm.xcb.xcb_alloc_named_color_cookie_t.ByValue xcb_alloc_named_color(PointerByReference c, int cmap, short name_len, String name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_alloc_named_color_cookie_t xcb_alloc_named_color(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10867</i>
	 */
	com.yi.ylwm.xcb.xcb_alloc_named_color_cookie_t.ByValue xcb_alloc_named_color(PointerByReference c, int cmap, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_named_color_cookie_t xcb_alloc_named_color_unchecked(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10884</i><br>
	 * @deprecated use the safer methods {@link #xcb_alloc_named_color_unchecked(com.sun.jna.ptr.PointerByReference, int, short, java.lang.String)} and {@link #xcb_alloc_named_color_unchecked(com.sun.jna.ptr.PointerByReference, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_alloc_named_color_cookie_t.ByValue xcb_alloc_named_color_unchecked(Pointer c, int cmap, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_named_color_cookie_t xcb_alloc_named_color_unchecked(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10884</i>
	 */
	com.yi.ylwm.xcb.xcb_alloc_named_color_cookie_t.ByValue xcb_alloc_named_color_unchecked(PointerByReference c, int cmap, short name_len, String name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_named_color_cookie_t xcb_alloc_named_color_unchecked(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10884</i>
	 */
	com.yi.ylwm.xcb.xcb_alloc_named_color_cookie_t.ByValue xcb_alloc_named_color_unchecked(PointerByReference c, int cmap, short name_len, Pointer name);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_alloc_named_color_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_alloc_named_color_reply_t* xcb_alloc_named_color_reply(xcb_connection_t*, xcb_alloc_named_color_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10904</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_named_color_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_alloc_named_color_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_alloc_named_color_reply_t xcb_alloc_named_color_reply(Pointer c, com.yi.ylwm.xcb.xcb_alloc_named_color_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_alloc_named_color_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_alloc_named_color_reply_t* xcb_alloc_named_color_reply(xcb_connection_t*, xcb_alloc_named_color_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10904</i>
	 */
	xcb_alloc_named_color_reply_t xcb_alloc_named_color_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_alloc_named_color_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_alloc_color_cells_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10909</i>
	 */
	int xcb_alloc_color_cells_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_alloc_color_cells_cookie_t xcb_alloc_color_cells(xcb_connection_t*, uint8_t, xcb_colormap_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10920</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color_cells(com.sun.jna.ptr.PointerByReference, byte, int, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_alloc_color_cells_cookie_t.ByValue xcb_alloc_color_cells(Pointer c, byte contiguous, int cmap, short colors, short planes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_alloc_color_cells_cookie_t xcb_alloc_color_cells(xcb_connection_t*, uint8_t, xcb_colormap_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10920</i>
	 */
	com.yi.ylwm.xcb.xcb_alloc_color_cells_cookie_t.ByValue xcb_alloc_color_cells(PointerByReference c, byte contiguous, int cmap, short colors, short planes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_color_cells_cookie_t xcb_alloc_color_cells_unchecked(xcb_connection_t*, uint8_t, xcb_colormap_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10938</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color_cells_unchecked(com.sun.jna.ptr.PointerByReference, byte, int, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_alloc_color_cells_cookie_t.ByValue xcb_alloc_color_cells_unchecked(Pointer c, byte contiguous, int cmap, short colors, short planes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_color_cells_cookie_t xcb_alloc_color_cells_unchecked(xcb_connection_t*, uint8_t, xcb_colormap_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10938</i>
	 */
	com.yi.ylwm.xcb.xcb_alloc_color_cells_cookie_t.ByValue xcb_alloc_color_cells_unchecked(PointerByReference c, byte contiguous, int cmap, short colors, short planes);
	/**
	 * Original signature : <code>uint32_t* xcb_alloc_color_cells_pixels(const xcb_alloc_color_cells_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10945</i>
	 */
	IntByReference xcb_alloc_color_cells_pixels(xcb_alloc_color_cells_reply_t R);
	/**
	 * Original signature : <code>int xcb_alloc_color_cells_pixels_length(const xcb_alloc_color_cells_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10948</i>
	 */
	int xcb_alloc_color_cells_pixels_length(xcb_alloc_color_cells_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_alloc_color_cells_pixels_end(const xcb_alloc_color_cells_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10951</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_alloc_color_cells_pixels_end(xcb_alloc_color_cells_reply_t R);
	/**
	 * Original signature : <code>uint32_t* xcb_alloc_color_cells_masks(const xcb_alloc_color_cells_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10954</i>
	 */
	IntByReference xcb_alloc_color_cells_masks(xcb_alloc_color_cells_reply_t R);
	/**
	 * Original signature : <code>int xcb_alloc_color_cells_masks_length(const xcb_alloc_color_cells_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10957</i>
	 */
	int xcb_alloc_color_cells_masks_length(xcb_alloc_color_cells_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_alloc_color_cells_masks_end(const xcb_alloc_color_cells_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10960</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_alloc_color_cells_masks_end(xcb_alloc_color_cells_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_alloc_color_cells_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_alloc_color_cells_reply_t* xcb_alloc_color_cells_reply(xcb_connection_t*, xcb_alloc_color_cells_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10977</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color_cells_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_alloc_color_cells_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_alloc_color_cells_reply_t xcb_alloc_color_cells_reply(Pointer c, com.yi.ylwm.xcb.xcb_alloc_color_cells_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_alloc_color_cells_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_alloc_color_cells_reply_t* xcb_alloc_color_cells_reply(xcb_connection_t*, xcb_alloc_color_cells_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10977</i>
	 */
	xcb_alloc_color_cells_reply_t xcb_alloc_color_cells_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_alloc_color_cells_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_alloc_color_planes_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10982</i>
	 */
	int xcb_alloc_color_planes_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_alloc_color_planes_cookie_t xcb_alloc_color_planes(xcb_connection_t*, uint8_t, xcb_colormap_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10993</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color_planes(com.sun.jna.ptr.PointerByReference, byte, int, short, short, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_alloc_color_planes_cookie_t.ByValue xcb_alloc_color_planes(Pointer c, byte contiguous, int cmap, short colors, short reds, short greens, short blues);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_alloc_color_planes_cookie_t xcb_alloc_color_planes(xcb_connection_t*, uint8_t, xcb_colormap_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:10993</i>
	 */
	com.yi.ylwm.xcb.xcb_alloc_color_planes_cookie_t.ByValue xcb_alloc_color_planes(PointerByReference c, byte contiguous, int cmap, short colors, short reds, short greens, short blues);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_color_planes_cookie_t xcb_alloc_color_planes_unchecked(xcb_connection_t*, uint8_t, xcb_colormap_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11013</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color_planes_unchecked(com.sun.jna.ptr.PointerByReference, byte, int, short, short, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_alloc_color_planes_cookie_t.ByValue xcb_alloc_color_planes_unchecked(Pointer c, byte contiguous, int cmap, short colors, short reds, short greens, short blues);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_alloc_color_planes_cookie_t xcb_alloc_color_planes_unchecked(xcb_connection_t*, uint8_t, xcb_colormap_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11013</i>
	 */
	com.yi.ylwm.xcb.xcb_alloc_color_planes_cookie_t.ByValue xcb_alloc_color_planes_unchecked(PointerByReference c, byte contiguous, int cmap, short colors, short reds, short greens, short blues);
	/**
	 * Original signature : <code>uint32_t* xcb_alloc_color_planes_pixels(const xcb_alloc_color_planes_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11022</i>
	 */
	IntByReference xcb_alloc_color_planes_pixels(xcb_alloc_color_planes_reply_t R);
	/**
	 * Original signature : <code>int xcb_alloc_color_planes_pixels_length(const xcb_alloc_color_planes_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11025</i>
	 */
	int xcb_alloc_color_planes_pixels_length(xcb_alloc_color_planes_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_alloc_color_planes_pixels_end(const xcb_alloc_color_planes_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11028</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_alloc_color_planes_pixels_end(xcb_alloc_color_planes_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_alloc_color_planes_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_alloc_color_planes_reply_t* xcb_alloc_color_planes_reply(xcb_connection_t*, xcb_alloc_color_planes_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11045</i><br>
	 * @deprecated use the safer method {@link #xcb_alloc_color_planes_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_alloc_color_planes_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_alloc_color_planes_reply_t xcb_alloc_color_planes_reply(Pointer c, com.yi.ylwm.xcb.xcb_alloc_color_planes_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_alloc_color_planes_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_alloc_color_planes_reply_t* xcb_alloc_color_planes_reply(xcb_connection_t*, xcb_alloc_color_planes_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11045</i>
	 */
	xcb_alloc_color_planes_reply_t xcb_alloc_color_planes_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_alloc_color_planes_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_free_colors_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11050</i>
	 */
	int xcb_free_colors_sizeof(Pointer _buffer, int pixels_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colors_checked(xcb_connection_t*, xcb_colormap_t, uint32_t, uint32_t, const uint32_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11065</i><br>
	 * @deprecated use the safer methods {@link #xcb_free_colors_checked(com.sun.jna.ptr.PointerByReference, int, int, int, int[])} and {@link #xcb_free_colors_checked(com.sun.jna.ptr.PointerByReference, int, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_colors_checked(Pointer c, int cmap, int plane_mask, int pixels_len, IntByReference pixels);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colors_checked(xcb_connection_t*, xcb_colormap_t, uint32_t, uint32_t, const uint32_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11065</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_colors_checked(PointerByReference c, int cmap, int plane_mask, int pixels_len, int pixels[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colors_checked(xcb_connection_t*, xcb_colormap_t, uint32_t, uint32_t, const uint32_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11065</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_colors_checked(PointerByReference c, int cmap, int plane_mask, int pixels_len, IntByReference pixels);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colors(xcb_connection_t*, xcb_colormap_t, uint32_t, uint32_t, const uint32_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11080</i><br>
	 * @deprecated use the safer methods {@link #xcb_free_colors(com.sun.jna.ptr.PointerByReference, int, int, int, int[])} and {@link #xcb_free_colors(com.sun.jna.ptr.PointerByReference, int, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_colors(Pointer c, int cmap, int plane_mask, int pixels_len, IntByReference pixels);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colors(xcb_connection_t*, xcb_colormap_t, uint32_t, uint32_t, const uint32_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11080</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_colors(PointerByReference c, int cmap, int plane_mask, int pixels_len, int pixels[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_colors(xcb_connection_t*, xcb_colormap_t, uint32_t, uint32_t, const uint32_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11080</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_colors(PointerByReference c, int cmap, int plane_mask, int pixels_len, IntByReference pixels);
	/**
	 * Original signature : <code>uint32_t* xcb_free_colors_pixels(const xcb_free_colors_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11087</i>
	 */
	IntByReference xcb_free_colors_pixels(xcb_free_colors_request_t R);
	/**
	 * Original signature : <code>int xcb_free_colors_pixels_length(const xcb_free_colors_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11090</i>
	 */
	int xcb_free_colors_pixels_length(xcb_free_colors_request_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_free_colors_pixels_end(const xcb_free_colors_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11093</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_free_colors_pixels_end(xcb_free_colors_request_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_coloritem_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_coloritem_t)<br>
	 * Original signature : <code>void xcb_coloritem_next(xcb_coloritem_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11104</i>
	 */
	void xcb_coloritem_next(xcb_coloritem_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_coloritem_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_coloritem_end(xcb_coloritem_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11116</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_coloritem_end(xcb_coloritem_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_store_colors_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11119</i>
	 */
	int xcb_store_colors_sizeof(Pointer _buffer, int items_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_colors_checked(xcb_connection_t*, xcb_colormap_t, uint32_t, const xcb_coloritem_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11134</i><br>
	 * @deprecated use the safer method {@link #xcb_store_colors_checked(com.sun.jna.ptr.PointerByReference, int, int, com.yi.ylwm.xcb.xcb_coloritem_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_store_colors_checked(Pointer c, int cmap, int items_len, xcb_coloritem_t items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_colors_checked(xcb_connection_t*, xcb_colormap_t, uint32_t, const xcb_coloritem_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11134</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_store_colors_checked(PointerByReference c, int cmap, int items_len, xcb_coloritem_t items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_colors(xcb_connection_t*, xcb_colormap_t, uint32_t, const xcb_coloritem_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11148</i><br>
	 * @deprecated use the safer method {@link #xcb_store_colors(com.sun.jna.ptr.PointerByReference, int, int, com.yi.ylwm.xcb.xcb_coloritem_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_store_colors(Pointer c, int cmap, int items_len, xcb_coloritem_t items);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_colors(xcb_connection_t*, xcb_colormap_t, uint32_t, const xcb_coloritem_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11148</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_store_colors(PointerByReference c, int cmap, int items_len, xcb_coloritem_t items);
	/**
	 * Original signature : <code>xcb_coloritem_t* xcb_store_colors_items(const xcb_store_colors_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11154</i>
	 */
	xcb_coloritem_t xcb_store_colors_items(xcb_store_colors_request_t R);
	/**
	 * Original signature : <code>int xcb_store_colors_items_length(const xcb_store_colors_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11157</i>
	 */
	int xcb_store_colors_items_length(xcb_store_colors_request_t R);
	/**
	 * Original signature : <code>xcb_coloritem_iterator_t xcb_store_colors_items_iterator(const xcb_store_colors_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11160</i>
	 */
	xcb_coloritem_iterator_t.ByValue xcb_store_colors_items_iterator(xcb_store_colors_request_t R);
	/**
	 * Original signature : <code>int xcb_store_named_color_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11163</i>
	 */
	int xcb_store_named_color_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_named_color_checked(xcb_connection_t*, uint8_t, xcb_colormap_t, uint32_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11177</i><br>
	 * @deprecated use the safer methods {@link #xcb_store_named_color_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, java.lang.String)} and {@link #xcb_store_named_color_checked(com.sun.jna.ptr.PointerByReference, byte, int, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_store_named_color_checked(Pointer c, byte flags, int cmap, int pixel, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_named_color_checked(xcb_connection_t*, uint8_t, xcb_colormap_t, uint32_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11177</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_store_named_color_checked(PointerByReference c, byte flags, int cmap, int pixel, short name_len, String name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_named_color_checked(xcb_connection_t*, uint8_t, xcb_colormap_t, uint32_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11177</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_store_named_color_checked(PointerByReference c, byte flags, int cmap, int pixel, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_named_color(xcb_connection_t*, uint8_t, xcb_colormap_t, uint32_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11193</i><br>
	 * @deprecated use the safer methods {@link #xcb_store_named_color(com.sun.jna.ptr.PointerByReference, byte, int, int, short, java.lang.String)} and {@link #xcb_store_named_color(com.sun.jna.ptr.PointerByReference, byte, int, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_store_named_color(Pointer c, byte flags, int cmap, int pixel, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_named_color(xcb_connection_t*, uint8_t, xcb_colormap_t, uint32_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11193</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_store_named_color(PointerByReference c, byte flags, int cmap, int pixel, short name_len, String name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_store_named_color(xcb_connection_t*, uint8_t, xcb_colormap_t, uint32_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11193</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_store_named_color(PointerByReference c, byte flags, int cmap, int pixel, short name_len, Pointer name);
	/**
	 * Original signature : <code>char* xcb_store_named_color_name(const xcb_store_named_color_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11201</i>
	 */
	Pointer xcb_store_named_color_name(xcb_store_named_color_request_t R);
	/**
	 * Original signature : <code>int xcb_store_named_color_name_length(const xcb_store_named_color_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11204</i>
	 */
	int xcb_store_named_color_name_length(xcb_store_named_color_request_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_store_named_color_name_end(const xcb_store_named_color_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11207</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_store_named_color_name_end(xcb_store_named_color_request_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_rgb_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_rgb_t)<br>
	 * Original signature : <code>void xcb_rgb_next(xcb_rgb_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11218</i>
	 */
	void xcb_rgb_next(xcb_rgb_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_rgb_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_rgb_end(xcb_rgb_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11230</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_rgb_end(xcb_rgb_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_query_colors_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11233</i>
	 */
	int xcb_query_colors_sizeof(Pointer _buffer, int pixels_len);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_query_colors_cookie_t xcb_query_colors(xcb_connection_t*, xcb_colormap_t, uint32_t, const uint32_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11245</i><br>
	 * @deprecated use the safer methods {@link #xcb_query_colors(com.sun.jna.ptr.PointerByReference, int, int, int[])} and {@link #xcb_query_colors(com.sun.jna.ptr.PointerByReference, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_query_colors_cookie_t.ByValue xcb_query_colors(Pointer c, int cmap, int pixels_len, IntByReference pixels);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_query_colors_cookie_t xcb_query_colors(xcb_connection_t*, xcb_colormap_t, uint32_t, const uint32_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11245</i>
	 */
	com.yi.ylwm.xcb.xcb_query_colors_cookie_t.ByValue xcb_query_colors(PointerByReference c, int cmap, int pixels_len, int pixels[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_query_colors_cookie_t xcb_query_colors(xcb_connection_t*, xcb_colormap_t, uint32_t, const uint32_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11245</i>
	 */
	com.yi.ylwm.xcb.xcb_query_colors_cookie_t.ByValue xcb_query_colors(PointerByReference c, int cmap, int pixels_len, IntByReference pixels);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_colors_cookie_t xcb_query_colors_unchecked(xcb_connection_t*, xcb_colormap_t, uint32_t, const uint32_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11262</i><br>
	 * @deprecated use the safer methods {@link #xcb_query_colors_unchecked(com.sun.jna.ptr.PointerByReference, int, int, int[])} and {@link #xcb_query_colors_unchecked(com.sun.jna.ptr.PointerByReference, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_query_colors_cookie_t.ByValue xcb_query_colors_unchecked(Pointer c, int cmap, int pixels_len, IntByReference pixels);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_colors_cookie_t xcb_query_colors_unchecked(xcb_connection_t*, xcb_colormap_t, uint32_t, const uint32_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11262</i>
	 */
	com.yi.ylwm.xcb.xcb_query_colors_cookie_t.ByValue xcb_query_colors_unchecked(PointerByReference c, int cmap, int pixels_len, int pixels[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_colors_cookie_t xcb_query_colors_unchecked(xcb_connection_t*, xcb_colormap_t, uint32_t, const uint32_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11262</i>
	 */
	com.yi.ylwm.xcb.xcb_query_colors_cookie_t.ByValue xcb_query_colors_unchecked(PointerByReference c, int cmap, int pixels_len, IntByReference pixels);
	/**
	 * Original signature : <code>xcb_rgb_t* xcb_query_colors_colors(const xcb_query_colors_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11268</i>
	 */
	xcb_rgb_t xcb_query_colors_colors(xcb_query_colors_reply_t R);
	/**
	 * Original signature : <code>int xcb_query_colors_colors_length(const xcb_query_colors_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11271</i>
	 */
	int xcb_query_colors_colors_length(xcb_query_colors_reply_t R);
	/**
	 * Original signature : <code>xcb_rgb_iterator_t xcb_query_colors_colors_iterator(const xcb_query_colors_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11274</i>
	 */
	xcb_rgb_iterator_t.ByValue xcb_query_colors_colors_iterator(xcb_query_colors_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_colors_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_colors_reply_t* xcb_query_colors_reply(xcb_connection_t*, xcb_query_colors_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11291</i><br>
	 * @deprecated use the safer method {@link #xcb_query_colors_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_query_colors_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_query_colors_reply_t xcb_query_colors_reply(Pointer c, com.yi.ylwm.xcb.xcb_query_colors_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_colors_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_colors_reply_t* xcb_query_colors_reply(xcb_connection_t*, xcb_query_colors_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11291</i>
	 */
	xcb_query_colors_reply_t xcb_query_colors_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_query_colors_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_lookup_color_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11296</i>
	 */
	int xcb_lookup_color_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_lookup_color_cookie_t xcb_lookup_color(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11307</i><br>
	 * @deprecated use the safer methods {@link #xcb_lookup_color(com.sun.jna.ptr.PointerByReference, int, short, java.lang.String)} and {@link #xcb_lookup_color(com.sun.jna.ptr.PointerByReference, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_lookup_color_cookie_t.ByValue xcb_lookup_color(Pointer c, int cmap, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_lookup_color_cookie_t xcb_lookup_color(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11307</i>
	 */
	com.yi.ylwm.xcb.xcb_lookup_color_cookie_t.ByValue xcb_lookup_color(PointerByReference c, int cmap, short name_len, String name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_lookup_color_cookie_t xcb_lookup_color(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11307</i>
	 */
	com.yi.ylwm.xcb.xcb_lookup_color_cookie_t.ByValue xcb_lookup_color(PointerByReference c, int cmap, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_lookup_color_cookie_t xcb_lookup_color_unchecked(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11324</i><br>
	 * @deprecated use the safer methods {@link #xcb_lookup_color_unchecked(com.sun.jna.ptr.PointerByReference, int, short, java.lang.String)} and {@link #xcb_lookup_color_unchecked(com.sun.jna.ptr.PointerByReference, int, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_lookup_color_cookie_t.ByValue xcb_lookup_color_unchecked(Pointer c, int cmap, short name_len, Pointer name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_lookup_color_cookie_t xcb_lookup_color_unchecked(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11324</i>
	 */
	com.yi.ylwm.xcb.xcb_lookup_color_cookie_t.ByValue xcb_lookup_color_unchecked(PointerByReference c, int cmap, short name_len, String name);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_lookup_color_cookie_t xcb_lookup_color_unchecked(xcb_connection_t*, xcb_colormap_t, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11324</i>
	 */
	com.yi.ylwm.xcb.xcb_lookup_color_cookie_t.ByValue xcb_lookup_color_unchecked(PointerByReference c, int cmap, short name_len, Pointer name);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_lookup_color_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_lookup_color_reply_t* xcb_lookup_color_reply(xcb_connection_t*, xcb_lookup_color_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11344</i><br>
	 * @deprecated use the safer method {@link #xcb_lookup_color_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_lookup_color_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_lookup_color_reply_t xcb_lookup_color_reply(Pointer c, com.yi.ylwm.xcb.xcb_lookup_color_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_lookup_color_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_lookup_color_reply_t* xcb_lookup_color_reply(xcb_connection_t*, xcb_lookup_color_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11344</i>
	 */
	xcb_lookup_color_reply_t xcb_lookup_color_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_lookup_color_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_cursor_checked(xcb_connection_t*, xcb_cursor_t, xcb_pixmap_t, xcb_pixmap_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11360</i><br>
	 * @deprecated use the safer method {@link #xcb_create_cursor_checked(com.sun.jna.ptr.PointerByReference, int, int, int, short, short, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_cursor_checked(Pointer c, int cid, int source, int mask, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue, short x, short y);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_cursor_checked(xcb_connection_t*, xcb_cursor_t, xcb_pixmap_t, xcb_pixmap_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11360</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_cursor_checked(PointerByReference c, int cid, int source, int mask, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue, short x, short y);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_cursor(xcb_connection_t*, xcb_cursor_t, xcb_pixmap_t, xcb_pixmap_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11382</i><br>
	 * @deprecated use the safer method {@link #xcb_create_cursor(com.sun.jna.ptr.PointerByReference, int, int, int, short, short, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_cursor(Pointer c, int cid, int source, int mask, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue, short x, short y);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_cursor(xcb_connection_t*, xcb_cursor_t, xcb_pixmap_t, xcb_pixmap_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11382</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_cursor(PointerByReference c, int cid, int source, int mask, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue, short x, short y);
	/**
	 * @brief create cursor<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the cursor, created by `xcb_generate_id`.<br>
	 * @param source_font In which font to look for the cursor glyph.<br>
	 * @param mask_font In which font to look for the mask glyph.<br>
	 * @param source_char The glyph of \a source_font to use.<br>
	 * @param mask_char The glyph of \a mask_font to use as a mask: Pixels which are set to 1 define<br>
	 * which source pixels are displayed. All pixels which are set to 0 are not<br>
	 * displayed.<br>
	 * @param fore_red The red value of the foreground color.<br>
	 * @param fore_green The green value of the foreground color.<br>
	 * @param fore_blue The blue value of the foreground color.<br>
	 * @param back_red The red value of the background color.<br>
	 * @param back_green The green value of the background color.<br>
	 * @param back_blue The blue value of the background color.<br>
	 * @return A cookie<br>
	 * Creates a cursor from a font glyph. X provides a set of standard cursor shapes<br>
	 * in a special font named cursor. Applications are encouraged to use this<br>
	 * interface for their cursors because the font can be customized for the<br>
	 * individual display type.<br>
	 * <br>
	 * All pixels which are set to 1 in the source will use the foreground color (as<br>
	 * specified by \a fore_red, \a fore_green and \a fore_blue). All pixels set to 0<br>
	 * will use the background color (as specified by \a back_red, \a back_green and<br>
	 * \a back_blue).<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_glyph_cursor_checked(xcb_connection_t*, xcb_cursor_t, xcb_font_t, xcb_font_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11429</i><br>
	 * @deprecated use the safer method {@link #xcb_create_glyph_cursor_checked(com.sun.jna.ptr.PointerByReference, int, int, int, short, short, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_glyph_cursor_checked(Pointer c, int cid, int source_font, int mask_font, short source_char, short mask_char, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue);
	/**
	 * @brief create cursor<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the cursor, created by `xcb_generate_id`.<br>
	 * @param source_font In which font to look for the cursor glyph.<br>
	 * @param mask_font In which font to look for the mask glyph.<br>
	 * @param source_char The glyph of \a source_font to use.<br>
	 * @param mask_char The glyph of \a mask_font to use as a mask: Pixels which are set to 1 define<br>
	 * which source pixels are displayed. All pixels which are set to 0 are not<br>
	 * displayed.<br>
	 * @param fore_red The red value of the foreground color.<br>
	 * @param fore_green The green value of the foreground color.<br>
	 * @param fore_blue The blue value of the foreground color.<br>
	 * @param back_red The red value of the background color.<br>
	 * @param back_green The green value of the background color.<br>
	 * @param back_blue The blue value of the background color.<br>
	 * @return A cookie<br>
	 * Creates a cursor from a font glyph. X provides a set of standard cursor shapes<br>
	 * in a special font named cursor. Applications are encouraged to use this<br>
	 * interface for their cursors because the font can be customized for the<br>
	 * individual display type.<br>
	 * <br>
	 * All pixels which are set to 1 in the source will use the foreground color (as<br>
	 * specified by \a fore_red, \a fore_green and \a fore_blue). All pixels set to 0<br>
	 * will use the background color (as specified by \a back_red, \a back_green and<br>
	 * \a back_blue).<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_glyph_cursor_checked(xcb_connection_t*, xcb_cursor_t, xcb_font_t, xcb_font_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11429</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_glyph_cursor_checked(PointerByReference c, int cid, int source_font, int mask_font, short source_char, short mask_char, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue);
	/**
	 * @brief create cursor<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the cursor, created by `xcb_generate_id`.<br>
	 * @param source_font In which font to look for the cursor glyph.<br>
	 * @param mask_font In which font to look for the mask glyph.<br>
	 * @param source_char The glyph of \a source_font to use.<br>
	 * @param mask_char The glyph of \a mask_font to use as a mask: Pixels which are set to 1 define<br>
	 * which source pixels are displayed. All pixels which are set to 0 are not<br>
	 * displayed.<br>
	 * @param fore_red The red value of the foreground color.<br>
	 * @param fore_green The green value of the foreground color.<br>
	 * @param fore_blue The blue value of the foreground color.<br>
	 * @param back_red The red value of the background color.<br>
	 * @param back_green The green value of the background color.<br>
	 * @param back_blue The blue value of the background color.<br>
	 * @return A cookie<br>
	 * Creates a cursor from a font glyph. X provides a set of standard cursor shapes<br>
	 * in a special font named cursor. Applications are encouraged to use this<br>
	 * interface for their cursors because the font can be customized for the<br>
	 * individual display type.<br>
	 * <br>
	 * All pixels which are set to 1 in the source will use the foreground color (as<br>
	 * specified by \a fore_red, \a fore_green and \a fore_blue). All pixels set to 0<br>
	 * will use the background color (as specified by \a back_red, \a back_green and<br>
	 * \a back_blue).<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_glyph_cursor(xcb_connection_t*, xcb_cursor_t, xcb_font_t, xcb_font_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11473</i><br>
	 * @deprecated use the safer method {@link #xcb_create_glyph_cursor(com.sun.jna.ptr.PointerByReference, int, int, int, short, short, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_glyph_cursor(Pointer c, int cid, int source_font, int mask_font, short source_char, short mask_char, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue);
	/**
	 * @brief create cursor<br>
	 * @param c The connection<br>
	 * @param cid The ID with which you will refer to the cursor, created by `xcb_generate_id`.<br>
	 * @param source_font In which font to look for the cursor glyph.<br>
	 * @param mask_font In which font to look for the mask glyph.<br>
	 * @param source_char The glyph of \a source_font to use.<br>
	 * @param mask_char The glyph of \a mask_font to use as a mask: Pixels which are set to 1 define<br>
	 * which source pixels are displayed. All pixels which are set to 0 are not<br>
	 * displayed.<br>
	 * @param fore_red The red value of the foreground color.<br>
	 * @param fore_green The green value of the foreground color.<br>
	 * @param fore_blue The blue value of the foreground color.<br>
	 * @param back_red The red value of the background color.<br>
	 * @param back_green The green value of the background color.<br>
	 * @param back_blue The blue value of the background color.<br>
	 * @return A cookie<br>
	 * Creates a cursor from a font glyph. X provides a set of standard cursor shapes<br>
	 * in a special font named cursor. Applications are encouraged to use this<br>
	 * interface for their cursors because the font can be customized for the<br>
	 * individual display type.<br>
	 * <br>
	 * All pixels which are set to 1 in the source will use the foreground color (as<br>
	 * specified by \a fore_red, \a fore_green and \a fore_blue). All pixels set to 0<br>
	 * will use the background color (as specified by \a back_red, \a back_green and<br>
	 * \a back_blue).<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_create_glyph_cursor(xcb_connection_t*, xcb_cursor_t, xcb_font_t, xcb_font_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11473</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_create_glyph_cursor(PointerByReference c, int cid, int source_font, int mask_font, short source_char, short mask_char, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue);
	/**
	 * @brief Deletes a cursor<br>
	 * @param c The connection<br>
	 * @param cursor The cursor to destroy.<br>
	 * @return A cookie<br>
	 * Deletes the association between the cursor resource ID and the specified<br>
	 * cursor. The cursor is freed when no other resource references it.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_cursor_checked(xcb_connection_t*, xcb_cursor_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11501</i><br>
	 * @deprecated use the safer method {@link #xcb_free_cursor_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_cursor_checked(Pointer c, int cursor);
	/**
	 * @brief Deletes a cursor<br>
	 * @param c The connection<br>
	 * @param cursor The cursor to destroy.<br>
	 * @return A cookie<br>
	 * Deletes the association between the cursor resource ID and the specified<br>
	 * cursor. The cursor is freed when no other resource references it.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_cursor_checked(xcb_connection_t*, xcb_cursor_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11501</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_cursor_checked(PointerByReference c, int cursor);
	/**
	 * @brief Deletes a cursor<br>
	 * @param c The connection<br>
	 * @param cursor The cursor to destroy.<br>
	 * @return A cookie<br>
	 * Deletes the association between the cursor resource ID and the specified<br>
	 * cursor. The cursor is freed when no other resource references it.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_cursor(xcb_connection_t*, xcb_cursor_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11516</i><br>
	 * @deprecated use the safer method {@link #xcb_free_cursor(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_cursor(Pointer c, int cursor);
	/**
	 * @brief Deletes a cursor<br>
	 * @param c The connection<br>
	 * @param cursor The cursor to destroy.<br>
	 * @return A cookie<br>
	 * Deletes the association between the cursor resource ID and the specified<br>
	 * cursor. The cursor is freed when no other resource references it.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_free_cursor(xcb_connection_t*, xcb_cursor_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11516</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_free_cursor(PointerByReference c, int cursor);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_recolor_cursor_checked(xcb_connection_t*, xcb_cursor_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11531</i><br>
	 * @deprecated use the safer method {@link #xcb_recolor_cursor_checked(com.sun.jna.ptr.PointerByReference, int, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_recolor_cursor_checked(Pointer c, int cursor, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_recolor_cursor_checked(xcb_connection_t*, xcb_cursor_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11531</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_recolor_cursor_checked(PointerByReference c, int cursor, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_recolor_cursor(xcb_connection_t*, xcb_cursor_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11549</i><br>
	 * @deprecated use the safer method {@link #xcb_recolor_cursor(com.sun.jna.ptr.PointerByReference, int, short, short, short, short, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_recolor_cursor(Pointer c, int cursor, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_recolor_cursor(xcb_connection_t*, xcb_cursor_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11549</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_recolor_cursor(PointerByReference c, int cursor, short fore_red, short fore_green, short fore_blue, short back_red, short back_green, short back_blue);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_query_best_size_cookie_t xcb_query_best_size(xcb_connection_t*, uint8_t, xcb_drawable_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11567</i><br>
	 * @deprecated use the safer method {@link #xcb_query_best_size(com.sun.jna.ptr.PointerByReference, byte, int, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_query_best_size_cookie_t.ByValue xcb_query_best_size(Pointer c, byte _class, int drawable, short width, short height);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_query_best_size_cookie_t xcb_query_best_size(xcb_connection_t*, uint8_t, xcb_drawable_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11567</i>
	 */
	com.yi.ylwm.xcb.xcb_query_best_size_cookie_t.ByValue xcb_query_best_size(PointerByReference c, byte _class, int drawable, short width, short height);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_best_size_cookie_t xcb_query_best_size_unchecked(xcb_connection_t*, uint8_t, xcb_drawable_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11585</i><br>
	 * @deprecated use the safer method {@link #xcb_query_best_size_unchecked(com.sun.jna.ptr.PointerByReference, byte, int, short, short)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_query_best_size_cookie_t.ByValue xcb_query_best_size_unchecked(Pointer c, byte _class, int drawable, short width, short height);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_best_size_cookie_t xcb_query_best_size_unchecked(xcb_connection_t*, uint8_t, xcb_drawable_t, uint16_t, uint16_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11585</i>
	 */
	com.yi.ylwm.xcb.xcb_query_best_size_cookie_t.ByValue xcb_query_best_size_unchecked(PointerByReference c, byte _class, int drawable, short width, short height);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_best_size_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_best_size_reply_t* xcb_query_best_size_reply(xcb_connection_t*, xcb_query_best_size_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11606</i><br>
	 * @deprecated use the safer method {@link #xcb_query_best_size_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_query_best_size_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_query_best_size_reply_t xcb_query_best_size_reply(Pointer c, com.yi.ylwm.xcb.xcb_query_best_size_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_best_size_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_best_size_reply_t* xcb_query_best_size_reply(xcb_connection_t*, xcb_query_best_size_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11606</i>
	 */
	xcb_query_best_size_reply_t xcb_query_best_size_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_query_best_size_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_query_extension_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11611</i>
	 */
	int xcb_query_extension_sizeof(Pointer _buffer);
	/**
	 * @brief check if extension is present<br>
	 * @param c The connection<br>
	 * @param name_len The length of \a name in bytes.<br>
	 * @param name The name of the extension to query, for example "RANDR". This is case<br>
	 * sensitive!<br>
	 * @return A cookie<br>
	 * Determines if the specified extension is present on this X11 server.<br>
	 * <br>
	 * Every extension has a unique `major_opcode` to identify requests, the minor<br>
	 * opcodes and request formats are extension-specific. If the extension provides<br>
	 * events and errors, the `first_event` and `first_error` fields in the reply are<br>
	 * set accordingly.<br>
	 * <br>
	 * There should rarely be a need to use this request directly, XCB provides the<br>
	 * `xcb_get_extension_data` function instead.<br>
	 * Original signature : <code>xcb_query_extension_cookie_t xcb_query_extension(xcb_connection_t*, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11634</i><br>
	 * @deprecated use the safer methods {@link #xcb_query_extension(com.sun.jna.ptr.PointerByReference, short, java.lang.String)} and {@link #xcb_query_extension(com.sun.jna.ptr.PointerByReference, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_query_extension_cookie_t.ByValue xcb_query_extension(Pointer c, short name_len, Pointer name);
	/**
	 * @brief check if extension is present<br>
	 * @param c The connection<br>
	 * @param name_len The length of \a name in bytes.<br>
	 * @param name The name of the extension to query, for example "RANDR". This is case<br>
	 * sensitive!<br>
	 * @return A cookie<br>
	 * Determines if the specified extension is present on this X11 server.<br>
	 * <br>
	 * Every extension has a unique `major_opcode` to identify requests, the minor<br>
	 * opcodes and request formats are extension-specific. If the extension provides<br>
	 * events and errors, the `first_event` and `first_error` fields in the reply are<br>
	 * set accordingly.<br>
	 * <br>
	 * There should rarely be a need to use this request directly, XCB provides the<br>
	 * `xcb_get_extension_data` function instead.<br>
	 * Original signature : <code>xcb_query_extension_cookie_t xcb_query_extension(xcb_connection_t*, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11634</i>
	 */
	com.yi.ylwm.xcb.xcb_query_extension_cookie_t.ByValue xcb_query_extension(PointerByReference c, short name_len, String name);
	/**
	 * @brief check if extension is present<br>
	 * @param c The connection<br>
	 * @param name_len The length of \a name in bytes.<br>
	 * @param name The name of the extension to query, for example "RANDR". This is case<br>
	 * sensitive!<br>
	 * @return A cookie<br>
	 * Determines if the specified extension is present on this X11 server.<br>
	 * <br>
	 * Every extension has a unique `major_opcode` to identify requests, the minor<br>
	 * opcodes and request formats are extension-specific. If the extension provides<br>
	 * events and errors, the `first_event` and `first_error` fields in the reply are<br>
	 * set accordingly.<br>
	 * <br>
	 * There should rarely be a need to use this request directly, XCB provides the<br>
	 * `xcb_get_extension_data` function instead.<br>
	 * Original signature : <code>xcb_query_extension_cookie_t xcb_query_extension(xcb_connection_t*, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11634</i>
	 */
	com.yi.ylwm.xcb.xcb_query_extension_cookie_t.ByValue xcb_query_extension(PointerByReference c, short name_len, Pointer name);
	/**
	 * @brief check if extension is present<br>
	 * @param c The connection<br>
	 * @param name_len The length of \a name in bytes.<br>
	 * @param name The name of the extension to query, for example "RANDR". This is case<br>
	 * sensitive!<br>
	 * @return A cookie<br>
	 * Determines if the specified extension is present on this X11 server.<br>
	 * <br>
	 * Every extension has a unique `major_opcode` to identify requests, the minor<br>
	 * opcodes and request formats are extension-specific. If the extension provides<br>
	 * events and errors, the `first_event` and `first_error` fields in the reply are<br>
	 * set accordingly.<br>
	 * <br>
	 * There should rarely be a need to use this request directly, XCB provides the<br>
	 * `xcb_get_extension_data` function instead.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_extension_cookie_t xcb_query_extension_unchecked(xcb_connection_t*, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11662</i><br>
	 * @deprecated use the safer methods {@link #xcb_query_extension_unchecked(com.sun.jna.ptr.PointerByReference, short, java.lang.String)} and {@link #xcb_query_extension_unchecked(com.sun.jna.ptr.PointerByReference, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_query_extension_cookie_t.ByValue xcb_query_extension_unchecked(Pointer c, short name_len, Pointer name);
	/**
	 * @brief check if extension is present<br>
	 * @param c The connection<br>
	 * @param name_len The length of \a name in bytes.<br>
	 * @param name The name of the extension to query, for example "RANDR". This is case<br>
	 * sensitive!<br>
	 * @return A cookie<br>
	 * Determines if the specified extension is present on this X11 server.<br>
	 * <br>
	 * Every extension has a unique `major_opcode` to identify requests, the minor<br>
	 * opcodes and request formats are extension-specific. If the extension provides<br>
	 * events and errors, the `first_event` and `first_error` fields in the reply are<br>
	 * set accordingly.<br>
	 * <br>
	 * There should rarely be a need to use this request directly, XCB provides the<br>
	 * `xcb_get_extension_data` function instead.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_extension_cookie_t xcb_query_extension_unchecked(xcb_connection_t*, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11662</i>
	 */
	com.yi.ylwm.xcb.xcb_query_extension_cookie_t.ByValue xcb_query_extension_unchecked(PointerByReference c, short name_len, String name);
	/**
	 * @brief check if extension is present<br>
	 * @param c The connection<br>
	 * @param name_len The length of \a name in bytes.<br>
	 * @param name The name of the extension to query, for example "RANDR". This is case<br>
	 * sensitive!<br>
	 * @return A cookie<br>
	 * Determines if the specified extension is present on this X11 server.<br>
	 * <br>
	 * Every extension has a unique `major_opcode` to identify requests, the minor<br>
	 * opcodes and request formats are extension-specific. If the extension provides<br>
	 * events and errors, the `first_event` and `first_error` fields in the reply are<br>
	 * set accordingly.<br>
	 * <br>
	 * There should rarely be a need to use this request directly, XCB provides the<br>
	 * `xcb_get_extension_data` function instead.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_query_extension_cookie_t xcb_query_extension_unchecked(xcb_connection_t*, uint16_t, const char*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11662</i>
	 */
	com.yi.ylwm.xcb.xcb_query_extension_cookie_t.ByValue xcb_query_extension_unchecked(PointerByReference c, short name_len, Pointer name);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_extension_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_extension_reply_t* xcb_query_extension_reply(xcb_connection_t*, xcb_query_extension_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11681</i><br>
	 * @deprecated use the safer method {@link #xcb_query_extension_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_query_extension_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_query_extension_reply_t xcb_query_extension_reply(Pointer c, com.yi.ylwm.xcb.xcb_query_extension_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_query_extension_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_query_extension_reply_t* xcb_query_extension_reply(xcb_connection_t*, xcb_query_extension_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11681</i>
	 */
	xcb_query_extension_reply_t xcb_query_extension_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_query_extension_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_list_extensions_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11686</i>
	 */
	int xcb_list_extensions_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_list_extensions_cookie_t xcb_list_extensions(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11697</i><br>
	 * @deprecated use the safer method {@link #xcb_list_extensions(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_list_extensions_cookie_t.ByValue xcb_list_extensions(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_list_extensions_cookie_t xcb_list_extensions(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11697</i>
	 */
	com.yi.ylwm.xcb.xcb_list_extensions_cookie_t.ByValue xcb_list_extensions(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_extensions_cookie_t xcb_list_extensions_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11711</i><br>
	 * @deprecated use the safer method {@link #xcb_list_extensions_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_list_extensions_cookie_t.ByValue xcb_list_extensions_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_extensions_cookie_t xcb_list_extensions_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11711</i>
	 */
	com.yi.ylwm.xcb.xcb_list_extensions_cookie_t.ByValue xcb_list_extensions_unchecked(PointerByReference c);
	/**
	 * Original signature : <code>int xcb_list_extensions_names_length(const xcb_list_extensions_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11714</i>
	 */
	int xcb_list_extensions_names_length(xcb_list_extensions_reply_t R);
	/**
	 * Original signature : <code>xcb_str_iterator_t xcb_list_extensions_names_iterator(const xcb_list_extensions_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11717</i>
	 */
	xcb_str_iterator_t.ByValue xcb_list_extensions_names_iterator(xcb_list_extensions_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_extensions_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_extensions_reply_t* xcb_list_extensions_reply(xcb_connection_t*, xcb_list_extensions_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11734</i><br>
	 * @deprecated use the safer method {@link #xcb_list_extensions_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_list_extensions_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_list_extensions_reply_t xcb_list_extensions_reply(Pointer c, com.yi.ylwm.xcb.xcb_list_extensions_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_extensions_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_extensions_reply_t* xcb_list_extensions_reply(xcb_connection_t*, xcb_list_extensions_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11734</i>
	 */
	xcb_list_extensions_reply_t xcb_list_extensions_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_list_extensions_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_change_keyboard_mapping_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11739</i>
	 */
	int xcb_change_keyboard_mapping_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_mapping_checked(xcb_connection_t*, uint8_t, xcb_keycode_t, uint8_t, const xcb_keysym_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11753</i><br>
	 * @deprecated use the safer methods {@link #xcb_change_keyboard_mapping_checked(com.sun.jna.ptr.PointerByReference, byte, byte, byte, java.nio.IntBuffer)} and {@link #xcb_change_keyboard_mapping_checked(com.sun.jna.ptr.PointerByReference, byte, byte, byte, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_mapping_checked(Pointer c, byte keycode_count, byte first_keycode, byte keysyms_per_keycode, IntByReference keysyms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_mapping_checked(xcb_connection_t*, uint8_t, xcb_keycode_t, uint8_t, const xcb_keysym_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11753</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_mapping_checked(PointerByReference c, byte keycode_count, byte first_keycode, byte keysyms_per_keycode, IntBuffer keysyms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_mapping_checked(xcb_connection_t*, uint8_t, xcb_keycode_t, uint8_t, const xcb_keysym_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11753</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_mapping_checked(PointerByReference c, byte keycode_count, byte first_keycode, byte keysyms_per_keycode, IntByReference keysyms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_mapping(xcb_connection_t*, uint8_t, xcb_keycode_t, uint8_t, const xcb_keysym_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11768</i><br>
	 * @deprecated use the safer methods {@link #xcb_change_keyboard_mapping(com.sun.jna.ptr.PointerByReference, byte, byte, byte, java.nio.IntBuffer)} and {@link #xcb_change_keyboard_mapping(com.sun.jna.ptr.PointerByReference, byte, byte, byte, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_mapping(Pointer c, byte keycode_count, byte first_keycode, byte keysyms_per_keycode, IntByReference keysyms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_mapping(xcb_connection_t*, uint8_t, xcb_keycode_t, uint8_t, const xcb_keysym_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11768</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_mapping(PointerByReference c, byte keycode_count, byte first_keycode, byte keysyms_per_keycode, IntBuffer keysyms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_mapping(xcb_connection_t*, uint8_t, xcb_keycode_t, uint8_t, const xcb_keysym_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11768</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_mapping(PointerByReference c, byte keycode_count, byte first_keycode, byte keysyms_per_keycode, IntByReference keysyms);
	/**
	 * Original signature : <code>xcb_keysym_t* xcb_change_keyboard_mapping_keysyms(const xcb_change_keyboard_mapping_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11775</i>
	 */
	IntByReference xcb_change_keyboard_mapping_keysyms(xcb_change_keyboard_mapping_request_t R);
	/**
	 * Original signature : <code>int xcb_change_keyboard_mapping_keysyms_length(const xcb_change_keyboard_mapping_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11778</i>
	 */
	int xcb_change_keyboard_mapping_keysyms_length(xcb_change_keyboard_mapping_request_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_change_keyboard_mapping_keysyms_end(const xcb_change_keyboard_mapping_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11781</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_change_keyboard_mapping_keysyms_end(xcb_change_keyboard_mapping_request_t R);
	/**
	 * Original signature : <code>int xcb_get_keyboard_mapping_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11784</i>
	 */
	int xcb_get_keyboard_mapping_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_keyboard_mapping_cookie_t xcb_get_keyboard_mapping(xcb_connection_t*, xcb_keycode_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11795</i><br>
	 * @deprecated use the safer method {@link #xcb_get_keyboard_mapping(com.sun.jna.ptr.PointerByReference, byte, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_keyboard_mapping_cookie_t.ByValue xcb_get_keyboard_mapping(Pointer c, byte first_keycode, byte count);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_keyboard_mapping_cookie_t xcb_get_keyboard_mapping(xcb_connection_t*, xcb_keycode_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11795</i>
	 */
	com.yi.ylwm.xcb.xcb_get_keyboard_mapping_cookie_t.ByValue xcb_get_keyboard_mapping(PointerByReference c, byte first_keycode, byte count);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_keyboard_mapping_cookie_t xcb_get_keyboard_mapping_unchecked(xcb_connection_t*, xcb_keycode_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11811</i><br>
	 * @deprecated use the safer method {@link #xcb_get_keyboard_mapping_unchecked(com.sun.jna.ptr.PointerByReference, byte, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_keyboard_mapping_cookie_t.ByValue xcb_get_keyboard_mapping_unchecked(Pointer c, byte first_keycode, byte count);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_keyboard_mapping_cookie_t xcb_get_keyboard_mapping_unchecked(xcb_connection_t*, xcb_keycode_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11811</i>
	 */
	com.yi.ylwm.xcb.xcb_get_keyboard_mapping_cookie_t.ByValue xcb_get_keyboard_mapping_unchecked(PointerByReference c, byte first_keycode, byte count);
	/**
	 * Original signature : <code>xcb_keysym_t* xcb_get_keyboard_mapping_keysyms(const xcb_get_keyboard_mapping_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11816</i>
	 */
	IntByReference xcb_get_keyboard_mapping_keysyms(xcb_get_keyboard_mapping_reply_t R);
	/**
	 * Original signature : <code>int xcb_get_keyboard_mapping_keysyms_length(const xcb_get_keyboard_mapping_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11819</i>
	 */
	int xcb_get_keyboard_mapping_keysyms_length(xcb_get_keyboard_mapping_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_get_keyboard_mapping_keysyms_end(const xcb_get_keyboard_mapping_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11822</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_get_keyboard_mapping_keysyms_end(xcb_get_keyboard_mapping_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_keyboard_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_keyboard_mapping_reply_t* xcb_get_keyboard_mapping_reply(xcb_connection_t*, xcb_get_keyboard_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11839</i><br>
	 * @deprecated use the safer method {@link #xcb_get_keyboard_mapping_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_get_keyboard_mapping_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_keyboard_mapping_reply_t xcb_get_keyboard_mapping_reply(Pointer c, com.yi.ylwm.xcb.xcb_get_keyboard_mapping_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_keyboard_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_keyboard_mapping_reply_t* xcb_get_keyboard_mapping_reply(xcb_connection_t*, xcb_get_keyboard_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11839</i>
	 */
	xcb_get_keyboard_mapping_reply_t xcb_get_keyboard_mapping_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_get_keyboard_mapping_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_change_keyboard_control_value_list_serialize(void**, uint32_t, const xcb_change_keyboard_control_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11844</i>
	 */
	int xcb_change_keyboard_control_value_list_serialize(PointerByReference _buffer, int value_mask, xcb_change_keyboard_control_value_list_t _aux);
	/**
	 * Original signature : <code>int xcb_change_keyboard_control_value_list_unpack(const void*, uint32_t, xcb_change_keyboard_control_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11849</i>
	 */
	int xcb_change_keyboard_control_value_list_unpack(Pointer _buffer, int value_mask, xcb_change_keyboard_control_value_list_t _aux);
	/**
	 * Original signature : <code>int xcb_change_keyboard_control_value_list_sizeof(const void*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11854</i>
	 */
	int xcb_change_keyboard_control_value_list_sizeof(Pointer _buffer, int value_mask);
	/**
	 * Original signature : <code>int xcb_change_keyboard_control_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11858</i>
	 */
	int xcb_change_keyboard_control_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_control_checked(xcb_connection_t*, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11872</i><br>
	 * @deprecated use the safer method {@link #xcb_change_keyboard_control_checked(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_control_checked(Pointer c, int value_mask, Pointer value_list);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_control_checked(xcb_connection_t*, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11872</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_control_checked(PointerByReference c, int value_mask, Pointer value_list);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_control(xcb_connection_t*, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11885</i><br>
	 * @deprecated use the safer method {@link #xcb_change_keyboard_control(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_control(Pointer c, int value_mask, Pointer value_list);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_control(xcb_connection_t*, uint32_t, const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11885</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_control(PointerByReference c, int value_mask, Pointer value_list);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_control_aux_checked(xcb_connection_t*, uint32_t, const xcb_change_keyboard_control_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11901</i><br>
	 * @deprecated use the safer method {@link #xcb_change_keyboard_control_aux_checked(com.sun.jna.ptr.PointerByReference, int, com.yi.ylwm.xcb.xcb_change_keyboard_control_value_list_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_control_aux_checked(Pointer c, int value_mask, xcb_change_keyboard_control_value_list_t value_list);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_control_aux_checked(xcb_connection_t*, uint32_t, const xcb_change_keyboard_control_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11901</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_control_aux_checked(PointerByReference c, int value_mask, xcb_change_keyboard_control_value_list_t value_list);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_control_aux(xcb_connection_t*, uint32_t, const xcb_change_keyboard_control_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11914</i><br>
	 * @deprecated use the safer method {@link #xcb_change_keyboard_control_aux(com.sun.jna.ptr.PointerByReference, int, com.yi.ylwm.xcb.xcb_change_keyboard_control_value_list_t)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_control_aux(Pointer c, int value_mask, xcb_change_keyboard_control_value_list_t value_list);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_keyboard_control_aux(xcb_connection_t*, uint32_t, const xcb_change_keyboard_control_value_list_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11914</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_keyboard_control_aux(PointerByReference c, int value_mask, xcb_change_keyboard_control_value_list_t value_list);
	/**
	 * Original signature : <code>void* xcb_change_keyboard_control_value_list(const xcb_change_keyboard_control_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11919</i>
	 */
	Pointer xcb_change_keyboard_control_value_list(xcb_change_keyboard_control_request_t R);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_keyboard_control_cookie_t xcb_get_keyboard_control(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11930</i><br>
	 * @deprecated use the safer method {@link #xcb_get_keyboard_control(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_keyboard_control_cookie_t.ByValue xcb_get_keyboard_control(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_keyboard_control_cookie_t xcb_get_keyboard_control(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11930</i>
	 */
	com.yi.ylwm.xcb.xcb_get_keyboard_control_cookie_t.ByValue xcb_get_keyboard_control(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_keyboard_control_cookie_t xcb_get_keyboard_control_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11944</i><br>
	 * @deprecated use the safer method {@link #xcb_get_keyboard_control_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_keyboard_control_cookie_t.ByValue xcb_get_keyboard_control_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_keyboard_control_cookie_t xcb_get_keyboard_control_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11944</i>
	 */
	com.yi.ylwm.xcb.xcb_get_keyboard_control_cookie_t.ByValue xcb_get_keyboard_control_unchecked(PointerByReference c);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_keyboard_control_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_keyboard_control_reply_t* xcb_get_keyboard_control_reply(xcb_connection_t*, xcb_get_keyboard_control_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11961</i><br>
	 * @deprecated use the safer method {@link #xcb_get_keyboard_control_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_get_keyboard_control_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_keyboard_control_reply_t xcb_get_keyboard_control_reply(Pointer c, com.yi.ylwm.xcb.xcb_get_keyboard_control_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_keyboard_control_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_keyboard_control_reply_t* xcb_get_keyboard_control_reply(xcb_connection_t*, xcb_get_keyboard_control_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11961</i>
	 */
	xcb_get_keyboard_control_reply_t xcb_get_keyboard_control_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_get_keyboard_control_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_bell_checked(xcb_connection_t*, int8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11977</i><br>
	 * @deprecated use the safer method {@link #xcb_bell_checked(com.sun.jna.ptr.PointerByReference, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_bell_checked(Pointer c, byte percent);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_bell_checked(xcb_connection_t*, int8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11977</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_bell_checked(PointerByReference c, byte percent);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_bell(xcb_connection_t*, int8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11989</i><br>
	 * @deprecated use the safer method {@link #xcb_bell(com.sun.jna.ptr.PointerByReference, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_bell(Pointer c, byte percent);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_bell(xcb_connection_t*, int8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:11989</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_bell(PointerByReference c, byte percent);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_pointer_control_checked(xcb_connection_t*, int16_t, int16_t, int16_t, uint8_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12004</i><br>
	 * @deprecated use the safer method {@link #xcb_change_pointer_control_checked(com.sun.jna.ptr.PointerByReference, short, short, short, byte, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_pointer_control_checked(Pointer c, short acceleration_numerator, short acceleration_denominator, short threshold, byte do_acceleration, byte do_threshold);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_pointer_control_checked(xcb_connection_t*, int16_t, int16_t, int16_t, uint8_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12004</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_pointer_control_checked(PointerByReference c, short acceleration_numerator, short acceleration_denominator, short threshold, byte do_acceleration, byte do_threshold);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_pointer_control(xcb_connection_t*, int16_t, int16_t, int16_t, uint8_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12020</i><br>
	 * @deprecated use the safer method {@link #xcb_change_pointer_control(com.sun.jna.ptr.PointerByReference, short, short, short, byte, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_pointer_control(Pointer c, short acceleration_numerator, short acceleration_denominator, short threshold, byte do_acceleration, byte do_threshold);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_pointer_control(xcb_connection_t*, int16_t, int16_t, int16_t, uint8_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12020</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_pointer_control(PointerByReference c, short acceleration_numerator, short acceleration_denominator, short threshold, byte do_acceleration, byte do_threshold);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_pointer_control_cookie_t xcb_get_pointer_control(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12036</i><br>
	 * @deprecated use the safer method {@link #xcb_get_pointer_control(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_pointer_control_cookie_t.ByValue xcb_get_pointer_control(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_pointer_control_cookie_t xcb_get_pointer_control(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12036</i>
	 */
	com.yi.ylwm.xcb.xcb_get_pointer_control_cookie_t.ByValue xcb_get_pointer_control(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_pointer_control_cookie_t xcb_get_pointer_control_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12050</i><br>
	 * @deprecated use the safer method {@link #xcb_get_pointer_control_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_pointer_control_cookie_t.ByValue xcb_get_pointer_control_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_pointer_control_cookie_t xcb_get_pointer_control_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12050</i>
	 */
	com.yi.ylwm.xcb.xcb_get_pointer_control_cookie_t.ByValue xcb_get_pointer_control_unchecked(PointerByReference c);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_pointer_control_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_pointer_control_reply_t* xcb_get_pointer_control_reply(xcb_connection_t*, xcb_get_pointer_control_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12067</i><br>
	 * @deprecated use the safer method {@link #xcb_get_pointer_control_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_get_pointer_control_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_pointer_control_reply_t xcb_get_pointer_control_reply(Pointer c, com.yi.ylwm.xcb.xcb_get_pointer_control_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_pointer_control_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_pointer_control_reply_t* xcb_get_pointer_control_reply(xcb_connection_t*, xcb_get_pointer_control_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12067</i>
	 */
	xcb_get_pointer_control_reply_t xcb_get_pointer_control_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_get_pointer_control_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_screen_saver_checked(xcb_connection_t*, int16_t, int16_t, uint8_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12083</i><br>
	 * @deprecated use the safer method {@link #xcb_set_screen_saver_checked(com.sun.jna.ptr.PointerByReference, short, short, byte, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_screen_saver_checked(Pointer c, short timeout, short interval, byte prefer_blanking, byte allow_exposures);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_screen_saver_checked(xcb_connection_t*, int16_t, int16_t, uint8_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12083</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_screen_saver_checked(PointerByReference c, short timeout, short interval, byte prefer_blanking, byte allow_exposures);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_screen_saver(xcb_connection_t*, int16_t, int16_t, uint8_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12098</i><br>
	 * @deprecated use the safer method {@link #xcb_set_screen_saver(com.sun.jna.ptr.PointerByReference, short, short, byte, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_screen_saver(Pointer c, short timeout, short interval, byte prefer_blanking, byte allow_exposures);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_screen_saver(xcb_connection_t*, int16_t, int16_t, uint8_t, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12098</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_screen_saver(PointerByReference c, short timeout, short interval, byte prefer_blanking, byte allow_exposures);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_screen_saver_cookie_t xcb_get_screen_saver(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12113</i><br>
	 * @deprecated use the safer method {@link #xcb_get_screen_saver(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_screen_saver_cookie_t.ByValue xcb_get_screen_saver(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_screen_saver_cookie_t xcb_get_screen_saver(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12113</i>
	 */
	com.yi.ylwm.xcb.xcb_get_screen_saver_cookie_t.ByValue xcb_get_screen_saver(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_screen_saver_cookie_t xcb_get_screen_saver_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12127</i><br>
	 * @deprecated use the safer method {@link #xcb_get_screen_saver_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_screen_saver_cookie_t.ByValue xcb_get_screen_saver_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_screen_saver_cookie_t xcb_get_screen_saver_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12127</i>
	 */
	com.yi.ylwm.xcb.xcb_get_screen_saver_cookie_t.ByValue xcb_get_screen_saver_unchecked(PointerByReference c);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_screen_saver_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_screen_saver_reply_t* xcb_get_screen_saver_reply(xcb_connection_t*, xcb_get_screen_saver_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12144</i><br>
	 * @deprecated use the safer method {@link #xcb_get_screen_saver_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_get_screen_saver_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_screen_saver_reply_t xcb_get_screen_saver_reply(Pointer c, com.yi.ylwm.xcb.xcb_get_screen_saver_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_screen_saver_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_screen_saver_reply_t* xcb_get_screen_saver_reply(xcb_connection_t*, xcb_get_screen_saver_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12144</i>
	 */
	xcb_get_screen_saver_reply_t xcb_get_screen_saver_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_get_screen_saver_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_change_hosts_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12149</i>
	 */
	int xcb_change_hosts_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_hosts_checked(xcb_connection_t*, uint8_t, uint8_t, uint16_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12163</i><br>
	 * @deprecated use the safer methods {@link #xcb_change_hosts_checked(com.sun.jna.ptr.PointerByReference, byte, byte, short, byte[])} and {@link #xcb_change_hosts_checked(com.sun.jna.ptr.PointerByReference, byte, byte, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_hosts_checked(Pointer c, byte mode, byte family, short address_len, Pointer address);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_hosts_checked(xcb_connection_t*, uint8_t, uint8_t, uint16_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12163</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_hosts_checked(PointerByReference c, byte mode, byte family, short address_len, byte address[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_hosts_checked(xcb_connection_t*, uint8_t, uint8_t, uint16_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12163</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_hosts_checked(PointerByReference c, byte mode, byte family, short address_len, Pointer address);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_hosts(xcb_connection_t*, uint8_t, uint8_t, uint16_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12178</i><br>
	 * @deprecated use the safer methods {@link #xcb_change_hosts(com.sun.jna.ptr.PointerByReference, byte, byte, short, byte[])} and {@link #xcb_change_hosts(com.sun.jna.ptr.PointerByReference, byte, byte, short, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_hosts(Pointer c, byte mode, byte family, short address_len, Pointer address);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_hosts(xcb_connection_t*, uint8_t, uint8_t, uint16_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12178</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_hosts(PointerByReference c, byte mode, byte family, short address_len, byte address[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_change_hosts(xcb_connection_t*, uint8_t, uint8_t, uint16_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12178</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_change_hosts(PointerByReference c, byte mode, byte family, short address_len, Pointer address);
	/**
	 * Original signature : <code>uint8_t* xcb_change_hosts_address(const xcb_change_hosts_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12185</i>
	 */
	Pointer xcb_change_hosts_address(xcb_change_hosts_request_t R);
	/**
	 * Original signature : <code>int xcb_change_hosts_address_length(const xcb_change_hosts_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12188</i>
	 */
	int xcb_change_hosts_address_length(xcb_change_hosts_request_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_change_hosts_address_end(const xcb_change_hosts_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12191</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_change_hosts_address_end(xcb_change_hosts_request_t R);
	/**
	 * Original signature : <code>int xcb_host_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12194</i>
	 */
	int xcb_host_sizeof(Pointer _buffer);
	/**
	 * Original signature : <code>uint8_t* xcb_host_address(const xcb_host_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12197</i>
	 */
	Pointer xcb_host_address(xcb_host_t R);
	/**
	 * Original signature : <code>int xcb_host_address_length(const xcb_host_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12200</i>
	 */
	int xcb_host_address_length(xcb_host_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_host_address_end(const xcb_host_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12203</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_host_address_end(xcb_host_t R);
	/**
	 * Get the next element of the iterator<br>
	 * @param i Pointer to a xcb_host_iterator_t<br>
	 * Get the next element in the iterator. The member rem is<br>
	 * decreased by one. The member data points to the next<br>
	 * element. The member index is increased by sizeof(xcb_host_t)<br>
	 * Original signature : <code>void xcb_host_next(xcb_host_iterator_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12214</i>
	 */
	void xcb_host_next(xcb_host_iterator_t i);
	/**
	 * Return the iterator pointing to the last element<br>
	 * @param i An xcb_host_iterator_t<br>
	 * @return  The iterator pointing to the last element<br>
	 * Set the current element in the iterator to the last element.<br>
	 * The member rem is set to 0. The member data points to the<br>
	 * last element.<br>
	 * Original signature : <code>xcb_generic_iterator_t xcb_host_end(xcb_host_iterator_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12226</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_host_end(xcb_host_iterator_t.ByValue i);
	/**
	 * Original signature : <code>int xcb_list_hosts_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12229</i>
	 */
	int xcb_list_hosts_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_list_hosts_cookie_t xcb_list_hosts(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12240</i><br>
	 * @deprecated use the safer method {@link #xcb_list_hosts(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_list_hosts_cookie_t.ByValue xcb_list_hosts(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_list_hosts_cookie_t xcb_list_hosts(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12240</i>
	 */
	com.yi.ylwm.xcb.xcb_list_hosts_cookie_t.ByValue xcb_list_hosts(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_hosts_cookie_t xcb_list_hosts_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12254</i><br>
	 * @deprecated use the safer method {@link #xcb_list_hosts_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_list_hosts_cookie_t.ByValue xcb_list_hosts_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_list_hosts_cookie_t xcb_list_hosts_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12254</i>
	 */
	com.yi.ylwm.xcb.xcb_list_hosts_cookie_t.ByValue xcb_list_hosts_unchecked(PointerByReference c);
	/**
	 * Original signature : <code>int xcb_list_hosts_hosts_length(const xcb_list_hosts_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12257</i>
	 */
	int xcb_list_hosts_hosts_length(xcb_list_hosts_reply_t R);
	/**
	 * Original signature : <code>xcb_host_iterator_t xcb_list_hosts_hosts_iterator(const xcb_list_hosts_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12260</i>
	 */
	xcb_host_iterator_t.ByValue xcb_list_hosts_hosts_iterator(xcb_list_hosts_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_hosts_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_hosts_reply_t* xcb_list_hosts_reply(xcb_connection_t*, xcb_list_hosts_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12277</i><br>
	 * @deprecated use the safer method {@link #xcb_list_hosts_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_list_hosts_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_list_hosts_reply_t xcb_list_hosts_reply(Pointer c, com.yi.ylwm.xcb.xcb_list_hosts_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_list_hosts_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_list_hosts_reply_t* xcb_list_hosts_reply(xcb_connection_t*, xcb_list_hosts_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12277</i>
	 */
	xcb_list_hosts_reply_t xcb_list_hosts_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_list_hosts_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_access_control_checked(xcb_connection_t*, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12293</i><br>
	 * @deprecated use the safer method {@link #xcb_set_access_control_checked(com.sun.jna.ptr.PointerByReference, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_access_control_checked(Pointer c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_access_control_checked(xcb_connection_t*, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12293</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_access_control_checked(PointerByReference c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_access_control(xcb_connection_t*, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12305</i><br>
	 * @deprecated use the safer method {@link #xcb_set_access_control(com.sun.jna.ptr.PointerByReference, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_access_control(Pointer c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_access_control(xcb_connection_t*, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12305</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_access_control(PointerByReference c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_close_down_mode_checked(xcb_connection_t*, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12320</i><br>
	 * @deprecated use the safer method {@link #xcb_set_close_down_mode_checked(com.sun.jna.ptr.PointerByReference, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_close_down_mode_checked(Pointer c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_close_down_mode_checked(xcb_connection_t*, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12320</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_close_down_mode_checked(PointerByReference c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_close_down_mode(xcb_connection_t*, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12332</i><br>
	 * @deprecated use the safer method {@link #xcb_set_close_down_mode(com.sun.jna.ptr.PointerByReference, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_close_down_mode(Pointer c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_set_close_down_mode(xcb_connection_t*, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12332</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_set_close_down_mode(PointerByReference c, byte mode);
	/**
	 * @brief kills a client<br>
	 * @param c The connection<br>
	 * @param resource Any resource belonging to the client (for example a Window), used to identify<br>
	 * the client connection.<br>
	 * \n<br>
	 * The special value of `XCB_KILL_ALL_TEMPORARY`, the resources of all clients<br>
	 * that have terminated in `RetainTemporary` (TODO) are destroyed.<br>
	 * @return A cookie<br>
	 * Forces a close down of the client that created the specified \a resource.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_kill_client_checked(xcb_connection_t*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12353</i><br>
	 * @deprecated use the safer method {@link #xcb_kill_client_checked(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_kill_client_checked(Pointer c, int resource);
	/**
	 * @brief kills a client<br>
	 * @param c The connection<br>
	 * @param resource Any resource belonging to the client (for example a Window), used to identify<br>
	 * the client connection.<br>
	 * \n<br>
	 * The special value of `XCB_KILL_ALL_TEMPORARY`, the resources of all clients<br>
	 * that have terminated in `RetainTemporary` (TODO) are destroyed.<br>
	 * @return A cookie<br>
	 * Forces a close down of the client that created the specified \a resource.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_kill_client_checked(xcb_connection_t*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12353</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_kill_client_checked(PointerByReference c, int resource);
	/**
	 * @brief kills a client<br>
	 * @param c The connection<br>
	 * @param resource Any resource belonging to the client (for example a Window), used to identify<br>
	 * the client connection.<br>
	 * \n<br>
	 * The special value of `XCB_KILL_ALL_TEMPORARY`, the resources of all clients<br>
	 * that have terminated in `RetainTemporary` (TODO) are destroyed.<br>
	 * @return A cookie<br>
	 * Forces a close down of the client that created the specified \a resource.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_kill_client(xcb_connection_t*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12371</i><br>
	 * @deprecated use the safer method {@link #xcb_kill_client(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_kill_client(Pointer c, int resource);
	/**
	 * @brief kills a client<br>
	 * @param c The connection<br>
	 * @param resource Any resource belonging to the client (for example a Window), used to identify<br>
	 * the client connection.<br>
	 * \n<br>
	 * The special value of `XCB_KILL_ALL_TEMPORARY`, the resources of all clients<br>
	 * that have terminated in `RetainTemporary` (TODO) are destroyed.<br>
	 * @return A cookie<br>
	 * Forces a close down of the client that created the specified \a resource.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_kill_client(xcb_connection_t*, uint32_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12371</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_kill_client(PointerByReference c, int resource);
	/**
	 * Original signature : <code>int xcb_rotate_properties_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12375</i>
	 */
	int xcb_rotate_properties_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_rotate_properties_checked(xcb_connection_t*, xcb_window_t, uint16_t, int16_t, const xcb_atom_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12389</i><br>
	 * @deprecated use the safer methods {@link #xcb_rotate_properties_checked(com.sun.jna.ptr.PointerByReference, int, short, short, java.nio.IntBuffer)} and {@link #xcb_rotate_properties_checked(com.sun.jna.ptr.PointerByReference, int, short, short, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_rotate_properties_checked(Pointer c, int window, short atoms_len, short delta, IntByReference atoms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_rotate_properties_checked(xcb_connection_t*, xcb_window_t, uint16_t, int16_t, const xcb_atom_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12389</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_rotate_properties_checked(PointerByReference c, int window, short atoms_len, short delta, IntBuffer atoms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_rotate_properties_checked(xcb_connection_t*, xcb_window_t, uint16_t, int16_t, const xcb_atom_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12389</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_rotate_properties_checked(PointerByReference c, int window, short atoms_len, short delta, IntByReference atoms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_rotate_properties(xcb_connection_t*, xcb_window_t, uint16_t, int16_t, const xcb_atom_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12404</i><br>
	 * @deprecated use the safer methods {@link #xcb_rotate_properties(com.sun.jna.ptr.PointerByReference, int, short, short, java.nio.IntBuffer)} and {@link #xcb_rotate_properties(com.sun.jna.ptr.PointerByReference, int, short, short, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_rotate_properties(Pointer c, int window, short atoms_len, short delta, IntByReference atoms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_rotate_properties(xcb_connection_t*, xcb_window_t, uint16_t, int16_t, const xcb_atom_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12404</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_rotate_properties(PointerByReference c, int window, short atoms_len, short delta, IntBuffer atoms);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_rotate_properties(xcb_connection_t*, xcb_window_t, uint16_t, int16_t, const xcb_atom_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12404</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_rotate_properties(PointerByReference c, int window, short atoms_len, short delta, IntByReference atoms);
	/**
	 * Original signature : <code>xcb_atom_t* xcb_rotate_properties_atoms(const xcb_rotate_properties_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12411</i>
	 */
	IntByReference xcb_rotate_properties_atoms(xcb_rotate_properties_request_t R);
	/**
	 * Original signature : <code>int xcb_rotate_properties_atoms_length(const xcb_rotate_properties_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12414</i>
	 */
	int xcb_rotate_properties_atoms_length(xcb_rotate_properties_request_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_rotate_properties_atoms_end(const xcb_rotate_properties_request_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12417</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_rotate_properties_atoms_end(xcb_rotate_properties_request_t R);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_force_screen_saver_checked(xcb_connection_t*, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12431</i><br>
	 * @deprecated use the safer method {@link #xcb_force_screen_saver_checked(com.sun.jna.ptr.PointerByReference, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_force_screen_saver_checked(Pointer c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_force_screen_saver_checked(xcb_connection_t*, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12431</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_force_screen_saver_checked(PointerByReference c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_force_screen_saver(xcb_connection_t*, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12443</i><br>
	 * @deprecated use the safer method {@link #xcb_force_screen_saver(com.sun.jna.ptr.PointerByReference, byte)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_force_screen_saver(Pointer c, byte mode);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_force_screen_saver(xcb_connection_t*, uint8_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12443</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_force_screen_saver(PointerByReference c, byte mode);
	/**
	 * Original signature : <code>int xcb_set_pointer_mapping_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12447</i>
	 */
	int xcb_set_pointer_mapping_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_set_pointer_mapping_cookie_t xcb_set_pointer_mapping(xcb_connection_t*, uint8_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12458</i><br>
	 * @deprecated use the safer methods {@link #xcb_set_pointer_mapping(com.sun.jna.ptr.PointerByReference, byte, byte[])} and {@link #xcb_set_pointer_mapping(com.sun.jna.ptr.PointerByReference, byte, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_set_pointer_mapping_cookie_t.ByValue xcb_set_pointer_mapping(Pointer c, byte map_len, Pointer map);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_set_pointer_mapping_cookie_t xcb_set_pointer_mapping(xcb_connection_t*, uint8_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12458</i>
	 */
	com.yi.ylwm.xcb.xcb_set_pointer_mapping_cookie_t.ByValue xcb_set_pointer_mapping(PointerByReference c, byte map_len, byte map[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_set_pointer_mapping_cookie_t xcb_set_pointer_mapping(xcb_connection_t*, uint8_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12458</i>
	 */
	com.yi.ylwm.xcb.xcb_set_pointer_mapping_cookie_t.ByValue xcb_set_pointer_mapping(PointerByReference c, byte map_len, Pointer map);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_set_pointer_mapping_cookie_t xcb_set_pointer_mapping_unchecked(xcb_connection_t*, uint8_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12474</i><br>
	 * @deprecated use the safer methods {@link #xcb_set_pointer_mapping_unchecked(com.sun.jna.ptr.PointerByReference, byte, byte[])} and {@link #xcb_set_pointer_mapping_unchecked(com.sun.jna.ptr.PointerByReference, byte, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_set_pointer_mapping_cookie_t.ByValue xcb_set_pointer_mapping_unchecked(Pointer c, byte map_len, Pointer map);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_set_pointer_mapping_cookie_t xcb_set_pointer_mapping_unchecked(xcb_connection_t*, uint8_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12474</i>
	 */
	com.yi.ylwm.xcb.xcb_set_pointer_mapping_cookie_t.ByValue xcb_set_pointer_mapping_unchecked(PointerByReference c, byte map_len, byte map[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_set_pointer_mapping_cookie_t xcb_set_pointer_mapping_unchecked(xcb_connection_t*, uint8_t, const uint8_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12474</i>
	 */
	com.yi.ylwm.xcb.xcb_set_pointer_mapping_cookie_t.ByValue xcb_set_pointer_mapping_unchecked(PointerByReference c, byte map_len, Pointer map);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_set_pointer_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_set_pointer_mapping_reply_t* xcb_set_pointer_mapping_reply(xcb_connection_t*, xcb_set_pointer_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12493</i><br>
	 * @deprecated use the safer method {@link #xcb_set_pointer_mapping_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_set_pointer_mapping_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_set_pointer_mapping_reply_t xcb_set_pointer_mapping_reply(Pointer c, com.yi.ylwm.xcb.xcb_set_pointer_mapping_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_set_pointer_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_set_pointer_mapping_reply_t* xcb_set_pointer_mapping_reply(xcb_connection_t*, xcb_set_pointer_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12493</i>
	 */
	xcb_set_pointer_mapping_reply_t xcb_set_pointer_mapping_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_set_pointer_mapping_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_get_pointer_mapping_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12498</i>
	 */
	int xcb_get_pointer_mapping_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_pointer_mapping_cookie_t xcb_get_pointer_mapping(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12509</i><br>
	 * @deprecated use the safer method {@link #xcb_get_pointer_mapping(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_pointer_mapping_cookie_t.ByValue xcb_get_pointer_mapping(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_pointer_mapping_cookie_t xcb_get_pointer_mapping(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12509</i>
	 */
	com.yi.ylwm.xcb.xcb_get_pointer_mapping_cookie_t.ByValue xcb_get_pointer_mapping(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_pointer_mapping_cookie_t xcb_get_pointer_mapping_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12523</i><br>
	 * @deprecated use the safer method {@link #xcb_get_pointer_mapping_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_pointer_mapping_cookie_t.ByValue xcb_get_pointer_mapping_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_pointer_mapping_cookie_t xcb_get_pointer_mapping_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12523</i>
	 */
	com.yi.ylwm.xcb.xcb_get_pointer_mapping_cookie_t.ByValue xcb_get_pointer_mapping_unchecked(PointerByReference c);
	/**
	 * Original signature : <code>uint8_t* xcb_get_pointer_mapping_map(const xcb_get_pointer_mapping_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12526</i>
	 */
	Pointer xcb_get_pointer_mapping_map(xcb_get_pointer_mapping_reply_t R);
	/**
	 * Original signature : <code>int xcb_get_pointer_mapping_map_length(const xcb_get_pointer_mapping_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12529</i>
	 */
	int xcb_get_pointer_mapping_map_length(xcb_get_pointer_mapping_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_get_pointer_mapping_map_end(const xcb_get_pointer_mapping_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12532</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_get_pointer_mapping_map_end(xcb_get_pointer_mapping_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_pointer_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_pointer_mapping_reply_t* xcb_get_pointer_mapping_reply(xcb_connection_t*, xcb_get_pointer_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12549</i><br>
	 * @deprecated use the safer method {@link #xcb_get_pointer_mapping_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_get_pointer_mapping_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_pointer_mapping_reply_t xcb_get_pointer_mapping_reply(Pointer c, com.yi.ylwm.xcb.xcb_get_pointer_mapping_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_pointer_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_pointer_mapping_reply_t* xcb_get_pointer_mapping_reply(xcb_connection_t*, xcb_get_pointer_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12549</i>
	 */
	xcb_get_pointer_mapping_reply_t xcb_get_pointer_mapping_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_get_pointer_mapping_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_set_modifier_mapping_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12554</i>
	 */
	int xcb_set_modifier_mapping_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_set_modifier_mapping_cookie_t xcb_set_modifier_mapping(xcb_connection_t*, uint8_t, const xcb_keycode_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12565</i><br>
	 * @deprecated use the safer methods {@link #xcb_set_modifier_mapping(com.sun.jna.ptr.PointerByReference, byte, java.nio.ByteBuffer)} and {@link #xcb_set_modifier_mapping(com.sun.jna.ptr.PointerByReference, byte, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_set_modifier_mapping_cookie_t.ByValue xcb_set_modifier_mapping(Pointer c, byte keycodes_per_modifier, Pointer keycodes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_set_modifier_mapping_cookie_t xcb_set_modifier_mapping(xcb_connection_t*, uint8_t, const xcb_keycode_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12565</i>
	 */
	com.yi.ylwm.xcb.xcb_set_modifier_mapping_cookie_t.ByValue xcb_set_modifier_mapping(PointerByReference c, byte keycodes_per_modifier, ByteBuffer keycodes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_set_modifier_mapping_cookie_t xcb_set_modifier_mapping(xcb_connection_t*, uint8_t, const xcb_keycode_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12565</i>
	 */
	com.yi.ylwm.xcb.xcb_set_modifier_mapping_cookie_t.ByValue xcb_set_modifier_mapping(PointerByReference c, byte keycodes_per_modifier, Pointer keycodes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_set_modifier_mapping_cookie_t xcb_set_modifier_mapping_unchecked(xcb_connection_t*, uint8_t, const xcb_keycode_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12581</i><br>
	 * @deprecated use the safer methods {@link #xcb_set_modifier_mapping_unchecked(com.sun.jna.ptr.PointerByReference, byte, java.nio.ByteBuffer)} and {@link #xcb_set_modifier_mapping_unchecked(com.sun.jna.ptr.PointerByReference, byte, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_set_modifier_mapping_cookie_t.ByValue xcb_set_modifier_mapping_unchecked(Pointer c, byte keycodes_per_modifier, Pointer keycodes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_set_modifier_mapping_cookie_t xcb_set_modifier_mapping_unchecked(xcb_connection_t*, uint8_t, const xcb_keycode_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12581</i>
	 */
	com.yi.ylwm.xcb.xcb_set_modifier_mapping_cookie_t.ByValue xcb_set_modifier_mapping_unchecked(PointerByReference c, byte keycodes_per_modifier, ByteBuffer keycodes);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_set_modifier_mapping_cookie_t xcb_set_modifier_mapping_unchecked(xcb_connection_t*, uint8_t, const xcb_keycode_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12581</i>
	 */
	com.yi.ylwm.xcb.xcb_set_modifier_mapping_cookie_t.ByValue xcb_set_modifier_mapping_unchecked(PointerByReference c, byte keycodes_per_modifier, Pointer keycodes);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_set_modifier_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_set_modifier_mapping_reply_t* xcb_set_modifier_mapping_reply(xcb_connection_t*, xcb_set_modifier_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12600</i><br>
	 * @deprecated use the safer method {@link #xcb_set_modifier_mapping_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_set_modifier_mapping_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_set_modifier_mapping_reply_t xcb_set_modifier_mapping_reply(Pointer c, com.yi.ylwm.xcb.xcb_set_modifier_mapping_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_set_modifier_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_set_modifier_mapping_reply_t* xcb_set_modifier_mapping_reply(xcb_connection_t*, xcb_set_modifier_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12600</i>
	 */
	xcb_set_modifier_mapping_reply_t xcb_set_modifier_mapping_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_set_modifier_mapping_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * Original signature : <code>int xcb_get_modifier_mapping_sizeof(const void*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12605</i>
	 */
	int xcb_get_modifier_mapping_sizeof(Pointer _buffer);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_modifier_mapping_cookie_t xcb_get_modifier_mapping(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12616</i><br>
	 * @deprecated use the safer method {@link #xcb_get_modifier_mapping(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_modifier_mapping_cookie_t.ByValue xcb_get_modifier_mapping(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_get_modifier_mapping_cookie_t xcb_get_modifier_mapping(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12616</i>
	 */
	com.yi.ylwm.xcb.xcb_get_modifier_mapping_cookie_t.ByValue xcb_get_modifier_mapping(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_modifier_mapping_cookie_t xcb_get_modifier_mapping_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12630</i><br>
	 * @deprecated use the safer method {@link #xcb_get_modifier_mapping_unchecked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_get_modifier_mapping_cookie_t.ByValue xcb_get_modifier_mapping_unchecked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * placed in the event queue.<br>
	 * Original signature : <code>xcb_get_modifier_mapping_cookie_t xcb_get_modifier_mapping_unchecked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12630</i>
	 */
	com.yi.ylwm.xcb.xcb_get_modifier_mapping_cookie_t.ByValue xcb_get_modifier_mapping_unchecked(PointerByReference c);
	/**
	 * Original signature : <code>xcb_keycode_t* xcb_get_modifier_mapping_keycodes(const xcb_get_modifier_mapping_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12633</i>
	 */
	Pointer xcb_get_modifier_mapping_keycodes(xcb_get_modifier_mapping_reply_t R);
	/**
	 * Original signature : <code>int xcb_get_modifier_mapping_keycodes_length(const xcb_get_modifier_mapping_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12636</i>
	 */
	int xcb_get_modifier_mapping_keycodes_length(xcb_get_modifier_mapping_reply_t R);
	/**
	 * Original signature : <code>xcb_generic_iterator_t xcb_get_modifier_mapping_keycodes_end(const xcb_get_modifier_mapping_reply_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12639</i>
	 */
	com.yi.ylwm.xcb.xcb_generic_iterator_t.ByValue xcb_get_modifier_mapping_keycodes_end(xcb_get_modifier_mapping_reply_t R);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_modifier_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_modifier_mapping_reply_t* xcb_get_modifier_mapping_reply(xcb_connection_t*, xcb_get_modifier_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12656</i><br>
	 * @deprecated use the safer method {@link #xcb_get_modifier_mapping_reply(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_get_modifier_mapping_cookie_t.ByValue, com.yi.ylwm.xcb.xcb_generic_error_t.ByReference[])} instead
	 */
	@Deprecated 
	xcb_get_modifier_mapping_reply_t xcb_get_modifier_mapping_reply(Pointer c, com.yi.ylwm.xcb.xcb_get_modifier_mapping_cookie_t.ByValue cookie, PointerByReference e);
	/**
	 * Return the reply<br>
	 * @param c      The connection<br>
	 * @param cookie The cookie<br>
	 * @param e      The xcb_generic_error_t supplied<br>
	 * Returns the reply of the request asked by<br>
	 * The parameter @p e supplied to this function must be NULL if<br>
	 * xcb_get_modifier_mapping_unchecked(). is used.<br>
	 * Otherwise, it stores the error if any.<br>
	 * The returned value must be freed by the caller using free().<br>
	 * Original signature : <code>xcb_get_modifier_mapping_reply_t* xcb_get_modifier_mapping_reply(xcb_connection_t*, xcb_get_modifier_mapping_cookie_t, xcb_generic_error_t**)</code><br>
	 * @param cookie <<br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12656</i>
	 */
	xcb_get_modifier_mapping_reply_t xcb_get_modifier_mapping_reply(PointerByReference c, com.yi.ylwm.xcb.xcb_get_modifier_mapping_cookie_t.ByValue cookie, xcb_generic_error_t.ByReference e[]);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_no_operation_checked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12672</i><br>
	 * @deprecated use the safer method {@link #xcb_no_operation_checked(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_no_operation_checked(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * This form can be used only if the request will not cause<br>
	 * a reply to be generated. Any returned error will be<br>
	 * saved for handling by xcb_request_check().<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_no_operation_checked(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12672</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_no_operation_checked(PointerByReference c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_no_operation(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12683</i><br>
	 * @deprecated use the safer method {@link #xcb_no_operation(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_no_operation(Pointer c);
	/**
	 * * @param c The connection<br>
	 * @return A cookie<br>
	 * Delivers a request to the X server.<br>
	 * Original signature : <code>xcb_void_cookie_t xcb_no_operation(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xproto.h:12683</i>
	 */
	com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue xcb_no_operation(PointerByReference c);
	/**
	 * @brief Forces any buffered output to be written to the server.<br>
	 * @param c The connection to the X server.<br>
	 * @return > @c 0 on success, <= @c 0 otherwise.<br>
	 * Forces any buffered output to be written to the server. Blocks<br>
	 * until the write is complete.<br>
	 * Original signature : <code>int xcb_flush(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:225</i><br>
	 * @deprecated use the safer method {@link #xcb_flush(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int xcb_flush(Pointer c);
	/**
	 * @brief Forces any buffered output to be written to the server.<br>
	 * @param c The connection to the X server.<br>
	 * @return > @c 0 on success, <= @c 0 otherwise.<br>
	 * Forces any buffered output to be written to the server. Blocks<br>
	 * until the write is complete.<br>
	 * Original signature : <code>int xcb_flush(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:225</i>
	 */
	int xcb_flush(PointerByReference c);
	/**
	 * @brief Returns the maximum request length that this server accepts.<br>
	 * @param c The connection to the X server.<br>
	 * @return The maximum request length field.<br>
	 * In the absence of the BIG-REQUESTS extension, returns the<br>
	 * maximum request length field from the connection setup data, which<br>
	 * may be as much as 65535. If the server supports BIG-REQUESTS, then<br>
	 * the maximum request length field from the reply to the<br>
	 * BigRequestsEnable request will be returned instead.<br>
	 * Note that this length is measured in four-byte units, making the<br>
	 * theoretical maximum lengths roughly 256kB without BIG-REQUESTS and<br>
	 * 16GB with.<br>
	 * Original signature : <code>uint32_t xcb_get_maximum_request_length(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:242</i><br>
	 * @deprecated use the safer method {@link #xcb_get_maximum_request_length(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int xcb_get_maximum_request_length(Pointer c);
	/**
	 * @brief Returns the maximum request length that this server accepts.<br>
	 * @param c The connection to the X server.<br>
	 * @return The maximum request length field.<br>
	 * In the absence of the BIG-REQUESTS extension, returns the<br>
	 * maximum request length field from the connection setup data, which<br>
	 * may be as much as 65535. If the server supports BIG-REQUESTS, then<br>
	 * the maximum request length field from the reply to the<br>
	 * BigRequestsEnable request will be returned instead.<br>
	 * Note that this length is measured in four-byte units, making the<br>
	 * theoretical maximum lengths roughly 256kB without BIG-REQUESTS and<br>
	 * 16GB with.<br>
	 * Original signature : <code>uint32_t xcb_get_maximum_request_length(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:242</i>
	 */
	int xcb_get_maximum_request_length(PointerByReference c);
	/**
	 * @brief Prefetch the maximum request length without blocking.<br>
	 * @param c The connection to the X server.<br>
	 * Without blocking, does as much work as possible toward computing<br>
	 * the maximum request length accepted by the X server.<br>
	 * Invoking this function may cause a call to xcb_big_requests_enable,<br>
	 * but will not block waiting for the reply.<br>
	 * xcb_get_maximum_request_length will return the prefetched data<br>
	 * after possibly blocking while the reply is retrieved.<br>
	 * Note that in order for this function to be fully non-blocking, the<br>
	 * application must previously have called<br>
	 * xcb_prefetch_extension_data(c, &xcb_big_requests_id) and the reply<br>
	 * must have already arrived.<br>
	 * Original signature : <code>void xcb_prefetch_maximum_request_length(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:261</i><br>
	 * @deprecated use the safer method {@link #xcb_prefetch_maximum_request_length(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void xcb_prefetch_maximum_request_length(Pointer c);
	/**
	 * @brief Prefetch the maximum request length without blocking.<br>
	 * @param c The connection to the X server.<br>
	 * Without blocking, does as much work as possible toward computing<br>
	 * the maximum request length accepted by the X server.<br>
	 * Invoking this function may cause a call to xcb_big_requests_enable,<br>
	 * but will not block waiting for the reply.<br>
	 * xcb_get_maximum_request_length will return the prefetched data<br>
	 * after possibly blocking while the reply is retrieved.<br>
	 * Note that in order for this function to be fully non-blocking, the<br>
	 * application must previously have called<br>
	 * xcb_prefetch_extension_data(c, &xcb_big_requests_id) and the reply<br>
	 * must have already arrived.<br>
	 * Original signature : <code>void xcb_prefetch_maximum_request_length(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:261</i>
	 */
	void xcb_prefetch_maximum_request_length(PointerByReference c);
	/**
	 * @brief Returns the next event or error from the server.<br>
	 * @param c The connection to the X server.<br>
	 * @return The next event from the server.<br>
	 * Returns the next event or error from the server, or returns null in<br>
	 * the event of an I/O error. Blocks until either an event or error<br>
	 * arrive, or an I/O error occurs.<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_wait_for_event(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:275</i><br>
	 * @deprecated use the safer method {@link #xcb_wait_for_event(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb_generic_event_t xcb_wait_for_event(Pointer c);
	/**
	 * @brief Returns the next event or error from the server.<br>
	 * @param c The connection to the X server.<br>
	 * @return The next event from the server.<br>
	 * Returns the next event or error from the server, or returns null in<br>
	 * the event of an I/O error. Blocks until either an event or error<br>
	 * arrive, or an I/O error occurs.<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_wait_for_event(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:275</i>
	 */
	xcb_generic_event_t xcb_wait_for_event(PointerByReference c);
	/**
	 * @brief Returns the next event or error from the server.<br>
	 * @param c The connection to the X server.<br>
	 * @return The next event from the server.<br>
	 * Returns the next event or error from the server, if one is<br>
	 * available, or returns @c NULL otherwise. If no event is available, that<br>
	 * might be because an I/O error like connection close occurred while<br>
	 * attempting to read the next event, in which case the connection is<br>
	 * shut down when this function returns.<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_poll_for_event(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:288</i><br>
	 * @deprecated use the safer method {@link #xcb_poll_for_event(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb_generic_event_t xcb_poll_for_event(Pointer c);
	/**
	 * @brief Returns the next event or error from the server.<br>
	 * @param c The connection to the X server.<br>
	 * @return The next event from the server.<br>
	 * Returns the next event or error from the server, if one is<br>
	 * available, or returns @c NULL otherwise. If no event is available, that<br>
	 * might be because an I/O error like connection close occurred while<br>
	 * attempting to read the next event, in which case the connection is<br>
	 * shut down when this function returns.<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_poll_for_event(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:288</i>
	 */
	xcb_generic_event_t xcb_poll_for_event(PointerByReference c);
	/**
	 * @brief Returns the next event without reading from the connection.<br>
	 * @param c The connection to the X server.<br>
	 * @return The next already queued event from the server.<br>
	 * This is a version of xcb_poll_for_event that only examines the<br>
	 * event queue for new events. The function doesn't try to read new<br>
	 * events from the connection if no queued events are found.<br>
	 * This function is useful for callers that know in advance that all<br>
	 * interesting events have already been read from the connection. For<br>
	 * example, callers might use xcb_wait_for_reply and be interested<br>
	 * only of events that preceded a specific reply.<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_poll_for_queued_event(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:304</i><br>
	 * @deprecated use the safer method {@link #xcb_poll_for_queued_event(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb_generic_event_t xcb_poll_for_queued_event(Pointer c);
	/**
	 * @brief Returns the next event without reading from the connection.<br>
	 * @param c The connection to the X server.<br>
	 * @return The next already queued event from the server.<br>
	 * This is a version of xcb_poll_for_event that only examines the<br>
	 * event queue for new events. The function doesn't try to read new<br>
	 * events from the connection if no queued events are found.<br>
	 * This function is useful for callers that know in advance that all<br>
	 * interesting events have already been read from the connection. For<br>
	 * example, callers might use xcb_wait_for_reply and be interested<br>
	 * only of events that preceded a specific reply.<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_poll_for_queued_event(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:304</i>
	 */
	xcb_generic_event_t xcb_poll_for_queued_event(PointerByReference c);
	/**
	 * @brief Returns the next event from a special queue<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_poll_for_special_event(xcb_connection_t*, xcb_special_event_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:311</i><br>
	 * @deprecated use the safer method {@link #xcb_poll_for_special_event(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb_generic_event_t xcb_poll_for_special_event(Pointer c, Pointer se);
	/**
	 * @brief Returns the next event from a special queue<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_poll_for_special_event(xcb_connection_t*, xcb_special_event_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:311</i>
	 */
	xcb_generic_event_t xcb_poll_for_special_event(PointerByReference c, PointerByReference se);
	/**
	 * @brief Returns the next event from a special queue, blocking until one arrives<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_wait_for_special_event(xcb_connection_t*, xcb_special_event_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:317</i><br>
	 * @deprecated use the safer method {@link #xcb_wait_for_special_event(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb_generic_event_t xcb_wait_for_special_event(Pointer c, Pointer se);
	/**
	 * @brief Returns the next event from a special queue, blocking until one arrives<br>
	 * Original signature : <code>xcb_generic_event_t* xcb_wait_for_special_event(xcb_connection_t*, xcb_special_event_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:317</i>
	 */
	xcb_generic_event_t xcb_wait_for_special_event(PointerByReference c, PointerByReference se);
	/**
	 * @brief Listen for a special event<br>
	 * Original signature : <code>xcb_special_event_t* xcb_register_for_special_xge(xcb_connection_t*, xcb_extension_t*, uint32_t, uint32_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:327</i><br>
	 * @deprecated use the safer methods {@link #xcb_register_for_special_xge(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference, int, java.nio.IntBuffer)} and {@link #xcb_register_for_special_xge(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	PointerByReference xcb_register_for_special_xge(Pointer c, Pointer ext, int eid, IntByReference stamp);
	/**
	 * @brief Listen for a special event<br>
	 * Original signature : <code>xcb_special_event_t* xcb_register_for_special_xge(xcb_connection_t*, xcb_extension_t*, uint32_t, uint32_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:327</i>
	 */
	PointerByReference xcb_register_for_special_xge(PointerByReference c, PointerByReference ext, int eid, IntBuffer stamp);
	/**
	 * @brief Listen for a special event<br>
	 * Original signature : <code>xcb_special_event_t* xcb_register_for_special_xge(xcb_connection_t*, xcb_extension_t*, uint32_t, uint32_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:327</i>
	 */
	PointerByReference xcb_register_for_special_xge(PointerByReference c, PointerByReference ext, int eid, IntByReference stamp);
	/**
	 * @brief Stop listening for a special event<br>
	 * Original signature : <code>void xcb_unregister_for_special_event(xcb_connection_t*, xcb_special_event_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:335</i><br>
	 * @deprecated use the safer method {@link #xcb_unregister_for_special_event(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void xcb_unregister_for_special_event(Pointer c, Pointer se);
	/**
	 * @brief Stop listening for a special event<br>
	 * Original signature : <code>void xcb_unregister_for_special_event(xcb_connection_t*, xcb_special_event_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:335</i>
	 */
	void xcb_unregister_for_special_event(PointerByReference c, PointerByReference se);
	/**
	 * @brief Return the error for a request, or NULL if none can ever arrive.<br>
	 * @param c The connection to the X server.<br>
	 * @param cookie The request cookie.<br>
	 * @return The error for the request, or NULL if none can ever arrive.<br>
	 * The xcb_void_cookie_t cookie supplied to this function must have resulted<br>
	 * from a call to xcb_[request_name]_checked().  This function will block<br>
	 * until one of two conditions happens.  If an error is received, it will be<br>
	 * returned.  If a reply to a subsequent request has already arrived, no error<br>
	 * can arrive for this request, so this function will return NULL.<br>
	 * Note that this function will perform a sync if needed to ensure that the<br>
	 * sequence number will advance beyond that provided in cookie; this is a<br>
	 * convenience to avoid races in determining whether the sync is needed.<br>
	 * Original signature : <code>xcb_generic_error_t* xcb_request_check(xcb_connection_t*, xcb_void_cookie_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:354</i><br>
	 * @deprecated use the safer method {@link #xcb_request_check(com.sun.jna.ptr.PointerByReference, com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue)} instead
	 */
	@Deprecated 
	xcb_generic_error_t xcb_request_check(Pointer c, com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue cookie);
	/**
	 * @brief Return the error for a request, or NULL if none can ever arrive.<br>
	 * @param c The connection to the X server.<br>
	 * @param cookie The request cookie.<br>
	 * @return The error for the request, or NULL if none can ever arrive.<br>
	 * The xcb_void_cookie_t cookie supplied to this function must have resulted<br>
	 * from a call to xcb_[request_name]_checked().  This function will block<br>
	 * until one of two conditions happens.  If an error is received, it will be<br>
	 * returned.  If a reply to a subsequent request has already arrived, no error<br>
	 * can arrive for this request, so this function will return NULL.<br>
	 * Note that this function will perform a sync if needed to ensure that the<br>
	 * sequence number will advance beyond that provided in cookie; this is a<br>
	 * convenience to avoid races in determining whether the sync is needed.<br>
	 * Original signature : <code>xcb_generic_error_t* xcb_request_check(xcb_connection_t*, xcb_void_cookie_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:354</i>
	 */
	xcb_generic_error_t xcb_request_check(PointerByReference c, com.yi.ylwm.xcb.xcb_void_cookie_t.ByValue cookie);
	/**
	 * @brief Discards the reply for a request.<br>
	 * @param c The connection to the X server.<br>
	 * @param sequence The request sequence number from a cookie.<br>
	 * Discards the reply for a request. Additionally, any error generated<br>
	 * by the request is also discarded (unless it was an _unchecked request<br>
	 * and the error has already arrived).<br>
	 * This function will not block even if the reply is not yet available.<br>
	 * Note that the sequence really does have to come from an xcb cookie;<br>
	 * this function is not designed to operate on socket-handoff replies.<br>
	 * Original signature : <code>void xcb_discard_reply(xcb_connection_t*, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:370</i><br>
	 * @deprecated use the safer method {@link #xcb_discard_reply(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	void xcb_discard_reply(Pointer c, int sequence);
	/**
	 * @brief Discards the reply for a request.<br>
	 * @param c The connection to the X server.<br>
	 * @param sequence The request sequence number from a cookie.<br>
	 * Discards the reply for a request. Additionally, any error generated<br>
	 * by the request is also discarded (unless it was an _unchecked request<br>
	 * and the error has already arrived).<br>
	 * This function will not block even if the reply is not yet available.<br>
	 * Note that the sequence really does have to come from an xcb cookie;<br>
	 * this function is not designed to operate on socket-handoff replies.<br>
	 * Original signature : <code>void xcb_discard_reply(xcb_connection_t*, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:370</i>
	 */
	void xcb_discard_reply(PointerByReference c, int sequence);
	/**
	 * @brief Discards the reply for a request, given by a 64bit sequence number<br>
	 * @param c The connection to the X server.<br>
	 * @param sequence 64-bit sequence number as returned by xcb_send_request64().<br>
	 * Discards the reply for a request. Additionally, any error generated<br>
	 * by the request is also discarded (unless it was an _unchecked request<br>
	 * and the error has already arrived).<br>
	 * This function will not block even if the reply is not yet available.<br>
	 * Note that the sequence really does have to come from xcb_send_request64();<br>
	 * the cookie sequence number is defined as "unsigned" int and therefore<br>
	 * not 64-bit on all platforms.<br>
	 * This function is not designed to operate on socket-handoff replies.<br>
	 * Unlike its xcb_discard_reply() counterpart, the given sequence number is not<br>
	 * automatically "widened" to 64-bit.<br>
	 * Original signature : <code>void xcb_discard_reply64(xcb_connection_t*, uint64_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:391</i><br>
	 * @deprecated use the safer method {@link #xcb_discard_reply64(com.sun.jna.ptr.PointerByReference, long)} instead
	 */
	@Deprecated 
	void xcb_discard_reply64(Pointer c, long sequence);
	/**
	 * @brief Discards the reply for a request, given by a 64bit sequence number<br>
	 * @param c The connection to the X server.<br>
	 * @param sequence 64-bit sequence number as returned by xcb_send_request64().<br>
	 * Discards the reply for a request. Additionally, any error generated<br>
	 * by the request is also discarded (unless it was an _unchecked request<br>
	 * and the error has already arrived).<br>
	 * This function will not block even if the reply is not yet available.<br>
	 * Note that the sequence really does have to come from xcb_send_request64();<br>
	 * the cookie sequence number is defined as "unsigned" int and therefore<br>
	 * not 64-bit on all platforms.<br>
	 * This function is not designed to operate on socket-handoff replies.<br>
	 * Unlike its xcb_discard_reply() counterpart, the given sequence number is not<br>
	 * automatically "widened" to 64-bit.<br>
	 * Original signature : <code>void xcb_discard_reply64(xcb_connection_t*, uint64_t)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:391</i>
	 */
	void xcb_discard_reply64(PointerByReference c, long sequence);
	/**
	 * @brief Caches reply information from QueryExtension requests.<br>
	 * @param c The connection.<br>
	 * @param ext The extension data.<br>
	 * @return A pointer to the xcb_query_extension_reply_t for the extension.<br>
	 * This function is the primary interface to the "extension cache",<br>
	 * which caches reply information from QueryExtension<br>
	 * requests. Invoking this function may cause a call to<br>
	 * xcb_query_extension to retrieve extension information from the<br>
	 * server, and may block until extension data is received from the<br>
	 * server.<br>
	 * The result must not be freed. This storage is managed by the cache<br>
	 * itself.<br>
	 * Original signature : <code>xcb_query_extension_reply_t* xcb_get_extension_data(xcb_connection_t*, xcb_extension_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:411</i><br>
	 * @deprecated use the safer method {@link #xcb_get_extension_data(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb_query_extension_reply_t xcb_get_extension_data(Pointer c, Pointer ext);
	/**
	 * @brief Caches reply information from QueryExtension requests.<br>
	 * @param c The connection.<br>
	 * @param ext The extension data.<br>
	 * @return A pointer to the xcb_query_extension_reply_t for the extension.<br>
	 * This function is the primary interface to the "extension cache",<br>
	 * which caches reply information from QueryExtension<br>
	 * requests. Invoking this function may cause a call to<br>
	 * xcb_query_extension to retrieve extension information from the<br>
	 * server, and may block until extension data is received from the<br>
	 * server.<br>
	 * The result must not be freed. This storage is managed by the cache<br>
	 * itself.<br>
	 * Original signature : <code>xcb_query_extension_reply_t* xcb_get_extension_data(xcb_connection_t*, xcb_extension_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:411</i>
	 */
	xcb_query_extension_reply_t xcb_get_extension_data(PointerByReference c, PointerByReference ext);
	/**
	 * @brief Prefetch of extension data into the extension cache<br>
	 * @param c The connection.<br>
	 * @param ext The extension data.<br>
	 * This function allows a "prefetch" of extension data into the<br>
	 * extension cache. Invoking the function may cause a call to<br>
	 * xcb_query_extension, but will not block waiting for the<br>
	 * reply. xcb_get_extension_data will return the prefetched data after<br>
	 * possibly blocking while it is retrieved.<br>
	 * Original signature : <code>void xcb_prefetch_extension_data(xcb_connection_t*, xcb_extension_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:424</i><br>
	 * @deprecated use the safer method {@link #xcb_prefetch_extension_data(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void xcb_prefetch_extension_data(Pointer c, Pointer ext);
	/**
	 * @brief Prefetch of extension data into the extension cache<br>
	 * @param c The connection.<br>
	 * @param ext The extension data.<br>
	 * This function allows a "prefetch" of extension data into the<br>
	 * extension cache. Invoking the function may cause a call to<br>
	 * xcb_query_extension, but will not block waiting for the<br>
	 * reply. xcb_get_extension_data will return the prefetched data after<br>
	 * possibly blocking while it is retrieved.<br>
	 * Original signature : <code>void xcb_prefetch_extension_data(xcb_connection_t*, xcb_extension_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:424</i>
	 */
	void xcb_prefetch_extension_data(PointerByReference c, PointerByReference ext);
	/**
	 * @brief Access the data returned by the server.<br>
	 * @param c The connection.<br>
	 * @return A pointer to an xcb_setup_t structure.<br>
	 * Accessor for the data returned by the server when the xcb_connection_t<br>
	 * was initialized. This data includes<br>
	 * - the server's required format for images,<br>
	 * - a list of available visuals,<br>
	 * - a list of available screens,<br>
	 * - the server's maximum request length (in the absence of the<br>
	 * BIG-REQUESTS extension),<br>
	 * - and other assorted information.<br>
	 * See the X protocol specification for more details.<br>
	 * The result must not be freed.<br>
	 * Original signature : <code>xcb_setup_t* xcb_get_setup(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:447</i><br>
	 * @deprecated use the safer method {@link #xcb_get_setup(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	xcb_setup_t xcb_get_setup(Pointer c);
	/**
	 * @brief Access the data returned by the server.<br>
	 * @param c The connection.<br>
	 * @return A pointer to an xcb_setup_t structure.<br>
	 * Accessor for the data returned by the server when the xcb_connection_t<br>
	 * was initialized. This data includes<br>
	 * - the server's required format for images,<br>
	 * - a list of available visuals,<br>
	 * - a list of available screens,<br>
	 * - the server's maximum request length (in the absence of the<br>
	 * BIG-REQUESTS extension),<br>
	 * - and other assorted information.<br>
	 * See the X protocol specification for more details.<br>
	 * The result must not be freed.<br>
	 * Original signature : <code>xcb_setup_t* xcb_get_setup(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:447</i>
	 */
	xcb_setup_t xcb_get_setup(PointerByReference c);
	/**
	 * @brief Access the file descriptor of the connection.<br>
	 * @param c The connection.<br>
	 * @return The file descriptor.<br>
	 * Accessor for the file descriptor that was passed to the<br>
	 * xcb_connect_to_fd call that returned @p c.<br>
	 * Original signature : <code>int xcb_get_file_descriptor(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:457</i><br>
	 * @deprecated use the safer method {@link #xcb_get_file_descriptor(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int xcb_get_file_descriptor(Pointer c);
	/**
	 * @brief Access the file descriptor of the connection.<br>
	 * @param c The connection.<br>
	 * @return The file descriptor.<br>
	 * Accessor for the file descriptor that was passed to the<br>
	 * xcb_connect_to_fd call that returned @p c.<br>
	 * Original signature : <code>int xcb_get_file_descriptor(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:457</i>
	 */
	int xcb_get_file_descriptor(PointerByReference c);
	/**
	 * @brief Test whether the connection has shut down due to a fatal error.<br>
	 * @param c The connection.<br>
	 * @return > 0 if the connection is in an error state; 0 otherwise.<br>
	 * Some errors that occur in the context of an xcb_connection_t<br>
	 * are unrecoverable. When such an error occurs, the<br>
	 * connection is shut down and further operations on the<br>
	 * xcb_connection_t have no effect, but memory will not be freed until<br>
	 * xcb_disconnect() is called on the xcb_connection_t.<br>
	 * @return XCB_CONN_ERROR, because of socket errors, pipe errors or other stream errors.<br>
	 * @return XCB_CONN_CLOSED_EXT_NOTSUPPORTED, when extension not supported.<br>
	 * @return XCB_CONN_CLOSED_MEM_INSUFFICIENT, when memory not available.<br>
	 * @return XCB_CONN_CLOSED_REQ_LEN_EXCEED, exceeding request length that server accepts.<br>
	 * @return XCB_CONN_CLOSED_PARSE_ERR, error during parsing display string.<br>
	 * @return XCB_CONN_CLOSED_INVALID_SCREEN, because the server does not have a screen matching the display.<br>
	 * Original signature : <code>int xcb_connection_has_error(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:477</i><br>
	 * @deprecated use the safer method {@link #xcb_connection_has_error(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int xcb_connection_has_error(Pointer c);
	/**
	 * @brief Test whether the connection has shut down due to a fatal error.<br>
	 * @param c The connection.<br>
	 * @return > 0 if the connection is in an error state; 0 otherwise.<br>
	 * Some errors that occur in the context of an xcb_connection_t<br>
	 * are unrecoverable. When such an error occurs, the<br>
	 * connection is shut down and further operations on the<br>
	 * xcb_connection_t have no effect, but memory will not be freed until<br>
	 * xcb_disconnect() is called on the xcb_connection_t.<br>
	 * @return XCB_CONN_ERROR, because of socket errors, pipe errors or other stream errors.<br>
	 * @return XCB_CONN_CLOSED_EXT_NOTSUPPORTED, when extension not supported.<br>
	 * @return XCB_CONN_CLOSED_MEM_INSUFFICIENT, when memory not available.<br>
	 * @return XCB_CONN_CLOSED_REQ_LEN_EXCEED, exceeding request length that server accepts.<br>
	 * @return XCB_CONN_CLOSED_PARSE_ERR, error during parsing display string.<br>
	 * @return XCB_CONN_CLOSED_INVALID_SCREEN, because the server does not have a screen matching the display.<br>
	 * Original signature : <code>int xcb_connection_has_error(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:477</i>
	 */
	int xcb_connection_has_error(PointerByReference c);
	/**
	 * @brief Connects to the X server.<br>
	 * @param fd The file descriptor.<br>
	 * @param auth_info Authentication data.<br>
	 * @return A newly allocated xcb_connection_t structure.<br>
	 * Connects to an X server, given the open socket @p fd and the<br>
	 * xcb_auth_info_t @p auth_info. The file descriptor @p fd is<br>
	 * bidirectionally connected to an X server. If the connection<br>
	 * should be unauthenticated, @p auth_info must be @c<br>
	 * NULL.<br>
	 * Always returns a non-NULL pointer to a xcb_connection_t, even on failure.<br>
	 * Callers need to use xcb_connection_has_error() to check for failure.<br>
	 * When finished, use xcb_disconnect() to close the connection and free<br>
	 * the structure.<br>
	 * Original signature : <code>xcb_connection_t* xcb_connect_to_fd(int, xcb_auth_info_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:496</i>
	 */
	PointerByReference xcb_connect_to_fd(int fd, xcb_auth_info_t auth_info);
	/**
	 * @brief Closes the connection.<br>
	 * @param c The connection.<br>
	 * Closes the file descriptor and frees all memory associated with the<br>
	 * connection @c c. If @p c is @c NULL, nothing is done.<br>
	 * Original signature : <code>void xcb_disconnect(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:505</i><br>
	 * @deprecated use the safer method {@link #xcb_disconnect(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void xcb_disconnect(Pointer c);
	/**
	 * @brief Closes the connection.<br>
	 * @param c The connection.<br>
	 * Closes the file descriptor and frees all memory associated with the<br>
	 * connection @c c. If @p c is @c NULL, nothing is done.<br>
	 * Original signature : <code>void xcb_disconnect(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:505</i>
	 */
	void xcb_disconnect(PointerByReference c);
	/**
	 * @brief Parses a display string name in the form documented by X(7x).<br>
	 * @param name The name of the display.<br>
	 * @param host A pointer to a malloc'd copy of the hostname.<br>
	 * @param display A pointer to the display number.<br>
	 * @param screen A pointer to the screen number.<br>
	 * @return 0 on failure, non 0 otherwise.<br>
	 * Parses the display string name @p display_name in the form<br>
	 * documented by X(7x). Has no side effects on failure. If<br>
	 * @p displayname is @c NULL or empty, it uses the environment<br>
	 * variable DISPLAY. @p hostp is a pointer to a newly allocated string<br>
	 * that contain the host name. @p displayp is set to the display<br>
	 * number and @p screenp to the preferred screen number. @p screenp<br>
	 * can be @c NULL. If @p displayname does not contain a screen number,<br>
	 * it is set to @c 0.<br>
	 * Original signature : <code>int xcb_parse_display(const char*, char**, int*, int*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:527</i><br>
	 * @deprecated use the safer methods {@link #xcb_parse_display(java.lang.String, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #xcb_parse_display(com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	int xcb_parse_display(Pointer name, PointerByReference host, IntByReference display, IntByReference screen);
	/**
	 * @brief Parses a display string name in the form documented by X(7x).<br>
	 * @param name The name of the display.<br>
	 * @param host A pointer to a malloc'd copy of the hostname.<br>
	 * @param display A pointer to the display number.<br>
	 * @param screen A pointer to the screen number.<br>
	 * @return 0 on failure, non 0 otherwise.<br>
	 * Parses the display string name @p display_name in the form<br>
	 * documented by X(7x). Has no side effects on failure. If<br>
	 * @p displayname is @c NULL or empty, it uses the environment<br>
	 * variable DISPLAY. @p hostp is a pointer to a newly allocated string<br>
	 * that contain the host name. @p displayp is set to the display<br>
	 * number and @p screenp to the preferred screen number. @p screenp<br>
	 * can be @c NULL. If @p displayname does not contain a screen number,<br>
	 * it is set to @c 0.<br>
	 * Original signature : <code>int xcb_parse_display(const char*, char**, int*, int*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:527</i>
	 */
	int xcb_parse_display(String name, PointerByReference host, IntBuffer display, IntBuffer screen);
	/**
	 * @brief Connects to the X server.<br>
	 * @param displayname The name of the display.<br>
	 * @param screenp A pointer to a preferred screen number.<br>
	 * @return A newly allocated xcb_connection_t structure.<br>
	 * Connects to the X server specified by @p displayname. If @p<br>
	 * displayname is @c NULL, uses the value of the DISPLAY environment<br>
	 * variable. If a particular screen on that server is preferred, the<br>
	 * int pointed to by @p screenp (if not @c NULL) will be set to that<br>
	 * screen; otherwise the screen will be set to 0.<br>
	 * Always returns a non-NULL pointer to a xcb_connection_t, even on failure.<br>
	 * Callers need to use xcb_connection_has_error() to check for failure.<br>
	 * When finished, use xcb_disconnect() to close the connection and free<br>
	 * the structure.<br>
	 * Original signature : <code>xcb_connection_t* xcb_connect(const char*, int*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:546</i><br>
	 * @deprecated use the safer methods {@link #xcb_connect(java.lang.String, java.nio.IntBuffer)} and {@link #xcb_connect(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	PointerByReference xcb_connect(Pointer displayname, IntByReference screenp);
	/**
	 * @brief Connects to the X server.<br>
	 * @param displayname The name of the display.<br>
	 * @param screenp A pointer to a preferred screen number.<br>
	 * @return A newly allocated xcb_connection_t structure.<br>
	 * Connects to the X server specified by @p displayname. If @p<br>
	 * displayname is @c NULL, uses the value of the DISPLAY environment<br>
	 * variable. If a particular screen on that server is preferred, the<br>
	 * int pointed to by @p screenp (if not @c NULL) will be set to that<br>
	 * screen; otherwise the screen will be set to 0.<br>
	 * Always returns a non-NULL pointer to a xcb_connection_t, even on failure.<br>
	 * Callers need to use xcb_connection_has_error() to check for failure.<br>
	 * When finished, use xcb_disconnect() to close the connection and free<br>
	 * the structure.<br>
	 * Original signature : <code>xcb_connection_t* xcb_connect(const char*, int*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:546</i>
	 */
	PointerByReference xcb_connect(String displayname, IntBuffer screenp);
	/**
	 * @brief Connects to the X server, using an authorization information.<br>
	 * @param display The name of the display.<br>
	 * @param auth The authorization information.<br>
	 * @param screen A pointer to a preferred screen number.<br>
	 * @return A newly allocated xcb_connection_t structure.<br>
	 * Connects to the X server specified by @p displayname, using the<br>
	 * authorization @p auth. If a particular screen on that server is<br>
	 * preferred, the int pointed to by @p screenp (if not @c NULL) will<br>
	 * be set to that screen; otherwise @p screenp will be set to 0.<br>
	 * Always returns a non-NULL pointer to a xcb_connection_t, even on failure.<br>
	 * Callers need to use xcb_connection_has_error() to check for failure.<br>
	 * When finished, use xcb_disconnect() to close the connection and free<br>
	 * the structure.<br>
	 * Original signature : <code>xcb_connection_t* xcb_connect_to_display_with_auth_info(const char*, xcb_auth_info_t*, int*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:565</i><br>
	 * @deprecated use the safer methods {@link #xcb_connect_to_display_with_auth_info(java.lang.String, com.yi.ylwm.xcb.xcb_auth_info_t, java.nio.IntBuffer)} and {@link #xcb_connect_to_display_with_auth_info(com.sun.jna.Pointer, com.yi.ylwm.xcb.xcb_auth_info_t, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	PointerByReference xcb_connect_to_display_with_auth_info(Pointer display, xcb_auth_info_t auth, IntByReference screen);
	/**
	 * @brief Connects to the X server, using an authorization information.<br>
	 * @param display The name of the display.<br>
	 * @param auth The authorization information.<br>
	 * @param screen A pointer to a preferred screen number.<br>
	 * @return A newly allocated xcb_connection_t structure.<br>
	 * Connects to the X server specified by @p displayname, using the<br>
	 * authorization @p auth. If a particular screen on that server is<br>
	 * preferred, the int pointed to by @p screenp (if not @c NULL) will<br>
	 * be set to that screen; otherwise @p screenp will be set to 0.<br>
	 * Always returns a non-NULL pointer to a xcb_connection_t, even on failure.<br>
	 * Callers need to use xcb_connection_has_error() to check for failure.<br>
	 * When finished, use xcb_disconnect() to close the connection and free<br>
	 * the structure.<br>
	 * Original signature : <code>xcb_connection_t* xcb_connect_to_display_with_auth_info(const char*, xcb_auth_info_t*, int*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:565</i>
	 */
	PointerByReference xcb_connect_to_display_with_auth_info(String display, xcb_auth_info_t auth, IntBuffer screen);
	/**
	 * @brief Allocates an XID for a new object.<br>
	 * @param c The connection.<br>
	 * @return A newly allocated XID.<br>
	 * Allocates an XID for a new object. Typically used just prior to<br>
	 * various object creation functions, such as xcb_create_window.<br>
	 * Original signature : <code>uint32_t xcb_generate_id(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:578</i><br>
	 * @deprecated use the safer method {@link #xcb_generate_id(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int xcb_generate_id(Pointer c);
	/**
	 * @brief Allocates an XID for a new object.<br>
	 * @param c The connection.<br>
	 * @return A newly allocated XID.<br>
	 * Allocates an XID for a new object. Typically used just prior to<br>
	 * various object creation functions, such as xcb_create_window.<br>
	 * Original signature : <code>uint32_t xcb_generate_id(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:578</i>
	 */
	int xcb_generate_id(PointerByReference c);
	/**
	 * @brief Obtain number of bytes read from the connection.<br>
	 * @param c The connection<br>
	 * @return Number of bytes read from the server.<br>
	 * Returns cumulative number of bytes received from the connection.<br>
	 * This retrieves the total number of bytes read from this connection,<br>
	 * to be used for diagnostic/monitoring/informative purposes.<br>
	 * Original signature : <code>uint64_t xcb_total_read(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:592</i><br>
	 * @deprecated use the safer method {@link #xcb_total_read(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	long xcb_total_read(Pointer c);
	/**
	 * @brief Obtain number of bytes read from the connection.<br>
	 * @param c The connection<br>
	 * @return Number of bytes read from the server.<br>
	 * Returns cumulative number of bytes received from the connection.<br>
	 * This retrieves the total number of bytes read from this connection,<br>
	 * to be used for diagnostic/monitoring/informative purposes.<br>
	 * Original signature : <code>uint64_t xcb_total_read(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:592</i>
	 */
	long xcb_total_read(PointerByReference c);
	/**
	 * * @brief Obtain number of bytes written to the connection.<br>
	 * @param c The connection<br>
	 * @return Number of bytes written to the server.<br>
	 * Returns cumulative number of bytes sent to the connection.<br>
	 * This retrieves the total number of bytes written to this connection,<br>
	 * to be used for diagnostic/monitoring/informative purposes.<br>
	 * Original signature : <code>uint64_t xcb_total_written(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:607</i><br>
	 * @deprecated use the safer method {@link #xcb_total_written(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	long xcb_total_written(Pointer c);
	/**
	 * * @brief Obtain number of bytes written to the connection.<br>
	 * @param c The connection<br>
	 * @return Number of bytes written to the server.<br>
	 * Returns cumulative number of bytes sent to the connection.<br>
	 * This retrieves the total number of bytes written to this connection,<br>
	 * to be used for diagnostic/monitoring/informative purposes.<br>
	 * Original signature : <code>uint64_t xcb_total_written(xcb_connection_t*)</code><br>
	 * <i>native declaration : /usr/include/xcb/xcb.h:607</i>
	 */
	long xcb_total_written(PointerByReference c);
	public static class xcb_special_event_t extends PointerType {
		public xcb_special_event_t(Pointer address) {
			super(address);
		}
		public xcb_special_event_t() {
			super();
		}
	};
	public static class xcb_extension_t extends PointerType {
		public xcb_extension_t(Pointer address) {
			super(address);
		}
		public xcb_extension_t() {
			super();
		}
	};
	public static class xcb_connection_t extends PointerType {
		public xcb_connection_t(Pointer address) {
			super(address);
		}
		public xcb_connection_t() {
			super();
		}
	};
}
